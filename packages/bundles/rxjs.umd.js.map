{"version":3,"file":"rxjs.umd.js","sources":["../../src/internal/types.ts","../../src/internal/util/sinkFromHandlers.ts","../../src/internal/util/noop.ts","../../src/internal/util/isSubscription.ts","../../src/internal/util/userFunction.ts","../../src/internal/util/UnsubscriptionError.ts","../../src/internal/Subscription.ts","../../src/internal/util/identity.ts","../../src/internal/util/pipe.ts","../../src/internal/util/sinkFromObserver.ts","../../src/internal/util/isPartialObserver.ts","../../src/internal/util/sourceAsObservable.ts","../../src/internal/util/sourceAsSubject.ts","../../src/internal/util/ObjectUnsubscribedError.ts","../../src/internal/sources/subjectBaseSource.ts","../../src/internal/Subject.ts","../../src/internal/AsyncSubject.ts","../../src/internal/BehaviorSubject.ts","../../src/internal/ConnectableObservable.ts","../../src/internal/EMPTY.ts","../../src/internal/create/of.ts","../../src/internal/create/throwError.ts","../../src/internal/Notification.ts","../../src/internal/RxSubscriber.ts","../../src/internal/Observable.ts","../../src/internal/util/hostReportError.ts","../../src/internal/Subscriber.ts","../../src/internal/ReplaySubject.ts","../../src/internal/NEVER.ts","../../src/internal/util/isArrayLike.ts","../../src/internal/util/isPromiseLike.ts","../../src/internal/util/isIterable.ts","../../src/internal/util/symbolObservable.ts","../../src/internal/util/isInteropObservable.ts","../../src/internal/util/symbolAsyncIterator.ts","../../src/internal/util/isAsyncIterable.ts","../../src/internal/util/isObservable.ts","../../src/internal/sources/asyncIterableSource.ts","../../src/internal/sources/symbolObservableSource.ts","../../src/internal/sources/iterableSource.ts","../../src/internal/sources/promiseSource.ts","../../src/internal/sources/fromSource.ts","../../src/internal/create/combineLatest.ts","../../src/internal/util/lift.ts","../../src/internal/operators/mergeMap.ts","../../src/internal/operators/derived/mergeAll.ts","../../src/internal/operators/derived/concatAll.ts","../../src/internal/create/concat.ts","../../src/internal/create/defer.ts","../../src/internal/create/forkJoin.ts","../../src/internal/create/from.ts","../../src/internal/create/fromEvent.ts","../../src/internal/create/fromEventPattern.ts","../../src/internal/create/fromScheduled.ts","../../src/internal/create/iif.ts","../../src/internal/scheduler/asyncScheduler.ts","../../src/internal/create/interval.ts","../../src/internal/create/merge.ts","../../src/internal/util/isObserver.ts","../../src/internal/create/multicast.ts","../../src/internal/RecyclableSubscription.ts","../../src/internal/create/onEmptyResumeNext.ts","../../src/internal/create/onErrorResumeNext.ts","../../src/internal/operators/filter.ts","../../src/internal/create/partition.ts","../../src/internal/create/pairs.ts","../../src/internal/create/publish.ts","../../src/internal/create/publishBehavior.ts","../../src/internal/create/publishLast.ts","../../src/internal/create/publishReplay.ts","../../src/internal/create/race.ts","../../src/internal/create/range.ts","../../src/internal/util/isNumeric.ts","../../src/internal/util/isScheduler.ts","../../src/internal/create/timer.ts","../../src/internal/create/using.ts","../../src/internal/create/zip.ts","../../src/internal/util/ArgumentOutOfRangeError.ts","../../src/internal/util/EmptyError.ts","../../src/internal/util/TimeoutError.ts","../../src/internal/scheduler/animationFrameScheduler.ts","../../src/internal/scheduler/asapScheduler.ts","../../src/internal/scheduler/QueueScheduler.ts","../../src/internal/scheduler/VirtualTimeScheduler.ts"],"sourcesContent":["import { Subscription } from 'rxjs/internal/Subscription';\nimport { Observable } from 'rxjs/internal/Observable';\n\nexport const enum FOType {\n  SUBSCRIBE = 0,\n  NEXT = 1,\n  COMPLETE = 2,\n  ERROR = 3,\n  DISPOSE = 4,\n}\n\nexport type SinkArg<T> = T | void | any;\n\nexport interface DisposableFObs {\n  (type: FOType.DISPOSE, arg: void, subs: Subscription): void;\n}\n\nexport interface Sink<T> {\n  (type: FOType.NEXT, value: T, subs: Subscription): void;\n  (type: FOType.ERROR, err: any, subs: Subscription): void;\n  (type: FOType.COMPLETE, arg: void, subs: Subscription): void;\n  (type: FOType, arg: FObsArg<T>, subs: Subscription): void;\n}\n\nexport interface Source<T> {\n  (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription): void;\n}\n\nexport interface FObs<T> extends Source<T>, Sink<T> {\n  (type: FOType, arg: FObsArg<T>, subs: Subscription): void;\n}\n\nexport type FObsArg<T> = SinkArg<T> | void;\n\nexport type TeardownLogic = Unsubscribable | (() => void) | void;\n\nexport interface NextObserver<T> {\n  next: (value: T, subscription: Subscription) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n  [key: string]: any;\n}\n\nexport interface ErrorObserver<T> {\n  next?: (value: T, subscription: Subscription) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n  [key: string]: any;\n}\n\nexport interface CompleteObserver<T> {\n  next?: (value: T, subscription: Subscription) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n  [key: string]: any;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompleteObserver<T>;\n\nexport interface Observer<T> {\n  next: (value: T, subscription?: Subscription) => void;\n  error: (err: any) => void;\n  complete: () => void;\n  [key: string]: any;\n}\n\nexport interface SchedulerLike {\n  now(): number;\n  schedule<T>(work: () => void): Subscription;\n  schedule<T>(work: () => void, delay: number): Subscription;\n  schedule<T>(work: (state?: T) => void, delay: number, state: T): Subscription;\n  schedule<T>(work: (state?: T) => void, delay: number, state: T, subs: Subscription): Subscription;\n}\n\nexport type OperatorFunction<T, R> = (source: Observable<T>) => Observable<R>;\n\nexport interface ObservableLike<T> {\n  subscribe(observer: Observer<T>): Unsubscribable;\n}\n\nexport interface InteropObservable<T> {\n  [Symbol.observable](): ObservableLike<T>;\n}\n\nexport type ObservableInput<T> = Observable<T> | ObservableLike<T> | PromiseLike<T> |\n  Array<T> | ArrayLike<T> | InteropObservable<T> | AsyncIterable<T> | Iterable<T>;\n\nexport interface Unsubscribable {\n  unsubscribe(): void;\n}\n\nexport interface SubscriptionLike extends Unsubscribable {\n  unsubscribe(): void;\n  closed: boolean;\n}\n\nexport interface GroupedObservable<K, T> extends Observable<T> {\n  readonly key: K;\n}\n\nexport interface NotificationLike<T> {\n  kind: 'N'|'E'|'C';\n  value?: T;\n  error?: any;\n}\n\nexport interface Timestamped<T> {\n  value: T,\n  timestamp: number;\n}\n\ndeclare global  {\n  interface SymbolConstructor {\n    readonly observable: symbol;\n  }\n}\n\nexport type MonoTypeOperatorFunction<T> = OperatorFunction<T, T>;\n","import { FOType, SinkArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\nexport function sinkFromHandlers<T>(\n  nextHandler: null|void|((value: T, subscription: Subscription) => void),\n  errorHandler: null|void|((err: any) => void),\n  completeHandler: null|void|(() => void)) {\n  return (type: FOType, arg: SinkArg<T>, subs: Subscription) => {\n    switch (type) {\n      case FOType.NEXT:\n        if (typeof nextHandler === 'function') {\n          nextHandler(arg, subs);\n        }\n        break;\n      case FOType.ERROR:\n        if (typeof errorHandler === 'function') {\n          errorHandler(arg);\n        }\n        break;\n      case FOType.COMPLETE:\n        if (typeof completeHandler === 'function') {\n          completeHandler();\n        }\n        break;\n      default:\n        break;\n    }\n  };\n}\n","export function noop() {\n  /* no op */\n}\n","import { Subscription } from \"rxjs/internal/Subscription\";\n\nexport function isSubscription(obj: any): obj is Subscription {\n  return obj && typeof obj.unsubscribe === 'function'\n    && typeof obj.add === 'function'\n    && typeof obj.remove=== 'function' ;\n}\n","const ERROR_OBJECT = {\n  error: null as any,\n};\n\n/**\n * Executes a user-provided function within a try-catch, and returns either the result\n * or returns {@link ERROR_OBJECT} if an error has occurred. Use {@link resultIsError} to\n * verify whether the result is an error or not.\n *\n * @param fn the user-provided function to wrap in some error handling for safety\n * @param args The arguments to execute the user-provided function with.\n */\nexport function tryUserFunction<R>(fn: (...args: any[]) => R, ...args: any[]): typeof ERROR_OBJECT | R {\n  ERROR_OBJECT.error = null;\n  let result: R;\n  try {\n    result = fn(...args);\n  } catch (err) {\n    ERROR_OBJECT.error = err;\n    return ERROR_OBJECT;\n  }\n  return result;\n}\n\n/**\n * Used to verify whether the result of {@link tryUserFunction} is an error or not. If\n * this returns true, check {@link ERROR_OBJECT}'s error property for the error value.\n */\nexport function resultIsError<R>(result: R|typeof ERROR_OBJECT): result is typeof ERROR_OBJECT {\n  return result === ERROR_OBJECT;\n}\n","export interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  new(errors: any[]): UnsubscriptionError;\n}\n\nfunction UnsubscriptionErrorImpl(this: any, errors: any[]) {\n  Error.call(this);\n  this.message = errors ?\n  `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '';\n  this.name = 'UnsubscriptionError';\n  this.errors = errors;\n  return this;\n}\n\nUnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = UnsubscriptionErrorImpl as any;\n","import { TeardownLogic } from 'rxjs/internal/types';\nimport { noop } from 'rxjs/internal/util/noop';\nimport { isSubscription } from 'rxjs/internal/util/isSubscription';\nimport { tryUserFunction, resultIsError } from './util/userFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n\nexport interface Subscription {\n  unsubscribe(): void;\n  add(...teardowns: TeardownLogic[]): void;\n  remove(...teardowns: TeardownLogic[]): void;\n  readonly closed: boolean;\n}\n\nexport interface SubscriptionConstructor {\n  new(): Subscription;\n  new(...teardowns: TeardownLogic[]): Subscription;\n  EMPTY: Subscription\n}\n\nexport interface SubscriptionContext {\n  _teardowns: TeardownLogic[];\n  _closed: boolean;\n}\n\nexport const Subscription: SubscriptionConstructor = function Subscription(this: SubscriptionContext, ...teardowns: TeardownLogic[]) {\n  this._teardowns = teardowns;\n  this._closed = false;\n} as any;\n\nconst EMPTY_SUBSCRIPTION = new Subscription();\n(EMPTY_SUBSCRIPTION as any)._closed = true;\n\nSubscription.EMPTY = EMPTY_SUBSCRIPTION;\n\nconst subscriptionProto = Subscription.prototype;\n\nsubscriptionProto.add = function (...teardowns: TeardownLogic[]) {\n  const { _teardowns } = this;\n  for (let teardown of teardowns) {\n    if (teardown) {\n      if (this._closed) {\n        teardownToFunction(teardown)();\n      } else {\n        if (isSubscription(teardown)) {\n          teardown.add(() => this.remove(teardown));\n        }\n        _teardowns.push(teardown);\n      }\n    }\n  }\n}\n\nsubscriptionProto.remove = function (...teardowns: TeardownLogic[]) {\n  const { _teardowns } = this;\n  for (let teardown of teardowns) {\n    if (teardown) {\n      const i = _teardowns.indexOf(teardown);\n      if (i >= 0) {\n        _teardowns.splice(i, 1);\n      }\n    }\n  }\n};\n\nsubscriptionProto.unsubscribe = function () {\n  if (!this._closed) {\n    this._closed = true;\n    const { _teardowns } = this;\n    let unsubError: UnsubscriptionError;\n\n    while (_teardowns.length > 0) {\n      const result = tryUserFunction(teardownToFunction(_teardowns.shift()));\n      if (resultIsError(result)) {\n        const err = result.error;\n        unsubError = unsubError || new UnsubscriptionError(err instanceof UnsubscriptionError ? err.errors : []);\n        unsubError.errors.push(err);\n      }\n    }\n    if (unsubError) throw unsubError;\n  }\n};\n\nObject.defineProperty(subscriptionProto, 'closed', {\n  get() {\n    return this._closed;\n  },\n});\n\nexport function teardownToFunction(teardown: any): () => void {\n  if (teardown) {\n    if (typeof teardown.unsubscribe === 'function') {\n      return () => teardown.unsubscribe();\n    } else if (typeof teardown === 'function') {\n      return teardown;\n    }\n  }\n  return noop;\n}\n","export function identity<T>(x: T) {\n  return x;\n}\n","import { identity } from \"rxjs/internal/util/identity\";\n\nexport function pipe<T>(): (value: T) => T;\nexport function pipe<A, R>(fnA: (value: A) => R): (value: A) => R;\nexport function pipe<A, B, R>(fnA: (value: A) => B, fnB: (value: B) => R): (value: A) => R;\nexport function pipe<A, B, C, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => R): (value: A) => R;\nexport function pipe<A, B, C, D, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, F, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => F, fnF: (value: F) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, F, G, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => F, fnF: (value: F) => G, fnG: (value: G) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, F, G, H, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => F, fnF: (value: F) => G, fnG: (value: G) => H, fnH: (value: H) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, F, G, H, I, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => F, fnF: (value: F) => G, fnG: (value: G) => H, fnH: (value: H) => I, fnI: (value: I) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, F, G, H, I, J, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => F, fnF: (value: F) => G, fnG: (value: G) => H, fnH: (value: H) => I, fnI: (value: I) => J, fnJ: (value: J) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => F, fnF: (value: F) => G, fnG: (value: G) => H, fnH: (value: H) => I, fnI: (value: I) => J, fnJ: (value: J) => K, fnK: (value: K) => R): (value: A) => R;\n\nexport function pipe<T>(...fns: Array<(value: any) => any>): (value: T) => any {\n  return pipeArray(fns);\n}\n\nexport function pipeArray<T>(fns: Array<(value: any) => any>): (value: T) => any {\n  if (fns.length <= 0) {\n    return identity;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return (x: T) => fns.reduce((prev, fn) => fn(prev), x);\n}\n","import { PartialObserver, FOType, Sink, SinkArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\nexport function sinkFromObserver<T>(observer: PartialObserver<T>): Sink<T> {\n  return (type: FOType, arg: SinkArg<T>, subs: Subscription) => {\n    switch (type) {\n      case FOType.NEXT:\n        if (typeof observer.next === 'function') {\n          observer.next(arg, subs);\n        }\n        break;\n      case FOType.ERROR:\n        if (typeof observer.error === 'function') {\n          observer.error(arg);\n        }\n        break;\n      case FOType.COMPLETE:\n        if (typeof observer.complete === 'function') {\n          observer.complete();\n        }\n        break;\n      default:\n        break;\n    }\n  };\n}\n","import { PartialObserver } from \"../types\";\n\n/**\n * Because Subjects are `typeof \"function\"`, we have this method to test to\n * see if something is a partial observer. Technically, anything with at least a `next`,\n * `error`, or `complete` method is a partial observer, and as a legacy, any object,\n * even if it doesn't have any of those methods, is considered a `PartialObserver`.\n *\n * In the future, we will probably want to restrict this only to values with some\n * combination of `next`, `error`, or `complete` methods on them.\n * @param o the value to test\n */\nexport function isPartialObserver(o: any): o is PartialObserver<any> {\n  return o && (\n    typeof o === 'object' ||\n    typeof o.next === 'function' ||\n    typeof o.error === 'function' ||\n    typeof o.complete === 'function'\n  );\n}\n","import { sinkFromHandlers } from 'rxjs/internal/util/sinkFromHandlers';\nimport { OperatorFunction, PartialObserver, FOType, Sink, Source, SinkArg, FObsArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { pipeArray } from 'rxjs/internal/util/pipe';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { sinkFromObserver } from 'rxjs/internal/util/sinkFromObserver';\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\nimport { isPartialObserver } from './isPartialObserver';\n\nexport function sourceAsObservable<T>(source: Source<T>): Observable<T> {\n  const result = source as Observable<T>;\n  result.subscribe = subscribe;\n  result.pipe = observablePipe;\n  result.forEach = forEach;\n  result.toPromise = toPromise;\n  if (Symbol && Symbol.observable) {\n    result[Symbol.observable] = () => result;\n  }\n  return result;\n}\n\nfunction subscribe<T>(this: Source<T>, nextOrObserver?: PartialObserver<T> | ((value: T, subscription: Subscription) => void), errorHandler?: (err: any) => void, completeHandler?: () => void) {\n  const subscription = new Subscription();\n  ;\n  let sink: Sink<T>;\n  if (nextOrObserver || errorHandler || completeHandler) {\n    if (isPartialObserver(nextOrObserver)) {\n      sink = sinkFromObserver(nextOrObserver);\n    }\n    else {\n      sink = sinkFromHandlers(nextOrObserver as any, errorHandler, completeHandler);\n    }\n  }\n  else {\n    sink = () => { };\n  }\n  this(FOType.SUBSCRIBE, safeSink(sink), subscription);\n  return subscription;\n}\n\nfunction safeSink<T>(sink: Sink<T>) {\n  return (type: FOType, arg: FObsArg<T>, subs: Subscription) => {\n    if (subs.closed) {\n      if (type === FOType.ERROR) {\n        console.warn('Error thrown after subscription closed', arg);\n      }\n    } else {\n      sink(type, arg, subs);\n      if (type >= 2) {\n        subs.unsubscribe();\n      }\n    }\n  }\n}\n\nfunction forEach<T>(this: Observable<T>, nextHandler: (value: T) => void, subscription?: Subscription): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    let completed = false;\n    let errored = false;\n    if (subscription) {\n      subscription.add(() => {\n        if (!completed && !errored) {\n          const error = new Error('forEach aborted');\n          error.name = 'AbortError';\n          reject(error);\n        }\n      });\n    }\n    subscription = subscription || new Subscription();\n    this(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, subs: Subscription) => {\n      if (subs.closed) {\n        return;\n      }\n      switch (t) {\n        case FOType.NEXT:\n          const result = tryUserFunction(nextHandler, v);\n          if (resultIsError(result)) {\n            errored = true;\n            reject(result.error);\n            subs.unsubscribe();\n          }\n          break;\n        case FOType.COMPLETE:\n          completed = true;\n          resolve();\n          subs.unsubscribe();\n          break;\n        case FOType.ERROR:\n          errored = true;\n          reject(v);\n          subs.unsubscribe();\n          break;\n        default:\n          break;\n      }\n    }, subscription);\n  });\n}\nfunction toPromise<T>(this: Observable<T>): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    this.subscribe({\n      _last: undefined,\n      next(value) { this._last = value; },\n      error(err) { reject(err); },\n      complete() { resolve(this._last); }\n    });\n  });\n}\n\nfunction observablePipe<T>(this: Observable<T>, ...operations: Array<OperatorFunction<T, T>>): Observable<T> {\n  return pipeArray(operations)(this);\n}\n","import { FOType, FObsArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subject } from 'rxjs/internal/Subject';\n\nexport function sourceAsSubject<T>(source: any): Subject<T> {\n  source = sourceAsObservable(source) as Subject<T>;\n  source.next = next;\n  source.error = error;\n  source.complete = complete;\n  source.unsubscribe = unsubscribe;\n  source.asObservable = asObservable;\n  return source;\n}\n\nfunction next<T>(this: Subject<T>, value: T, subs: Subscription) {\n  this(FOType.NEXT, value, subs);\n}\n\n// NOTE: For error and complete, subscription doesn't matter, as\n// we are passing it from state\n\nfunction error<T>(this: Subject<T>, err: any) {\n  this(FOType.ERROR, err, undefined);\n}\n\nfunction complete<T>(this: Subject<T>) {\n  this(FOType.COMPLETE, undefined, undefined);\n}\n\nfunction unsubscribe<T>(this: Subject<T>) {\n  this(FOType.DISPOSE, undefined, undefined);\n}\n\nfunction asObservable<T>(this: Subject<T>) {\n  return sourceAsObservable((t: FOType, v: FObsArg<T>, subs: Subscription) => {\n    this(t, v, subs);\n  });\n}\n","export interface ObjectUnsubscribedError extends Error {\n}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  new(): ObjectUnsubscribedError;\n}\n\nfunction ObjectUnsubscribedErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'object unsubscribed';\n  this.name = 'ObjectUnsubscribedError';\n  return this;\n}\n\nObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = ObjectUnsubscribedErrorImpl as any;\n","import { FOType, FObsArg, FObs } from \"rxjs/internal/types\";\nimport { Subscription } from \"rxjs/internal/Subscription\";\nimport { ObjectUnsubscribedError } from \"../util/ObjectUnsubscribedError\";\n\nexport function subjectBaseSource<T>(): FObs<T> {\n  let state: any[];\n  let disposed = false;\n  return (type: FOType, arg: FObsArg<T>, subs: Subscription) => {\n    if (disposed) {\n      throw new ObjectUnsubscribedError();\n    }\n    if (type === FOType.SUBSCRIBE) {\n      state = (state || []);\n      state.push(arg, subs);\n      subs.add(() => {\n        if (!state) return;\n        const i = state.indexOf(arg);\n        state.splice(i, 2);\n      });\n    } else if (type === FOType.DISPOSE) {\n      disposed = true;\n      state = null;\n    } else if (state) {\n      const copy = state.slice();\n      if (type !== FOType.NEXT) {\n        state = undefined;\n      }\n      for (let i = 0; i < copy.length; i += 2) {\n        copy[i](type, arg, copy[i + 1]);\n      }\n    }\n  };\n}\n","import { Observer, FOType, FObsArg, FObs, Sink, Source } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { sourceAsSubject } from 'rxjs/internal/util/sourceAsSubject';\nimport { subjectBaseSource } from 'rxjs/internal/sources/subjectBaseSource';\nimport { sinkFromObserver } from \"rxjs/internal/util/sinkFromObserver\";\nimport { isPartialObserver } from './util/isPartialObserver';\n\nexport interface Subject<O, I=O> extends Observer<I>, Observable<O> {\n  unsubscribe(): void;\n  asObservable(): Observable<O>;\n}\n\nexport interface SubjectConstructor {\n  <T>(): Subject<T>;\n  <O, I>(observer: Observer<I>, observable: Observable<O>): Subject<O, I>;\n  new<T>(): Subject<T>;\n}\n\nexport const Subject: SubjectConstructor =  (function Subject<T>(observer?: Observer<T>, observable?: Observable<T>) {\n  return sourceAsSubject(\n    arguments.length > 0\n    ? frankenSubjectSource(\n      sinkFromObserver(observer),\n      observable,\n    )\n    : subjectSource<T>()\n  )\n}) as any;\n\nexport function frankenSubjectSource<O, I>(\n  sink: Sink<I>,\n  source: Source<O>\n) {\n  return (type: FOType, arg: FObsArg<O|I>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      source(type, arg, subs);\n    } else {\n      sink(type, arg, subs);\n    }\n  };\n}\n\nexport function subjectSource<T>(): FObs<T> {\n  const base = subjectBaseSource<T>();\n  let _completed = false;\n  let _hasError = false;\n  let _error: any;\n  let _disposed = false;\n\n  return (type: FOType, arg: FObsArg<T>, subs: Subscription) => {\n    if (type === FOType.DISPOSE) {\n      _disposed = true;\n    }\n\n    if (type === FOType.SUBSCRIBE) {\n      if (_completed) {\n        arg(FOType.COMPLETE, undefined, subs);\n      } else if (_hasError) {\n        arg(FOType.ERROR, _error, subs);\n      }\n    }\n\n    if (_disposed || (!_completed && !_hasError)) {\n      if (type === FOType.COMPLETE) {\n        _completed = true;\n      } else if (type === FOType.ERROR) {\n        _hasError = true;\n        _error = arg;\n      }\n      base(type, arg, subs);\n    }\n  };\n}\n","import { Subject, subjectSource } from 'rxjs/internal/Subject';\nimport { FOType, FObsArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { sourceAsSubject } from 'rxjs/internal/util/sourceAsSubject';\n\n\nexport interface AsyncSubjectConstructor {\n  new <T>(): AsyncSubject<T>;\n}\n\nexport interface AsyncSubject<T> extends Subject<T> {\n}\n\nexport const AsyncSubject: AsyncSubjectConstructor = (<T>() => {\n  let hasValue = false;\n  let hasCompleted = false;\n  let hasError = false;\n  let value: T;\n  const subject = subjectSource<T>();\n\n  let result = ((type: FOType, arg: FObsArg<T>, subs: Subscription) => {\n    if (!hasError) {\n      switch (type) {\n        case FOType.SUBSCRIBE:\n          if (hasCompleted && hasValue) {\n            arg(FOType.NEXT, value, subs);\n          }\n          break;\n        case FOType.NEXT:\n          if (!hasCompleted && !hasError) {\n            hasValue = true;\n            value = arg;\n          }\n          return;\n        case FOType.ERROR:\n          hasError = true;\n          break;\n        case FOType.COMPLETE:\n          hasCompleted = true;\n          if (hasValue) {\n            subject(FOType.NEXT, value, subs);\n          }\n          break;\n      }\n    }\n    subject(type, arg, subs);\n  }) as AsyncSubject<T>;\n\n  result = sourceAsSubject(result) as AsyncSubject<T>;\n  return result;\n}) as any;\n\n","import { Subject, subjectSource } from 'rxjs/internal/Subject';\nimport { FOType, FObsArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { sourceAsSubject } from 'rxjs/internal/util/sourceAsSubject';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\n\n\nexport interface BehaviorSubjectConstructor {\n  new <T>(initialValue: T): BehaviorSubject<T>;\n}\n\nexport interface BehaviorSubject<T> extends Subject<T> {\n  getValue(): T;\n}\n\nexport const BehaviorSubject: BehaviorSubjectConstructor = (<T>(initialValue: T) => {\n  let completed = false;\n  let value = initialValue;\n  let hasError = false;\n  let disposed = false;\n  let error: any;\n  const subject = subjectSource<T>();\n\n  let result = ((type: FOType, arg: FObsArg<T>, subs: Subscription) => {\n    switch (type) {\n      case FOType.SUBSCRIBE:\n        if (!completed && !hasError) {\n          arg(FOType.NEXT, value, subs);\n        }\n        break;\n      case FOType.NEXT:\n        value = arg;\n        break;\n      case FOType.ERROR:\n        hasError = true;\n        error = arg;\n        break;\n      case FOType.COMPLETE:\n        completed = true;\n        break;\n      case FOType.DISPOSE:\n        disposed = true;\n        break;\n    }\n    subject(type, arg, subs);\n  }) as BehaviorSubject<T>;\n\n  result = sourceAsSubject(result) as BehaviorSubject<T>;\n  result.getValue = () => {\n    if (disposed) throw new ObjectUnsubscribedError();\n    if (hasError) throw error;\n    return value;\n  };\n  Object.defineProperty(result, 'value', {\n    get() {\n      return value\n    }\n  })\n  return result;\n}) as any;\n\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { Subject } from 'rxjs/internal/Subject';\nimport { FOType, Sink } from 'rxjs/internal/types';\n\nexport interface ConnectableObservable<T> extends Observable<T> {\n  connect(): Subscription;\n  refCount(): Observable<T>;\n}\n\nexport interface ConnectableObservableCtor {\n  new <T>(source: Observable<T>, subjectFactory: () => Subject<T>): ConnectableObservable<T>;\n}\n\nexport const ConnectableObservable: ConnectableObservableCtor = (<T>(source: Observable<T>, subjectFactory: () => Subject<T>) => {\n  let _subject: any;\n\n  let connectable = (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    _subject = _subject || subjectFactory();\n    _subject(FOType.SUBSCRIBE, sink, subs);\n  };\n\n  connectable = sourceAsObservable(connectable);\n\n  (connectable as ConnectableObservable<T>).connect = () => {\n    _subject = _subject || subjectFactory();\n    const subs = new Subscription();\n    source(FOType.SUBSCRIBE, _subject, subs);\n    return subs;\n  };\n\n  (connectable as ConnectableObservable<T>).refCount = refCount;\n\n  return connectable;\n}) as any;\n\n\nfunction refCount<T>(this: ConnectableObservable<T>) {\n  let _refCounter = 0;\n  let _connection: Subscription;\n\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    _refCounter++;\n\n    subs.add(() => {\n      _refCounter--;\n      if (_refCounter === 0) {\n        _connection.unsubscribe();\n      }\n    });\n\n    if (_refCounter === 1) {\n      _connection = this.connect();\n    }\n  });\n}\n","import { Observable } from 'rxjs/internal/Observable';\nimport { Source, FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\n\nexport const EMPTY_SOURCE: Source<never> =\n  (type: FOType.SUBSCRIBE, sink: Sink<never>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      sink(FOType.COMPLETE, undefined, subs);\n    }\n  };\n\nexport const EMPTY: Observable<never> = sourceAsObservable(EMPTY_SOURCE);\n\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink, Source } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\n/* tslint:disable:max-line-length */\nexport function of<T>(a: T): Observable<T>;\nexport function of<T, B>(a: T, b: B): Observable<T|B>;\nexport function of<T, B, C>(a: T, b: B, c: C): Observable<T|B|C>;\nexport function of<T, B, C, D>(a: T, b: B, c: C, d: D): Observable<T|B|C|D>;\nexport function of<T, B, C, D, E>(a: T, b: B, c: C, d: D, e: E): Observable<T|B|C|D|E>;\nexport function of<T, B, C, D, E, F>(a: T, b: B, c: C, d: D, e: E, f: F): Observable<T|B|C|D|E|F>;\nexport function of<T, B, C, D, E, F, G>(a: T, b: B, c: C, d: D, e: E, f: F, g: G):\n  Observable<T|B|C|D|E|F|G>;\nexport function of<T, B, C, D, E, F, G, H>(a: T, b: B, c: C, d: D, e: E, f: F, g: G, h: H):\n  Observable<T|B|C|D|E|F|G|H>;\nexport function of<T, B, C, D, E, F, G, H, I>(a: T, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I):\n  Observable<T|B|C|D|E|F|G|H|I>;\nexport function of<T>(...values: T[]): Observable<T>;\n/* tslint:enable:max-line-length */\n\nexport function of<T>(...values: T[]): Observable<T> {\n  return sourceAsObservable(ofSource(values));\n}\n\nexport function ofSource<T>(values: ArrayLike<T>): Source<T> {\n  return (type: FOType, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      for (let i = 0; i < values.length && !subs.closed; i++) {\n        if (subs.closed) return;\n        sink(FOType.NEXT, values[i], subs);\n      }\n      if (!subs.closed) sink(FOType.COMPLETE, undefined, subs);\n    }\n  };\n}\n\n\nconst x = of(1, 'test');\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\nexport function throwError(err: any): Observable<never> {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<never>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) sink(FOType.ERROR, err, subs);\n  });\n}\n","import { PartialObserver, NotificationLike } from './types';\nimport { Observable } from './Observable';\nimport { Subscription } from './Subscription';\nimport { isPartialObserver } from './util/isPartialObserver';\nimport { EMPTY } from './EMPTY';\nimport { of } from './create/of';\nimport { throwError } from './create/throwError';\n\nexport interface Notification<T> extends NotificationLike<T> {\n  /** @deprecated test `kind` for value `\"N\"` instead. */\n  hasValue: boolean;\n  observe(observer: PartialObserver<T>): void;\n  do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): void;\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) : void;\n  toObservable(): Observable<T>;\n}\n\nexport interface NotificationCtor {\n  new(kind: 'N'): Notification<void>;\n  new<T>(kind: 'N', value: T): Notification<T>;\n  new(kind: 'E', value: void, error: any): Notification<never>;\n  new(kind: 'C'): Notification<never>;\n\n  createNext(): Notification<void>;\n  createNext<T>(value: T): Notification<T>;\n  createError(error?: any): Notification<never>;\n  createComplete(): Notification<never>;\n}\n\nexport const Notification: NotificationCtor = (function <T>(this: Notification<T>, kind: 'N'|'E'|'C', value?: T, error?: any) {\n  this.kind = kind;\n  this.value = value;\n  this.error = error;\n}) as any;\n\nNotification.prototype = Object.create(Object.prototype);\nNotification.prototype.constructor = Notification;\n\nObject.defineProperty(Notification.prototype, 'hasValue', {\n  get() {\n    return this.kind === 'N';\n  }\n});\n\nNotification.prototype.observe = function <T>(observer: PartialObserver<T>, subscription?: Subscription) {\n  switch (this.kind) {\n    case 'N':\n      return observer.next && observer.next(this.value, subscription || new Subscription());\n    case 'E':\n      return observer.error && observer.error(this.error);\n    case 'C':\n      return observer.complete && observer.complete();\n  }\n};\n\nNotification.prototype.do = function<T>(next: (value: T, subscription: Subscription) => void, error?: (err: any) => void, complete?: () => void, subscription?: Subscription) {\n  const kind = this.kind;\n  switch (kind) {\n    case 'N':\n      return next && next(this.value, subscription || new Subscription());\n    case 'E':\n      return error && error(this.error);\n    case 'C':\n      return complete && complete();\n  }\n};\n\nNotification.prototype.accept = function<T>(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void, subscription?: Subscription) {\n  if (isPartialObserver(nextOrObserver)) {\n    return this.observe(<PartialObserver<T>>nextOrObserver, subscription);\n  } else {\n    return this.do(<(value: T) => void>nextOrObserver, error, complete, subscription);\n  }\n};\n\nNotification.prototype.toObservable = function<T>() {\n  const kind = this.kind;\n  switch (kind) {\n    case 'N':\n      return of(this.value);\n    case 'E':\n      return throwError(this.error);\n    case 'C':\n      return EMPTY;\n  }\n  throw new Error('unexpected notification kind value');\n}\n\nconst COMPLETE_NOTIFICATION = new Notification('C');\nconst UNDEFINED_NEXT_NOTIFICATION = new Notification('N');\n\nNotification.createNext = <T>(value?: T) => value === undefined ? UNDEFINED_NEXT_NOTIFICATION : new Notification('N', value);\n\nNotification.createError = (error: any) => new Notification('E', undefined, error);\n\nNotification.createComplete = () => COMPLETE_NOTIFICATION;\n","import { FOType, Sink, SinkArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\nexport interface RxSubscriber<T> extends Sink<T> {\n  next(value: T): void;\n  error(err: any): void;\n  complete(): void;\n  readonly closed: boolean;\n}\n\nconst CLOSED = 'closed';\n\nconst rxSubs = Symbol('rxjs subscription');\n\nexport function createSubscriber<T>(dest: Sink<T>, subs: Subscription): RxSubscriber<T> {\n  let closed = false;\n  subs.add(() => closed = true);\n  const result = ((type: FOType, arg: SinkArg<T>, subs: Subscription) => {\n    switch (type) {\n      case FOType.NEXT:\n        if (!closed) {\n          dest(FOType.NEXT, arg, subs);\n        }\n        break;\n      case FOType.ERROR:\n        if (!closed) {\n          closed = true;\n          dest(FOType.ERROR, arg, subs);\n          subs.unsubscribe();\n        }\n        break;\n      case FOType.COMPLETE:\n        if (!closed) {\n          closed = true;\n          dest(FOType.COMPLETE, undefined, subs);\n          subs.unsubscribe();\n        }\n        break;\n      default:\n    }\n  }) as RxSubscriber<T>;\n\n  result.next = next;\n  result.error = error;\n  result.complete = complete;\n  result[rxSubs] = subs;\n  Object.defineProperty(result, CLOSED, {\n    get() { return closed; },\n  });\n  return result;\n}\n\nfunction next<T>(this: RxSubscriber<T>, value: T) {\n  this(FOType.NEXT, value, this[rxSubs]);\n}\n\nfunction error<T>(this: RxSubscriber<T>, err: any) {\n  this(FOType.ERROR, err, this[rxSubs]);\n}\n\nfunction complete<T>(this: RxSubscriber<T>) {\n  this(FOType.COMPLETE, undefined, this[rxSubs]);\n}\n","import { FObs, OperatorFunction, PartialObserver, FOType, Sink, SinkArg, TeardownLogic } from 'rxjs/internal/types';\nimport { RxSubscriber, createSubscriber } from 'rxjs/internal/RxSubscriber';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\n\nexport interface ObservableConstructor {\n  <T>(init?: (subscriber: RxSubscriber<T>) => void): Observable<T>;\n  new<T>(init?: (subscriber: RxSubscriber<T>) => void): Observable<T>;\n}\n\nexport interface Observable<T> extends FObs<T> {\n  subscribe(observer: PartialObserver<T>): Subscription;\n  subscribe(\n    nextHandler?: (value: T, subscription: Subscription) => void,\n    errorHandler?: (err: any) => void,\n    completeHandler?: () => void,\n  ): Subscription;\n  subscribe(): Subscription;\n\n  forEach(nextHandler: (value: T) => void, subscription?: Subscription): Promise<void>;\n\n  toPromise(): Promise<T>;\n\n  pipe(): Observable<T>;\n  pipe<R>(op1: OperatorFunction<T, R>, ): Observable<R>;\n  pipe<A, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, R>, ): Observable<R>;\n  pipe<A, B, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, R>, ): Observable<R>;\n  pipe<A, B, C, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, R>, ): Observable<R>;\n  pipe<A, B, C, D, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, F, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op8: OperatorFunction<F, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, F, G, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op8: OperatorFunction<F, G>, op9: OperatorFunction<G, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, F, G, H, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op8: OperatorFunction<F, G>, op9: OperatorFunction<G, H>, op10: OperatorFunction<H, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, F, G, H, I, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op8: OperatorFunction<F, G>, op9: OperatorFunction<G, H>, op10: OperatorFunction<H, I>, op11: OperatorFunction<I, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, F, G, H, I, J, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op8: OperatorFunction<F, G>, op9: OperatorFunction<G, H>, op10: OperatorFunction<H, I>, op11: OperatorFunction<I, J>, op12: OperatorFunction<J, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, F, G, H, I, J, K, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op8: OperatorFunction<F, G>, op9: OperatorFunction<G, H>, op10: OperatorFunction<H, I>, op11: OperatorFunction<I, J>, op12: OperatorFunction<J, K>, op13: OperatorFunction<K, R>, ): Observable<R>;\n  pipe(...operations: Array<OperatorFunction<any, any>>): Observable<any>;\n}\n\n/** The Observable constructor */\nexport const Observable: ObservableConstructor = function <T>(init?: (subscriber: RxSubscriber<T>) => TeardownLogic) {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, dest: Sink<T>, subs: Subscription) => {\n    if (init) {\n      const subscriber = createSubscriber(dest, subs);\n      const teardown = tryUserFunction(init, subscriber);\n      if (resultIsError(teardown)) {\n        subscriber(FOType.ERROR, teardown.error, subs);\n        subs.unsubscribe();\n        return;\n      }\n      subs.add(teardown);\n    }\n  });\n} as any;\n\n\n","export function hostReportError(err: any) {\n  setTimeout(() => { throw err; });\n}\n","import { Subscription } from \"./Subscription\";\nimport { Observer, PartialObserver } from \"./types\";\nimport { hostReportError } from \"./util/hostReportError\";\n\nconst EMPTY_OBSERVER = {\n  next() {},\n  error() {},\n  complete() {}\n};\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n * @deprecated Do not use or subclass. This type is being phased out and is not used in RxJS 7.\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  /** @internal */ syncErrorValue: any = null;\n  /** @internal */ syncErrorThrown: boolean = false;\n  /** @internal */ syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: Observer<T>;\n\n  private _parentSubscription: Subscription | null = null;\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = EMPTY_OBSERVER;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = EMPTY_OBSERVER;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            this.destination = destinationOrNext;\n            destinationOrNext.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value, this);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n}\n\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n * @deprecated Do not use, legacy support for RxJS 6\n */\nexport class SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(\n    private _parentSubscriber: Subscriber<T>,\n    observerOrNext?: PartialObserver<T> | ((value: T) => void),\n    error?: (e?: any) => void,\n    complete?: () => void\n  ) {\n    super();\n\n    let next: ((value: T, subscription: Subscription) => void);\n    let context: any = this;\n\n    if (typeof observerOrNext === 'function') {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== EMPTY_OBSERVER) {\n        context = Object.create(observerOrNext);\n        if (typeof context.unsubscribe === 'function') {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = (value: T) => next(value, this);\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._error) {\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else {\n        hostReportError(err);\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      hostReportError(err);\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      hostReportError(err);\n      return true;\n    }\n    return false;\n  }\n\n  /** @internal This is an internal implementation detail, do not use. */\n  _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n","import { Subject } from 'rxjs/internal/Subject';\nimport { FOType, FObsArg, SinkArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { sourceAsSubject } from 'rxjs/internal/util/sourceAsSubject';\nimport { subjectBaseSource } from 'rxjs/internal/sources/subjectBaseSource';\n\nexport interface ReplaySubjectConstructor {\n  new <T>(bufferSize?: number, windowTime?: number): Subject<T>;\n}\n\ninterface ReplayValue<T> {\n  arg: SinkArg<T>,\n  timeout: number,\n}\n\nexport const ReplaySubject: ReplaySubjectConstructor =\n  (<T>(\n    bufferSize = Number.POSITIVE_INFINITY,\n    windowTime = Number.POSITIVE_INFINITY,\n  ) => {\n\n  return sourceAsSubject(replaySubjectSource(bufferSize, windowTime));\n}) as any;\n\nexport function replaySubjectSource<T>(\n  bufferSize = Number.POSITIVE_INFINITY,\n  windowTime = Number.POSITIVE_INFINITY,\n) {\n  const _base = subjectBaseSource<T>();\n  const _buffer: ReplayValue<T>[] = [];\n  let _endType: FOType;\n  let _endArg: any;\n\n  return ((type: FOType, arg: FObsArg<T>, subs: Subscription) => {\n    _base(type, arg, subs);\n    const now = Date.now();\n\n    for (let i = 0; i < _buffer.length; i++) {\n      const { arg: a, timeout } = _buffer[i];\n      if (timeout < now) {\n        _buffer.splice(i);\n        break;\n      }\n      if (type === FOType.SUBSCRIBE) {\n        arg(FOType.NEXT, a, subs);\n      }\n    }\n\n    if (_endType) {\n      if (type === FOType.SUBSCRIBE) {\n        arg(_endType, _endArg, subs);\n        subs.unsubscribe();\n      }\n      return;\n    }\n\n    switch (type) {\n      case FOType.NEXT:\n        _buffer.push({ arg, timeout: now + windowTime });\n        if(_buffer.length > bufferSize) {\n          _buffer.splice(0, _buffer.length - bufferSize);\n        }\n        break;\n      case FOType.ERROR:\n        _endType = FOType.ERROR;\n        _endArg = arg;\n        break;\n      case FOType.COMPLETE:\n        _endType = FOType.COMPLETE;\n        break;\n      default:\n        break;\n    }\n  });\n}\n\n","import { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\n\nexport const NEVER = sourceAsObservable(() => { /* noop */ });\n","export function isArrayLike<T>(obj: any): obj is ArrayLike<T> {\n  return obj != null && typeof obj !== 'function' && typeof obj.length === 'number';\n}\n","export function isPromiseLike<T>(obj: any): obj is PromiseLike<T> {\n  return obj != null && typeof obj.then === 'function';\n}\n","export function isIterable<T>(obj: any): obj is Iterable<T> {\n  return typeof obj[Symbol.iterator] === 'function';\n}\n","export const symbolObservable = Symbol && Symbol.observable || '@@observable';\n","import { InteropObservable } from \"rxjs/internal/types\";\nimport { symbolObservable } from 'rxjs/internal/util/symbolObservable';\n\nexport function isInteropObservable<T>(obj: any): obj is InteropObservable<T> {\n  return typeof obj[symbolObservable] === 'function';\n}\n","export const symbolAsyncIterator = (Symbol && Symbol.asyncIterator) || '@@asyncIterator';\n","import { symbolAsyncIterator } from 'rxjs/internal/util/symbolAsyncIterator';\n\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\n  return typeof obj[symbolAsyncIterator] === 'function';\n}\n","import { Observable } from 'rxjs/internal/Observable';\n\nexport function isObservable<T>(obj: any): obj is Observable<T> {\n  return typeof obj === 'function' && typeof obj.subscribe === 'function' && typeof obj.toPromise === 'function';\n}\n","import { FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { symbolAsyncIterator } from 'rxjs/internal/util/symbolAsyncIterator';\n\nexport function asyncIterableSource<T>(input: AsyncIterable<T>) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const ai = input[symbolAsyncIterator]() as AsyncIterator<T>;\n      let getNextValue: () => Promise<void>;\n      getNextValue = () => ai.next().then(result => {\n        if (result.done) {\n          sink(FOType.COMPLETE, undefined, subs);\n        }\n        else {\n          sink(FOType.NEXT, result.value, subs);\n          getNextValue();\n        }\n      }, err => {\n        sink(FOType.ERROR, err, subs);\n      });\n      getNextValue();\n    }\n  };\n}\n","import { FOType, Sink, InteropObservable, ObservableLike } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { symbolObservable } from 'rxjs/internal/util/symbolObservable';\nexport function symbolObservableSource<T>(input: InteropObservable<T>) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const obs: ObservableLike<T> = input[symbolObservable]();\n      if (!obs) {\n        sink(FOType.ERROR, new Error('invalid Symbol.observable implementation, observable not returned'), subs);\n      }\n      if (typeof obs.subscribe !== 'function') {\n        sink(FOType.ERROR, new Error('invalid Symbol.observable implementation, no subscribe method on returned value'), subs);\n        return;\n      }\n      let subscription: any;\n      subs.add(() => {\n        if (subscription && typeof subscription.unsubscribe === 'function') {\n          subscription.unsubscribe();\n        }\n      });\n      subscription = obs.subscribe({\n        next(value: T) { sink(FOType.NEXT, value, subs); },\n        error(err: any) { sink(FOType.ERROR, err, subs); },\n        complete() { sink(FOType.COMPLETE, undefined, subs); },\n      });\n    }\n  };\n}\n","import { Source, FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nexport function iterableSource<T>(iterable: Iterable<T>): Source<T> {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const iterator = iterable[Symbol.iterator]();\n      while (true) {\n        if (subs.closed)\n          return;\n        const { done, value } = iterator.next();\n        if (done)\n          break;\n        sink(FOType.NEXT, value, subs);\n      }\n      sink(FOType.COMPLETE, undefined, subs);\n    }\n  };\n}\n","import { Source, FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nexport function promiseSource<T>(promise: PromiseLike<T>): Source<T> {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      promise.then(value => {\n        if (!subs.closed) {\n          sink(FOType.NEXT, value, subs);\n          sink(FOType.COMPLETE, undefined, subs);\n        }\n      }, err => {\n        if (!subs.closed) {\n          sink(FOType.ERROR, err, subs);\n        }\n      });\n    }\n  };\n}\n","import { ObservableInput, Source } from 'rxjs/internal/types';\nimport { ofSource } from 'rxjs/internal/create/of';\nimport { isArrayLike } from 'rxjs/internal/util/isArrayLike';\nimport { isPromiseLike } from 'rxjs/internal/util/isPromiseLike';\nimport { isIterable } from 'rxjs/internal/util/isIterable';\nimport { isInteropObservable } from 'rxjs/internal/util/isInteropObservable';\nimport { isAsyncIterable } from 'rxjs/internal/util/isAsyncIterable';\nimport { isObservable } from 'rxjs/internal/util/isObservable';\nimport { asyncIterableSource } from \"rxjs/internal/sources/asyncIterableSource\";\nimport { symbolObservableSource } from \"rxjs/internal/sources/symbolObservableSource\";\nimport { iterableSource } from \"rxjs/internal/sources/iterableSource\";\nimport { promiseSource } from \"rxjs/internal/sources/promiseSource\";\nexport function fromSource<T>(input: ObservableInput<T>): Source<T> {\n  if (isObservable(input)) {\n    return input;\n  }\n  else if (isPromiseLike(input)) {\n    return promiseSource(input);\n  }\n  else if (isArrayLike(input)) {\n    return ofSource(input);\n  }\n  else if (isIterable(input)) {\n    return iterableSource(input);\n  }\n  else if (isInteropObservable(input)) {\n    return symbolObservableSource(input);\n  }\n  else if (isAsyncIterable(input)) {\n    return asyncIterableSource(input);\n  }\n  throw new Error('Unable to convert from input to Observable source');\n}\n","import { ObservableInput, FOType, Sink, Source, SinkArg } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { fromSource } from \"rxjs/internal/sources/fromSource\";\nimport { identity } from 'rxjs/internal/util/identity';\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\n\n/* tslint:disable:max-line-length */\nexport function combineLatest<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\nexport function combineLatest<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\nexport function combineLatest<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\nexport function combineLatest<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\nexport function combineLatest<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\nexport function combineLatest<T>(array: ObservableInput<T>[]): Observable<T[]>;\nexport function combineLatest<R>(array: ObservableInput<any>[]): Observable<R>;\nexport function combineLatest<T>(...observables: Array<ObservableInput<T>>): Observable<T[]>;\n/* tslint:enable:max-line-length */\n\nexport function combineLatest<T>(...sources: ObservableInput<T>[]): Observable<T> {\n  if (sources && sources.length === 1 && Array.isArray(sources[0])) {\n    sources = sources[0] as any;\n  }\n  return sourceAsObservable(combineLatestSource(sources));\n}\n\nexport function combineLatestSource<T>(sources: ObservableInput<T>[]): Source<T> {\n  return (type: FOType, dest: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const values = new Array(sources.length);\n      let emittedOnce = sources.map(() => false);\n      let completed = sources.map(() => false);\n      let hasValues = false;\n\n      for (let s = 0; s < sources.length; s++) {\n        const source = sources[s];\n        const src = tryUserFunction(fromSource, source);\n        if (resultIsError(src)) {\n          dest(FOType.ERROR, src.error, subs);\n          return;\n        }\n\n        src(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, subs: Subscription) => {\n          switch (t) {\n            case FOType.NEXT:\n              values[s] = v;\n              emittedOnce[s] = true;\n              if (hasValues || (hasValues = emittedOnce.every(identity))) {\n                dest(FOType.NEXT, values.slice(0), subs);\n              }\n              break;\n            case FOType.ERROR:\n              dest(t, v, subs);\n              break;\n            case FOType.COMPLETE:\n              completed[s] = true;\n              if (completed.every(identity)) {\n                dest(FOType.COMPLETE, undefined, subs);\n              }\n              break;\n            default:\n              break;\n          }\n        }, subs);\n      }\n    }\n  };\n}\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\nexport function lift<T, R>(operatorDef: (source: Observable<T>, dest: Sink<R>, subs: Subscription) => void) {\n  return (source: Observable<T>) =>\n    sourceAsObservable((type: FOType, dest: Sink<R>, subs: Subscription) => {\n      if (type === FOType.SUBSCRIBE) {\n        operatorDef(source, dest, subs);\n      }\n    });\n}\n","import { ObservableInput, OperatorFunction, FOType, Sink, SinkArg, Source } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { fromSource } from \"rxjs/internal/sources/fromSource\";\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\nimport { lift } from 'rxjs/internal/util/lift';\n\nexport function mergeMap<T, R>(\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent = Number.POSITIVE_INFINITY,\n): OperatorFunction<T, R> {\n  return lift((source: Observable<T>, dest: Sink<R>, subs: Subscription) => {\n    let counter = 0;\n    let active = 0;\n    let outerComplete = false;\n    const buffer: Array<{outerValue: T, outerIndex: number}> = [];\n\n    let startNextInner: () => void;\n    startNextInner = () => {\n      while (buffer.length > 0 && active < concurrent) {\n        active++;\n        const { outerValue, outerIndex } = buffer.shift();\n\n        const innerSource = tryUserFunction(() => fromSource(project(outerValue, outerIndex)));\n        if (resultIsError(innerSource)) {\n          dest(FOType.ERROR, innerSource.error, subs);\n          subs.unsubscribe();\n          return;\n        }\n\n        const innerSubs = new Subscription();\n        subs.add(innerSubs);\n\n        // INNER subscription\n        innerSource(FOType.SUBSCRIBE, (type: FOType, v: SinkArg<R>, innerSubs: Subscription) => {\n          switch (type) {\n            case FOType.NEXT:\n              dest(FOType.NEXT, v, subs);\n              break;\n            case FOType.ERROR:\n              dest(FOType.ERROR, v, subs);\n              subs.unsubscribe();\n              break;\n            case FOType.COMPLETE:\n              subs.remove(innerSubs);\n              active--;\n              if (buffer.length > 0) {\n                startNextInner();\n              }\n              if (outerComplete && buffer.length == 0 && active === 0) {\n                dest(FOType.COMPLETE, undefined, subs);\n              }\n\n            default:\n          }\n        }, innerSubs);\n      }\n    }\n\n    // OUTER subscription\n    source(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>) => {\n      switch (t) {\n        case FOType.NEXT:\n          let outerIndex = counter++;\n          buffer.push({ outerValue: v, outerIndex });\n          startNextInner();\n          break;\n        case FOType.ERROR:\n          if (!subs.closed) {\n            dest(FOType.ERROR, v, subs);\n            subs.unsubscribe();\n          }\n          break;\n        case FOType.COMPLETE:\n          outerComplete = true;\n          if (buffer.length > 0) {\n            startNextInner();\n          } else if (active === 0) {\n            dest(FOType.COMPLETE, undefined, subs);\n          }\n          break;\n        default:\n      }\n    }, subs);\n  });\n}\n","import { mergeMap } from 'rxjs/internal/operators/mergeMap';\nimport { identity } from 'rxjs/internal/util/identity';\nimport { OperatorFunction } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\n\nexport const mergeAll = <T extends Observable<R>, R>(concurrent = Number.POSITIVE_INFINITY) => mergeMap<T, R>(identity, concurrent);\n","import { mergeAll } from 'rxjs/internal/operators/derived/mergeAll';\nimport { identity } from 'rxjs/internal/util/identity';\nimport { OperatorFunction } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\n\nexport const concatAll = <T extends Observable<R>, R>() => mergeAll<T, R>(1);\n","import { ObservableInput } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { of } from 'rxjs/internal/create/of';\nimport { concatAll } from 'rxjs/internal/operators/derived/concatAll';\n\nexport function concat<T>(...sources: ObservableInput<T>[]): Observable<T> {\n  return of(...sources).pipe(concatAll());\n}\n","import { ObservableInput, FOType, Sink, Source } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { fromSource } from \"rxjs/internal/sources/fromSource\";\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\n\nexport function defer<T>(fn: () => ObservableInput<T>): Observable<T> {\n  return sourceAsObservable(deferSource(fn));\n}\n\nexport function deferSource<T>(fn: () => ObservableInput<T>): Source<T> {\n  return (type: FOType, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const result = tryUserFunction(() => fromSource(fn()));\n      if (resultIsError(result)) {\n        sink(FOType.ERROR, result.error, subs);\n        return;\n      }\n      result(FOType.SUBSCRIBE, sink, subs);\n    }\n  };\n}\n","import { ObservableInput, FOType, Sink, SinkArg } from \"rxjs/internal/types\";\nimport { Observable } from \"rxjs/internal/Observable\";\nimport { sourceAsObservable } from \"rxjs/internal/util/sourceAsObservable\";\nimport { Subscription } from \"rxjs/internal/Subscription\";\nimport { tryUserFunction, resultIsError } from \"rxjs/internal/util/userFunction\";\nimport { fromSource } from \"rxjs/internal/sources/fromSource\";\nimport { EMPTY } from \"rxjs/internal/EMPTY\";\n\n/* tslint:disable:max-line-length */\n// forkJoin([a$, b$, c$]);\nexport function forkJoin<T>(sources: [ObservableInput<T>]): Observable<T[]>;\nexport function forkJoin<T, T2>(sources: [ObservableInput<T>, ObservableInput<T2>]): Observable<[T, T2]>;\nexport function forkJoin<T, T2, T3>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>]): Observable<[T, T2, T3]>;\nexport function forkJoin<T, T2, T3, T4>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>]): Observable<[T, T2, T3, T4]>;\nexport function forkJoin<T, T2, T3, T4, T5>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>, ObservableInput<T5>]): Observable<[T, T2, T3, T4, T5]>;\nexport function forkJoin<T, T2, T3, T4, T5, T6>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>, ObservableInput<T5>, ObservableInput<T6>]): Observable<[T, T2, T3, T4, T5, T6]>;\nexport function forkJoin<T>(sources: Array<ObservableInput<T>>): Observable<T[]>;\n\n// forkJoin(a$, b$, c$)\nexport function forkJoin<T>(v1: ObservableInput<T>): Observable<T[]>;\nexport function forkJoin<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\nexport function forkJoin<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\nexport function forkJoin<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\nexport function forkJoin<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\nexport function forkJoin<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\n\nexport function forkJoin<T>(...sources: ObservableInput<T>[]): Observable<T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Joins last values emitted by passed Observables.\n *\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n *\n * ![](forkJoin.png)\n *\n * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n * or directly as arguments. If no input Observables are provided, resulting stream will complete\n * immediately.\n *\n * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n * array will have `n` values, where first value is the last thing emitted by the first Observable,\n * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n * not emit more than once and it will complete after that. If you need to emit combined values not only\n * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n * or {@link zip} instead.\n *\n * In order for resulting array to have the same length as the number of input Observables, whenever any of\n * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n * and it will not emit anything either, even if it already has some last values from other Observables.\n * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n * unless at any point some other Observable completes without emitting value, which brings us back to\n * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n * have to emit something at least once and complete.\n *\n * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n * will be immediately unsubscribed.\n *\n * Optionally `forkJoin` accepts project function, that will be called with values which normally\n * would land in emitted array. Whatever is returned by project function, will appear in output\n * Observable instead. This means that default project can be thought of as a function that takes\n * all its arguments and puts them into an array. Note that project function will be called only\n * when output Observable is supposed to emit a result.\n *\n * ## Examples\n * ### Use forkJoin with operator emitting immediately\n * ```javascript\n * import { forkJoin, of } from 'rxjs';\n *\n * const observable = forkJoin(\n *   of(1, 2, 3, 4),\n *   of(5, 6, 7, 8),\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!'),\n * );\n *\n * // Logs:\n * // [4, 8]\n * // \"This is how it ends!\"\n * ```\n *\n * ### Use forkJoin with operator emitting after some time\n * ```javascript\n * import { forkJoin, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const observable = forkJoin(\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\n *   interval(500).pipe(take(4)),  // emit 0, 1, 2, 3 every half a second and complete\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!'),\n * );\n *\n * // Logs:\n * // [2, 3] after 3 seconds\n * // \"This is how it ends!\" immediately after\n * ```\n *\n * ### Use forkJoin with project function\n * ```javascript\n * import { forkJoin, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const observable = forkJoin(\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\n *   interval(500).pipe(take(4)),  // emit 0, 1, 2, 3 every half a second and complete\n * ).pipe(\n *   map(([n, m]) => n + m),\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!'),\n * );\n *\n * // Logs:\n * // 5 after 3 seconds\n * // \"This is how it ends!\" immediately after\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n *\n * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments\n * passed directly to the operator.\n * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n * or value from project function.\n */\nexport function forkJoin<T>(\n  ...sources: Array<ObservableInput<T> | ObservableInput<T>[]>\n): Observable<T[]> {\n  if (sources.length === 0) {\n    return EMPTY;\n  }\n\n  if (sources.length === 1 && Array.isArray(sources[0])) {\n    return forkJoin(...(sources[0] as ObservableInput<T>[]));\n  }\n\n  const validSources = sources as ObservableInput<T>[];\n\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<T[]>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const state = validSources.map(toEmptyState);\n\n      for (let i = 0; i < validSources.length && !subs.closed; i++) {\n        const source = tryUserFunction(fromSource, validSources[i]);\n        if (resultIsError(source)) {\n          sink(FOType.ERROR, source.error, subs);\n        } else {\n          source(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, subs: Subscription) => {\n            const s = state[i];\n            if (t === FOType.NEXT) {\n              s.hasValue = true;\n              s.value = v;\n            } else if (t === FOType.COMPLETE) {\n              s.completed = true;\n              if (!s.hasValue || state.every(isComplete)) {\n                if (state.every(hasValue)) {\n                  sink(FOType.NEXT, state.map(getValue), subs);\n                }\n                sink(FOType.COMPLETE, undefined, subs);\n              }\n            } else if (t === FOType.ERROR) {\n              sink(FOType.ERROR, v, subs);\n            }\n          }, subs);\n        }\n      }\n    }\n  });\n}\n\nfunction toEmptyState<T>() {\n  return {\n    hasValue: false,\n    completed: false,\n    value: undefined as T\n  };\n}\n\nfunction isComplete(s: { completed: boolean }) {\n  return s.completed;\n}\nfunction hasValue(s: { hasValue: boolean }) {\n  return s.hasValue;\n}\n\nfunction getValue<T>(o: { value: T } ) {\n  return o.value;\n}\n","import { ObservableInput } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { fromSource } from 'rxjs/internal/sources/fromSource';\n\nexport function from<T>(input: ObservableInput<T>): Observable<T> {\n  return sourceAsObservable(fromSource(input));\n}\n\n\n","import { Observable } from \"rxjs/internal/Observable\";\nimport { sourceAsObservable } from \"rxjs/internal/util/sourceAsObservable\";\nimport { Subscription } from \"rxjs/internal/Subscription\";\nimport { FOType, Sink } from \"rxjs/internal/types\";\n\nexport interface NodeStyleEventEmitter {\n  addListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n  removeListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n}\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\n// For APIs that implement `addListener` and `removeListener` methods that may\n// not use the same arguments or return EventEmitter values\n// such as React Native\nexport interface NodeCompatibleEventEmitter {\n  addListener: (eventName: string, handler: NodeEventHandler) => void | {};\n  removeListener: (eventName: string, handler: NodeEventHandler) => void | {};\n}\n\nexport interface JQueryStyleEventEmitter {\n  on: (eventName: string, handler: Function) => void;\n  off: (eventName: string, handler: Function) => void;\n}\n\nexport interface HasEventTargetAddRemove<E> {\n  addEventListener(type: string, listener: ((evt: E) => void) | null, options?: boolean | AddEventListenerOptions): void;\n  removeEventListener(type: string, listener?: ((evt: E) => void) | null, options?: EventListenerOptions | boolean): void;\n}\n\nexport type EventTargetLike<T> = HasEventTargetAddRemove<T> | NodeStyleEventEmitter | NodeCompatibleEventEmitter | JQueryStyleEventEmitter;\n\nexport type FromEventTarget<T> = EventTargetLike<T> | ArrayLike<EventTargetLike<T>>;\n\nexport interface EventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n}\n\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\n/* tslint:disable:max-line-length */\nexport function fromEvent<T>(target: FromEventTarget<T>, eventName: string): Observable<T>;\nexport function fromEvent<T>(target: FromEventTarget<T>, eventName: string, options: EventListenerOptions): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an Observable that emits events of a specific type coming from the\n * given event target.\n *\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n * EventEmitter events or others.</span>\n *\n * ![](fromEvent.png)\n *\n * `fromEvent` accepts as a first argument event target, which is an object with methods\n * for registering event handler functions. As a second argument it takes string that indicates\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n * which are described in detail below. If your event target does not match any of the ones listed,\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n * handler functions have different names, but they all accept a string describing event type\n * and function itself, which will be called whenever said event happens.\n *\n * Every time resulting Observable is subscribed, event handler function will be registered\n * to event target on given event type. When that event fires, value\n * passed as a first argument to registered function will be emitted by output Observable.\n * When Observable is unsubscribed, function will be unregistered from event target.\n *\n * Note that if event target calls registered function with more than one argument, second\n * and following arguments will not appear in resulting stream. In order to get access to them,\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\n * passed to event handler. Output Observable will then emit value returned by project function,\n * instead of the usual value.\n *\n * Remember that event targets listed below are checked via duck typing. It means that\n * no matter what kind of object you have and no matter what environment you work in,\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\n * of course they behave as was described above). So for example if Node.js library exposes\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n * a good choice.\n *\n * If the API you use is more callback then event handler oriented (subscribed\n * callback function fires only once and thus there is no need to manually\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n * instead.\n *\n * `fromEvent` supports following types of event targets:\n *\n * **DOM EventTarget**\n *\n * This is an object with `addEventListener` and `removeEventListener` methods.\n *\n * In the browser, `addEventListener` accepts - apart from event type string and event\n * handler function arguments - optional third parameter, which is either an object or boolean,\n * both used for additional configuration how and when passed function will be called. When\n * `fromEvent` is used with event target of that type, you can provide this values\n * as third parameter as well.\n *\n * **Node.js EventEmitter**\n *\n * An object with `addListener` and `removeListener` methods.\n *\n * **JQuery-style event target**\n *\n * An object with `on` and `off` methods\n *\n * **DOM NodeList**\n *\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n *\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n * it contains and install event handler function in every of them. When returned Observable\n * is unsubscribed, function will be removed from all Nodes.\n *\n * **DOM HtmlCollection**\n *\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n * installed and removed in each of elements.\n *\n *\n * ## Examples\n * ### Emits clicks happening on the DOM document\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * clicks.subscribe(x => console.log(x));\n *\n * // Results in:\n * // MouseEvent object logged to console every time a click\n * // occurs on the document.\n * ```\n *\n * ### Use addEventListener with capture option\n * ```javascript\n * const clicksInDocument = fromEvent(document, 'click', true); // note optional configuration parameter\n *                                                              // which will be passed to addEventListener\n * const clicksInDiv = fromEvent(someDivInDocument, 'click');\n *\n * clicksInDocument.subscribe(() => console.log('document'));\n * clicksInDiv.subscribe(() => console.log('div'));\n *\n * // By default events bubble UP in DOM tree, so normally\n * // when we would click on div in document\n * // \"div\" would be logged first and then \"document\".\n * // Since we specified optional `capture` option, document\n * // will catch event when it goes DOWN DOM tree, so console\n * // will log \"document\" and then \"div\".\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n * @see {@link fromEventPattern}\n *\n * @param {FromEventTarget<T>} target The DOM EventTarget, Node.js\n * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n * @param {string} eventName The event name of interest, being emitted by the\n * `target`.\n * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n * @return {Observable<T>}\n * @name fromEvent\n */\nexport function fromEvent<T>(\n  target: FromEventTarget<T>,\n  eventName: string,\n  options?: EventListenerOptions,\n): Observable<T> {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    function handler(e: T) {\n      const arg = arguments.length > 1 ? Array.from(arguments) : e;\n      sink(FOType.NEXT, arg, subs);\n    }\n    setupSubscription(target, eventName, handler, subs, sink,  options as EventListenerOptions);\n  });\n}\n\nfunction setupSubscription<T>(sourceObj: FromEventTarget<T>, eventName: string,\n  handler: (...args: any[]) => void, subs: Subscription, sink: Sink<T>,\n  options?: EventListenerOptions) {\n  let unsubscribe: () => void;\n  if (isEventTarget(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.addEventListener(eventName, handler, options);\n    unsubscribe = () => source.removeEventListener(eventName, handler, options);\n  } else if (isJQueryStyleEventEmitter(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.on(eventName, handler);\n    unsubscribe = () => source.off(eventName, handler);\n  } else if (isNodeStyleEventEmitter(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.addListener(eventName, handler as NodeEventHandler);\n    unsubscribe = () => source.removeListener(eventName, handler as NodeEventHandler);\n  } else if (sourceObj && (sourceObj as any).length) {\n    for (let i = 0, len = (sourceObj as any).length; i < len; i++) {\n      setupSubscription(sourceObj[i], eventName, handler, subs, sink, options);\n    }\n  } else {\n    sink(FOType.ERROR, new TypeError('Invalid event target'), subs);\n    return;\n  }\n\n  subs.add(unsubscribe);\n}\n\nfunction isNodeStyleEventEmitter(sourceObj: any): sourceObj is NodeStyleEventEmitter {\n  return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\n\nfunction isJQueryStyleEventEmitter(sourceObj: any): sourceObj is JQueryStyleEventEmitter {\n  return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\n\nfunction isEventTarget(sourceObj: any): sourceObj is HasEventTargetAddRemove<any> {\n  return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\n\n/**\n * Creates an Observable from an arbitrary API for registering event handlers.\n *\n * <span class=\"informal\">When that method for adding event handler was something {@link fromEvent}\n * was not prepared for.</span>\n *\n * ![](fromEventPattern.png)\n *\n * `fromEventPattern` allows you to convert into an Observable any API that supports registering handler functions\n * for events. It is similar to {@link fromEvent}, but far\n * more flexible. In fact, all use cases of {@link fromEvent} could be easily handled by\n * `fromEventPattern` (although in slightly more verbose way).\n *\n * This operator accepts as a first argument an `addHandler` function, which will be injected with\n * handler parameter. That handler is actually an event handler function that you now can pass\n * to API expecting it. `addHandler` will be called whenever Observable\n * returned by the operator is subscribed, so registering handler in API will not\n * necessarily happen when `fromEventPattern` is called.\n *\n * After registration, every time an event that we listen to happens,\n * Observable returned by `fromEventPattern` will emit value that event handler\n * function was called with. Note that if event handler was called with more\n * then one argument, second and following arguments will not appear in the Observable.\n *\n * If API you are using allows to unregister event handlers as well, you can pass to `fromEventPattern`\n * another function - `removeHandler` - as a second parameter. It will be injected\n * with the same handler function as before, which now you can use to unregister\n * it from the API. `removeHandler` will be called when consumer of resulting Observable\n * unsubscribes from it.\n *\n * In some APIs unregistering is actually handled differently. Method registering an event handler\n * returns some kind of token, which is later used to identify which function should\n * be unregistered or it itself has method that unregisters event handler.\n * If that is the case with your API, make sure token returned\n * by registering method is returned by `addHandler`. Then it will be passed\n * as a second argument to `removeHandler`, where you will be able to use it.\n *\n * If you need access to all event handler parameters (not only the first one),\n * or you need to transform them in any way, you can call `fromEventPattern` with optional\n * third parameter - project function which will accept all arguments passed to\n * event handler when it is called. Whatever is returned from project function will appear on\n * resulting stream instead of usual event handlers first argument. This means\n * that default project can be thought of as function that takes its first parameter\n * and ignores the rest.\n *\n * ## Example\n * ### Emits clicks happening on the DOM document\n *\n * ```javascript\n * function addClickHandler(handler) {\n *   document.addEventListener('click', handler);\n * }\n *\n * function removeClickHandler(handler) {\n *   document.removeEventListener('click', handler);\n * }\n *\n * const clicks = fromEventPattern(\n *   addClickHandler,\n *   removeClickHandler\n * );\n * clicks.subscribe(x => console.log(x));\n *\n * // Whenever you click anywhere in the browser, DOM MouseEvent\n * // object will be logged.\n * ```\n *\n * ## Example\n * ### Use with API that returns cancellation token\n *\n * ```javascript\n * const token = someAPI.registerEventHandler(function() {});\n * someAPI.unregisterEventHandler(token); // this APIs cancellation method accepts\n *                                        // not handler itself, but special token.\n *\n * const someAPIObservable = fromEventPattern(\n *   function(handler) { return someAPI.registerEventHandler(handler); }, // Note that we return the token here...\n *   function(handler, token) { someAPI.unregisterEventHandler(token); }  // ...to then use it here.\n * );\n * ```\n *\n * ## Example\n * ### Use with project function\n *\n * ```javascript\n * someAPI.registerEventHandler((eventType, eventMessage) => {\n *   console.log(eventType, eventMessage); // Logs \"EVENT_TYPE\" \"EVENT_MESSAGE\" to console.\n * });\n *\n * const someAPIObservable = fromEventPattern(\n *   handler => someAPI.registerEventHandler(handler),\n *   handler => someAPI.unregisterEventHandler(handler)\n *   (eventType, eventMessage) => eventType + \" --- \" + eventMessage // without that function only \"EVENT_TYPE\"\n * );                                                                // would be emitted by the Observable\n *\n * someAPIObservable.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"EVENT_TYPE --- EVENT_MESSAGE\"\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n *\n * @param {function(handler: Function): any} addHandler A function that takes\n * a `handler` function as argument and attaches it somehow to the actual\n * source of events.\n * @param {function(handler: Function, token?: any): void} [removeHandler] A function that\n * takes a `handler` function as an argument and removes it from the event source. If `addHandler`\n * returns some kind of token, `removeHandler` function will have it as a second parameter.\n * @param {function(...args: any): T} [project] A function to\n * transform results. It takes the arguments from the event handler and\n * should return a single value.\n * @return {Observable<T>} Observable which, when an event happens, emits first parameter\n * passed to registered event handler. Alternatively it emits whatever project function returns\n * at that moment.\n * @static true\n * @name fromEventPattern\n * @owner Observable\n */\n\nexport function fromEventPattern<T>(\n  addHandler: (handler: Function) => any,\n  removeHandler?: (handler: Function, signal?: any) => void\n): Observable<T | T[]> {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    const handler = (...e: T[]) => sink(FOType.NEXT, e.length === 1 ? e[0] : e, subs);\n\n    const retValue = tryUserFunction(addHandler, handler);\n    if (resultIsError(retValue)) {\n      sink(FOType.ERROR, retValue.error, subs);\n      return;\n    }\n\n    if (typeof removeHandler !== 'function') {\n      return;\n    }\n\n    subs.add(() => removeHandler(handler, retValue));\n  });\n}\n","// TODO: require rxjs/core as a peer dep\nimport { SchedulerLike, ObservableInput, FOType, Sink, SinkArg, InteropObservable } from 'rxjs/internal/types';\nimport { isArrayLike } from 'rxjs/internal/util/isArrayLike';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { isIterable } from 'rxjs/internal/util/isIterable';\nimport { isObservable } from 'rxjs/internal/util/isObservable';\nimport { isInteropObservable } from 'rxjs/internal/util/isInteropObservable';\nimport { isPromiseLike } from 'rxjs/internal/util/isPromiseLike';\nimport { isAsyncIterable } from 'rxjs/internal/util/isAsyncIterable';\nimport { symbolAsyncIterator } from 'rxjs/internal/util/symbolAsyncIterator';\n\nexport function fromScheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\n  if (isObservable(input)) {\n    return sourceAsObservable(fromObservableScheduledSource(input, scheduler));\n  } else if (isInteropObservable(input)) {\n    return sourceAsObservable(fromInteropObservableSource(input, scheduler));\n  } else if (isPromiseLike(input)) {\n    return sourceAsObservable(fromPromiseLikeSource(input, scheduler));\n  } else if (isAsyncIterable(input)) {\n    return sourceAsObservable(fromAsyncIterableSource(input, scheduler));\n  } else if (isIterable(input)) {\n    return sourceAsObservable(fromIterableScheduledSource(input as Iterable<T>, scheduler));\n  } else if (isArrayLike(input)) {\n    return sourceAsObservable(fromArrayLikeScheduledSource(input, scheduler));\n  } else {\n    throw new Error('not implemented yet');\n  }\n}\n\n// TODO: this could be refactored with subscribeOn and observeOn (perhaps \"scheduleOn\")?\nfunction fromObservableScheduledSource<T>(\n  input: Observable<T>,\n  scheduler: SchedulerLike,\n) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      scheduler.schedule(() => {\n        input(FOType.SUBSCRIBE, (t: FOType, a: SinkArg<T>, subs: Subscription) => {\n          scheduler.schedule(() => {\n            sink(t, a, subs);\n          }, 0, null, subs);\n        }, subs);\n      }, 0, null, subs);\n    }\n  };\n}\n\nfunction fromInteropObservableSource<T>(\n  input: InteropObservable<T>,\n  scheduler: SchedulerLike,\n) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      scheduler.schedule(() => {\n        const source = input[Symbol.observable]();\n        const innerSubs = source.subscribe({\n          next(value) {\n            scheduler.schedule(() => sink(FOType.NEXT, value, subs), 0, null, subs);\n          },\n          error(err) {\n            scheduler.schedule(() => {\n              sink(FOType.ERROR, err, subs);\n            }, 0, null, subs);\n          },\n          complete() {\n            scheduler.schedule(() => {\n              sink(FOType.COMPLETE, undefined, subs);\n            }, 0, null, subs);\n          }\n        });\n        subs.add(innerSubs);\n      }, 0, null, subs);\n    }\n  };\n}\n\nfunction fromPromiseLikeSource<T>(\n  input: PromiseLike<T>,\n  scheduler: SchedulerLike,\n) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      scheduler.schedule(() => {\n        input.then(\n          value => {\n            scheduler.schedule(() => {\n              sink(FOType.NEXT, value, subs);\n              scheduler.schedule(() => sink(FOType.COMPLETE, undefined, subs), 0, null, subs);\n            }, 0, null, subs);\n          },\n          err => {\n            scheduler.schedule(() => sink(FOType.ERROR, err, subs), 0, null, subs);\n          },\n        );\n      }, 0, null, subs);\n    }\n  };\n}\n\nfunction fromAsyncIterableSource<T>(\n  input: AsyncIterable<T>,\n  scheduler: SchedulerLike,\n) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      scheduler.schedule(() => {\n        const ai: AsyncIterator<T> = input[symbolAsyncIterator]();\n        const go = () => scheduler.schedule(() => {\n          ai.next().then(\n            result => {\n              const { done, value } = result;\n              if (done) {\n                scheduler.schedule(() => sink(FOType.COMPLETE, undefined, subs), 0, null, subs);\n              } else {\n                scheduler.schedule(() => sink(FOType.NEXT, value, subs), 0, null, subs);\n                go();\n              }\n            },\n            err => {\n              scheduler.schedule(() => sink(FOType.ERROR, err, subs), 0, null, subs);\n            }\n          );\n        }, 0, null, subs);\n        go();\n      }, 0, null, subs);\n    }\n  };\n}\n\nfunction fromArrayLikeScheduledSource<T>(\n  input: ArrayLike<T>,\n  scheduler: SchedulerLike,\n) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      let i = 0;\n      scheduler.schedule(fromArrayLikeWork as any, 0, { i, input, subs, sink, scheduler }, subs);\n    }\n  };\n}\n\nfunction fromArrayLikeWork<T>(state: { i: number, input: ArrayLike<T>, subs: Subscription, sink: Sink<T>, scheduler: SchedulerLike}) {\n  const { i, input, subs, sink, scheduler } = state;\n  if (subs.closed) return;\n  if (i < input.length) {\n    if (i < input.length) {\n      sink(FOType.NEXT, input[state.i++], subs);\n      if (subs.closed) return;\n      scheduler.schedule(fromArrayLikeWork as any, 0, state, subs);\n    } else {\n      sink(FOType.COMPLETE, undefined, subs);\n    }\n  }\n}\n\nfunction fromIterableScheduledSource<T>(\n  input: Iterable<T>,\n  scheduler: SchedulerLike,\n) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const iterator = input[Symbol.iterator]();\n      scheduler.schedule(fromIterableWork as any, 0, { iterator, subs, sink, scheduler }, subs);\n    }\n  };\n}\n\nfunction fromIterableWork<T>(state: { iterator: Iterator<T>, subs: Subscription, sink: Sink<T>, scheduler: SchedulerLike }) {\n  const { iterator, subs, sink, scheduler } = state;\n  if (subs.closed) return;\n  const { done, value } = iterator.next();\n  if (done) {\n    sink(FOType.COMPLETE, undefined, subs);\n  } else {\n    sink(FOType.NEXT, value, subs);\n    scheduler.schedule(fromIterableWork as any, 0, state, subs);\n  }\n}\n","import { ObservableInput } from '../types';\nimport { EMPTY } from '../EMPTY';\nimport { Observable } from '../Observable';\nimport { defer } from './defer';\n\n/**\n * Decides at subscription time which Observable will actually be subscribed.\n *\n * <span class=\"informal\">`If` statement for Observables.</span>\n *\n * `iif` accepts a condition function and two Observables. When\n * an Observable returned by the operator is subscribed, condition function will be called.\n * Based on what boolean it returns at that moment, consumer will subscribe either to\n * the first Observable (if condition was true) or to the second (if condition was false). Condition\n * function may also not return anything - in that case condition will be evaluated as false and\n * second Observable will be subscribed.\n *\n * Note that Observables for both cases (true and false) are optional. If condition points to an Observable that\n * was left undefined, resulting stream will simply complete immediately. That allows you to, rather\n * then controlling which Observable will be subscribed, decide at runtime if consumer should have access\n * to given Observable or not.\n *\n * If you have more complex logic that requires decision between more than two Observables, {@link defer}\n * will probably be a better choice. Actually `iif` can be easily implemented with {@link defer}\n * and exists only for convenience and readability reasons.\n *\n *\n * ## Examples\n * ### Change at runtime which Observable will be subscribed\n * ```javascript\n * let subscribeToFirst;\n * const firstOrSecond = iif(\n *   () => subscribeToFirst,\n *   of('first'),\n *   of('second'),\n * );\n *\n * subscribeToFirst = true;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"first\"\n *\n * subscribeToFirst = false;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"second\"\n *\n * ```\n *\n * ### Control an access to an Observable\n * ```javascript\n * let accessGranted;\n * const observableIfYouHaveAccess = iif(\n *   () => accessGranted,\n *   of('It seems you have an access...'), // Note that only one Observable is passed to the operator.\n * );\n *\n * accessGranted = true;\n * observableIfYouHaveAccess.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('The end'),\n * );\n *\n * // Logs:\n * // \"It seems you have an access...\"\n * // \"The end\"\n *\n * accessGranted = false;\n * observableIfYouHaveAccess.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('The end'),\n * );\n *\n * // Logs:\n * // \"The end\"\n * ```\n *\n * @see {@link defer}\n *\n * @param {function(): boolean} condition Condition which Observable should be chosen.\n * @param {Observable} [trueObservable] An Observable that will be subscribed if condition is true.\n * @param {Observable} [falseObservable] An Observable that will be subscribed if condition is false.\n * @return {Observable} Either first or second Observable, depending on condition.\n * @static true\n * @name iif\n * @owner Observable\n */\nexport function iif<T, F>(\n  condition: () => boolean,\n  trueResult: ObservableInput<T> = EMPTY,\n  falseResult: ObservableInput<F> = EMPTY\n): Observable<T|F> {\n  return defer<T|F>(() => condition() ? trueResult : falseResult);\n}\n","import { Subscription } from 'rxjs/internal/Subscription';\nimport { SchedulerLike } from 'rxjs/internal/types';\n\nexport const asyncScheduler: SchedulerLike = {\n  now() {\n    return Date.now();\n  },\n  schedule<T>(work: (state: T) =>void, delay = 0, state = undefined as T, subs?: Subscription): Subscription {\n    subs = subs || new Subscription();\n    const id = setTimeout(() => work(state), delay);\n    subs.add(() => clearTimeout(id));\n    return subs;\n  }\n}\n","import { sourceAsObservable } from  'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink, SchedulerLike } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { asyncScheduler } from 'rxjs/internal/scheduler/asyncScheduler';\n\nexport function interval(interval: number, scheduler: SchedulerLike = asyncScheduler) {\n  interval = Math.max(0, interval);\n  return sourceAsObservable((type: FOType.SUBSCRIBE, dest: Sink<number>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const state = { i: 0, subs, interval, dest, scheduler };\n      scheduler.schedule(intervalWork, interval, state, subs);\n    }\n  });\n}\n\nexport function intervalWork(state: { i: number, subs: Subscription, interval: number, dest: Sink<number>, scheduler: SchedulerLike }) {\n  const { subs, dest, interval, scheduler } = state;\n  if (!subs.closed) {\n    dest(FOType.NEXT, state.i++, subs);\n    scheduler.schedule(intervalWork, interval, state, subs);\n  }\n}\n","import { ObservableInput } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { of } from 'rxjs/internal/create/of';\nimport { mergeAll } from 'rxjs/internal/operators/derived/mergeAll';\n\nexport function merge<T>(...sources: ObservableInput<T>[]): Observable<T> {\n  return of(...sources).pipe(mergeAll());\n}\n","export function isObserver(obj: any) {\n  return obj != null &&\n    typeof obj.next === 'function' &&\n    typeof obj.error === 'function' &&\n    typeof obj.complete === 'function';\n}\n","import { ConnectableObservable } from 'rxjs/internal/ConnectableObservable';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { Subject } from 'rxjs/internal/Subject';\nimport { isObserver } from 'rxjs/internal/util/isObserver';\n\nexport function multicast<T>(source: Observable<T>, subjectOrFactory: Subject<T>|(() => Subject<T>)): ConnectableObservable<T> {\n  const subjectFactory = isObserver(subjectOrFactory) ? () => subjectOrFactory as Subject<T> : subjectOrFactory as (() => Subject<T>);\n  return new ConnectableObservable(source, subjectFactory);\n}\n","import { Subscription, SubscriptionContext, teardownToFunction } from 'rxjs/internal/Subscription';\nimport { TeardownLogic } from 'rxjs/internal/types';\n\nexport interface RecyclableSubscription extends Subscription {\n  recycle(): void;\n}\n\nexport interface RecyclableSubscriptionConstructor {\n  new(...teardowns: TeardownLogic[]): RecyclableSubscription;\n}\n\nexport const RecyclableSubscription: RecyclableSubscriptionConstructor =\n  function RecyclableSubscription(this: any, ...teardowns: TeardownLogic[]) {\n    Subscription.apply(this, teardowns);\n  } as any;\n\nRecyclableSubscription.prototype = Object.create(Subscription.prototype);\n\nRecyclableSubscription.prototype.recycle = function (this: SubscriptionContext) {\n  const { _teardowns } = this;\n  while (_teardowns.length > 0) {\n    teardownToFunction(_teardowns.shift())();\n  }\n}\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink, SinkArg} from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { RecyclableSubscription } from 'rxjs/internal/RecyclableSubscription';\n\nexport function onEmptyResumeNext<T>(...sources: Array<Observable<T>>): Observable<T> {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, dest: Sink<T>, downstreamSubs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const remainingSources = sources.slice();\n      let hasValue = false;\n      const upstreamSubs = new RecyclableSubscription();\n      downstreamSubs.add(upstreamSubs);\n\n      let subscribe: () => void;\n      subscribe = () => {\n        const source = remainingSources.shift();\n        hasValue = false;\n        source(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, _: Subscription) => {\n          hasValue = hasValue || t === FOType.NEXT;\n          if (t === FOType.COMPLETE && !hasValue) {\n            upstreamSubs.recycle();\n            subscribe();\n          } else {\n            dest(t, v, downstreamSubs);\n          }\n        }, upstreamSubs);\n      };\n\n      subscribe();\n    }\n  });\n}\n\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink, SinkArg, ObservableInput} from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { RecyclableSubscription } from 'rxjs/internal/RecyclableSubscription';\nimport { tryUserFunction, resultIsError } from '../util/userFunction';\nimport { fromSource } from '../sources/fromSource';\n\nexport function onErrorResumeNext<T>(...sources: ObservableInput<T>[]): Observable<T> {\n  if (sources.length === 1 && Array.isArray(sources[0])) {\n    return onErrorResumeNext(...(sources[0] as any[]));\n  }\n  return sourceAsObservable((type: FOType.SUBSCRIBE, dest: Sink<T>, downstreamSubs: Subscription) => {\n    const remainingSources = sources.slice();\n    const upstreamSubs = new RecyclableSubscription();\n    downstreamSubs.add(upstreamSubs);\n\n    let subscribe: () => void;\n    subscribe = () => {\n      const input = remainingSources.shift();\n      const source = tryUserFunction(fromSource, input);\n      if (resultIsError(source)) {\n        upstreamSubs.recycle();\n        subscribe();\n        return;\n      }\n      source(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, _: Subscription) => {\n        if (t === FOType.ERROR && remainingSources.length > 0) {\n          upstreamSubs.recycle();\n          subscribe();\n        } else {\n          if (t === FOType.ERROR) {\n            t = FOType.COMPLETE;\n          }\n          dest(t, v, downstreamSubs);\n        }\n      }, upstreamSubs);\n    };\n\n    subscribe();\n  });\n}\n\n","import { Observable } from 'rxjs/internal/Observable';\nimport { OperatorFunction, FOType, Sink, SinkArg, FObs } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\nimport { lift } from 'rxjs/internal/util/lift';\n\nexport function filter<T>(predicate: (value: T, index: number) => boolean): OperatorFunction<T, T> {\n  return lift((source: Observable<T>, dest: Sink<T>, subs: Subscription) => {\n    let i = 0;\n    source(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, subs: Subscription) => {\n      if (t === FOType.NEXT) {\n        const result = tryUserFunction(predicate, v, i++);\n        if (resultIsError(result)) {\n          dest(FOType.ERROR, result.error, subs);\n          subs.unsubscribe();\n          return;\n        }\n        if (!result) return;\n      }\n      dest(t, v, subs);\n    }, subs);\n  });\n}\n","import { filter } from 'rxjs/internal/operators/filter';\nimport { Observable } from 'rxjs/internal/Observable';\n\n\nexport function partition<T>(source: Observable<T>, predicate: (value: T, index: number) => boolean) {\n  return [\n    source.pipe(filter(predicate)),\n    source.pipe(filter((v, i) => !predicate(v, i))),\n  ];\n}\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\n/**\n * Convert an object into an Observable of `[key, value]` pairs.\n *\n * <span class=\"informal\">Turn entries of an object into a stream.</span>\n *\n * <img src=\"./img/pairs.png\" width=\"100%\">\n *\n * `pairs` takes an arbitrary object and returns an Observable that emits arrays. Each\n * emitted array has exactly two elements - the first is a key from the object\n * and the second is a value corresponding to that key. Keys are extracted from\n * an object via `Object.keys` function, which means that they will be only\n * enumerable keys that are present on an object directly - not ones inherited\n * via prototype chain.\n *\n * By default these arrays are emitted synchronously. To change that you can\n * pass a {@link SchedulerLike} as a second argument to `pairs`.\n *\n * @example <caption>Converts a javascript object to an Observable</caption>\n * ```javascript\n * const obj = {\n *   foo: 42,\n *   bar: 56,\n *   baz: 78\n * };\n *\n * pairs(obj)\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n *\n * // Logs:\n * // [\"foo\", 42],\n * // [\"bar\", 56],\n * // [\"baz\", 78],\n * // \"the end!\"\n * ```\n *\n * @param {Object} obj The object to inspect and turn into an\n * Observable sequence.\n * @returns {(Observable<Array<string|T>>)} An observable sequence of\n * [key, value] pairs from the object.\n */\nexport function pairs<T>(obj: Object): Observable<[string, T]> {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<[string, T]>, subs: Subscription) => {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length && !subs.closed; i++) {\n      const key = keys[i];\n      if (obj.hasOwnProperty(key)) {\n        sink(FOType.NEXT, [key, obj[key]], subs);\n      }\n    }\n    sink(FOType.COMPLETE, undefined, subs);\n  });\n}\n","import { multicast } from 'rxjs/internal/create/multicast';\nimport { ConnectableObservable } from 'rxjs/internal/ConnectableObservable';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { Subject } from 'rxjs/internal/Subject';\n\nexport function publish<T>(source: Observable<T>): ConnectableObservable<T> {\n  return multicast(source, new Subject<T>());\n}\n","import { multicast } from 'rxjs/internal/create/multicast';\nimport { ConnectableObservable } from 'rxjs/internal/ConnectableObservable';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { BehaviorSubject } from 'rxjs/internal/BehaviorSubject';\n\nexport function publishBehavior<T>(source: Observable<T>, initialValue: T): ConnectableObservable<T> {\n  return multicast(source, new BehaviorSubject<T>(initialValue));\n}\n","import { multicast } from 'rxjs/internal/create/multicast';\nimport { ConnectableObservable } from 'rxjs/internal/ConnectableObservable';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { AsyncSubject } from 'rxjs/internal/AsyncSubject';\n\nexport function publishLast<T>(source: Observable<T>): ConnectableObservable<T> {\n  return multicast(source, new AsyncSubject<T>());\n}\n","import { multicast } from 'rxjs/internal/create/multicast';\nimport { ConnectableObservable } from 'rxjs/internal/ConnectableObservable';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { ReplaySubject } from 'rxjs/internal/ReplaySubject';\n\nexport function publishReplay<T>(source: Observable<T>, bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY): ConnectableObservable<T> {\n  return multicast(source, new ReplaySubject<T>(bufferSize, windowTime));\n}\n","import { ObservableInput, FOType, Sink, Source, SinkArg } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { fromSource } from \"rxjs/internal/sources/fromSource\";\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\n\n\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item.\n *\n * ## Example\n * ### Subscribes to the observable that was the first to start emitting.\n *\n * ```javascript\n * const obs1 = interval(1000).pipe(mapTo('fast one'));\n * const obs2 = interval(3000).pipe(mapTo('medium one'));\n * const obs3 = interval(5000).pipe(mapTo('slow one'));\n *\n * race(obs3, obs1, obs2)\n * .subscribe(\n *   winner => console.log(winner)\n * );\n *\n * // result:\n * // a series of 'fast one'\n * ```\n *\n * @param {...ObservableInput<T>[]} sources ...observables sources used to race for which Observable emits first.\n * @return {ObservableInput[]} an Observable that mirrors the output of the first Observable to emit an item.\n * @static true\n * @name race\n * @owner Observable\n */\nexport function race<T>(sources: Array<ObservableInput<T>>): Observable<T>;\nexport function race<T>(...sources: ObservableInput<T>[]): Observable<T>;\nexport function race<T>(...sources: ObservableInput<T>[]): Observable<T> {\n  if (sources.length === 1 && Array.isArray(sources[0])) {\n    sources = sources[0] as any;\n  }\n  return sourceAsObservable(raceSource(sources));\n}\n\nexport function raceSource<T>(sources: ObservableInput<T>[]): Source<T> {\n  return (type: FOType, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      let allSubs: Subscription[] = [];\n      for (let s = 0; s < sources.length; s++) {\n        const source = sources[s];\n        const src = tryUserFunction(fromSource, source);\n        if (resultIsError(src)) {\n          sink(FOType.ERROR, src.error, subs);\n          return;\n        }\n\n        const mySubs = new Subscription();\n        subs.add(mySubs);\n        allSubs.push(mySubs);\n        src(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, mySubs: Subscription) => {\n          if (allSubs && t === FOType.NEXT) {\n            for (let childSubs of allSubs) {\n              if (childSubs !== mySubs) childSubs.unsubscribe();\n            }\n            allSubs = null;\n          }\n          sink(t, v, subs);\n        }, mySubs);\n      }\n    }\n  };\n}\n","import { Observable } from \"rxjs/internal/Observable\";\nimport { sourceAsObservable } from \"rxjs/internal/util/sourceAsObservable\";\nimport { FOType, Sink } from \"rxjs/internal/types\";\nimport { Subscription } from \"rxjs/internal/Subscription\";\n\n/**\n * Creates an Observable that emits a sequence of numbers within a specified\n * range.\n *\n * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n *\n * ![](range.png)\n *\n * `range` operator emits a range of sequential integers, in order, where you\n * select the `start` of the range and its `length`. By default, uses no\n * {@link SchedulerLike} and just delivers the notifications synchronously, but may use\n * an optional {@link SchedulerLike} to regulate those deliveries.\n *\n * ## Example\n * Emits the numbers 1 to 10</caption>\n * ```javascript\n * const numbers = range(1, 10);\n * numbers.subscribe(x => console.log(x));\n * ```\n * @see {@link timer}\n * @see {@link index/interval}\n *\n * @param {number} [start=0] The value of the first integer in the sequence.\n * @param {number} [count=0] The number of sequential integers to generate.\n * @return {Observable} An Observable of numbers that emits a finite range of\n * sequential integers.\n * @static true\n * @name range\n * @owner Observable\n */\nexport function range(start = 0, count = 0): Observable<number> {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<number>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const end = start + count;\n      for (let n = start; n < end && !subs.closed; n++) {\n        sink(FOType.NEXT, n, subs);\n      }\n      sink(FOType.COMPLETE, undefined, subs);\n    }\n  });\n}\n","export function isNumeric(val: any): val is number | string {\n  // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n  // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n  // subtraction forces infinities to NaN\n  // adding 1 corrects loss of precision from parseFloat (#15100)\n  return !Array.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\n","import { SchedulerLike } from 'rxjs/internal/types';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return Boolean(value && typeof (<any>value).schedule === 'function');\n}\n","import { FOType, Sink, SchedulerLike }  from 'rxjs/internal/types';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { asyncScheduler } from 'rxjs/internal/scheduler/asyncScheduler';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { isNumeric } from 'rxjs/internal/util/isNumeric';\nimport { isScheduler } from 'rxjs/internal/util/isScheduler';\n\nexport function timer(): Observable<0>;\nexport function timer(delay: number|Date): Observable<0>;\nexport function timer(delay: number|Date, scheduler: SchedulerLike): Observable<0>;\nexport function timer(delay: number|Date, interval: number): Observable<number>;\nexport function timer(delay: number|Date, interval: number, scheduler: SchedulerLike): Observable<number>;\n\n/**\n * Creates an Observable that starts emitting after an `dueTime` and\n * emits ever increasing numbers after each `period` of time thereafter.\n *\n * <span class=\"informal\">Its like {@link index/interval}, but you can specify when\n * should the emissions start.</span>\n *\n * ![](timer.png)\n *\n * `timer` returns an Observable that emits an infinite sequence of ascending\n * integers, with a constant interval of time, `period` of your choosing\n * between those emissions. The first emission happens after the specified\n * `dueTime`. The initial delay may be a `Date`. By default, this\n * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you\n * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output\n * Observable emits only one value, `0`. Otherwise, it emits an infinite\n * sequence.\n *\n * ## Examples\n * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds\n * ```javascript\n * const numbers = timer(3000, 1000);\n * numbers.subscribe(x => console.log(x));\n * ```\n *\n * ### Emits one number after five seconds\n * ```javascript\n * const numbers = timer(5000);\n * numbers.subscribe(x => console.log(x));\n * ```\n * @see {@link index/interval}\n * @see {@link delay}\n *\n * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting\n * milliseconds to wait before emitting the first value of 0`.\n * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the\n * subsequent numbers.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a `0` after the\n * `dueTime` and ever increasing numbers after each `period` of time\n * thereafter.\n * @static true\n * @name timer\n * @owner Observable\n */\nexport function timer(dueTime: number | Date = 0,\n  periodOrScheduler?: number | SchedulerLike,\n  scheduler?: SchedulerLike): Observable<number> {\n\n  let period = -1;\n  if (isNumeric(periodOrScheduler)) {\n    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);\n  } else if (isScheduler(periodOrScheduler)) {\n    scheduler = periodOrScheduler as any;\n  }\n\n  if (!isScheduler(scheduler)) {\n    scheduler = asyncScheduler;\n  }\n\n  return sourceAsObservable((type = FOType.SUBSCRIBE, dest: Sink<number>, subs: Subscription) => {\n    const due = isNumeric(dueTime)\n      ? (dueTime as number)\n      : (+dueTime - scheduler.now());\n\n    if (type === FOType.SUBSCRIBE) {\n      scheduler.schedule(timerDelayWork as any, due, {\n        dest,\n        scheduler,\n        subs,\n        i: 0,\n        period,\n      }, subs);\n    }\n  });\n}\n\nfunction timerDelayWork<T>(state: { dest: Sink<T>, scheduler: SchedulerLike, subs: Subscription, i: number, period: number }) {\n  const { dest, scheduler, subs, period } = state;\n  if (subs.closed) return;\n  dest(FOType.NEXT, state.i++, subs);\n  if (!subs.closed) {\n    if (period >= 0) {\n      scheduler.schedule(timerDelayWork as any, period, state, subs);\n    } else {\n      dest(FOType.COMPLETE, undefined, subs);\n    }\n  }\n}\n","import { Unsubscribable, ObservableInput, FOType, Sink } from \"../types\";\nimport { Observable } from \"../Observable\";\nimport { from } from \"./from\";\nimport { EMPTY } from \"../EMPTY\";\n\n/**\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\n *\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\n *\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\n * that object and should return an Observable. That Observable can use resource object during its execution.\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\n * resource object will be shared in any way between subscriptions.\n *\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\n *\n * @see {@link defer}\n *\n * @param {function(): ISubscription} resourceFactory A function which creates any resource object\n * that implements `unsubscribe` method.\n * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which\n * creates an Observable, that can use injected resource object.\n * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\n */\nexport function using<T>(\n  resourceFactory: () => Unsubscribable | void,\n  observableFactory: (resource: Unsubscribable | void) => ObservableInput<T> | void\n): Observable<T> {\n  return new Observable<T>(subscriber => {\n    let resource: Unsubscribable | void;\n\n    try {\n      resource = resourceFactory();\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n\n    let result: ObservableInput<T> | void;\n    try {\n      result = observableFactory(resource);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n\n    const source = result ? from(result) : EMPTY;\n    const subscription = source.subscribe(subscriber);\n    return () => {\n      subscription.unsubscribe();\n      if (resource) {\n        resource.unsubscribe();\n      }\n    };\n  });\n}\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { ObservableInput, Source, FOType, Sink, SinkArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { fromSource } from \"rxjs/internal/sources/fromSource\";\nimport { identity } from 'rxjs/internal/util/identity';\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\nimport { isIterable } from '../util/isIterable';\n\n/* tslint:disable:max-line-length */\nexport function zip<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\nexport function zip<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\nexport function zip<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\nexport function zip<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\nexport function zip<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\n\nexport function zip<T>(array: ObservableInput<T>[]): Observable<T[]>;\nexport function zip<R>(array: ObservableInput<any>[]): Observable<R>;\nexport function zip<T>(...observables: Array<ObservableInput<T>>): Observable<T[]>;\nexport function zip<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): Observable<R>;\nexport function zip<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\n/* tslint:enable:max-line-length */\n\nexport function zip<T>(...sources: ObservableInput<T>[]): Observable<T> {\n  return sourceAsObservable(zipSource(sources));\n}\n\nfunction zipSource<T>(sources: ObservableInput<T>[]): Source<T> {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      if (sources.length === 0) {\n        sink(FOType.COMPLETE, undefined, subs);\n        return;\n      }\n      const state: Array<{ buffer: T[], complete: boolean }> = [];\n      for (let i = 0; i < sources.length; i++) {\n        const buffer = [] as T[];\n        const currentState = {\n          buffer,\n          complete: false,\n        };\n        state.push(currentState);\n\n        const source = sources[i];\n        const src = tryUserFunction(fromSource, source);\n        if (resultIsError(src)) {\n          sink(FOType.ERROR, src.error, subs);\n          return;\n        }\n\n        src(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, subs: Subscription) => {\n          switch (t) {\n            case FOType.NEXT:\n              buffer.push(v);\n              while (state.length === sources.length && state.every(({ buffer }) => buffer.length > 0)) {\n                sink(FOType.NEXT, state.map(s => s.buffer.shift()), subs);\n              }\n              if (state.some(s => s.complete && s.buffer.length === 0)) {\n                sink(FOType.COMPLETE, undefined, subs);\n                subs.unsubscribe();\n              }\n              break;\n            case FOType.ERROR:\n              sink(t, v, subs);\n              break;\n            case FOType.COMPLETE:\n              currentState.complete = true;\n              if (buffer.length === 0) {\n                sink(t, v, subs);\n                subs.unsubscribe();\n              }\n              break;\n            default:\n              break;\n          }\n        }, subs);\n      }\n    }\n  };\n}\n","export interface ArgumentOutOfRangeError extends Error {\n}\n\nexport interface ArgumentOutOfRangeErrorCtor {\n  new(): ArgumentOutOfRangeError;\n}\n\nfunction ArgumentOutOfRangeErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'argument out of range';\n  this.name = 'ArgumentOutOfRangeError';\n  return this;\n}\n\nArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = ArgumentOutOfRangeErrorImpl as any;\n","export interface EmptyError extends Error {\n}\n\nexport interface EmptyErrorCtor {\n  new(): EmptyError;\n}\n\nfunction EmptyErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'no elements in sequence';\n  this.name = 'EmptyError';\n  return this;\n}\n\nEmptyErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nexport const EmptyError: EmptyErrorCtor = EmptyErrorImpl as any;\n","export interface TimeoutError extends Error {\n}\n\nexport interface TimeoutErrorCtor {\n  new(): TimeoutError;\n}\n\nfunction TimeoutErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'Timeout has occurred';\n  this.name = 'TimeoutError';\n  return this;\n}\n\nTimeoutErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nexport const TimeoutError: TimeoutErrorCtor = TimeoutErrorImpl as any;\n","import { asyncScheduler } from 'rxjs/internal/scheduler/asyncScheduler';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { SchedulerLike } from 'rxjs/internal/types';\n\nconst toAnimate: any[] = [];\nlet animId = 0;\nexport const animationFrameScheduler: SchedulerLike = {\n  now() {\n    return Date.now();\n  },\n  schedule<T>(work: (state: T) => void,delay = 0, state = undefined as T, subs?: Subscription): Subscription {\n    subs = subs || new Subscription();\n    if (delay > 0) {\n      asyncScheduler.schedule((state) => {\n        animationFrameScheduler.schedule(work, 0, state, subs);\n      }, delay, state, subs);\n    } else {\n      toAnimate.push(work, state);\n      subs.add(() => {\n        const i = toAnimate.indexOf(work);\n        if (i >= 0) {\n          toAnimate.splice(i, 2);\n          if (toAnimate.length === 0) {\n            cancelAnimationFrame(animId);\n          }\n        }\n      });\n      if (toAnimate.length === 2) {\n        animId = requestAnimationFrame(() => {\n          while (toAnimate.length > 0) {\n            toAnimate.shift()(toAnimate.shift());\n          }\n        });\n      }\n    }\n    return subs;\n  }\n}\n","import { SchedulerLike } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { asyncScheduler } from 'rxjs/internal/scheduler/asyncScheduler';\n\nconst p = Promise.resolve();\n\nexport const asapScheduler: SchedulerLike = {\n  now() {\n    return Date.now();\n  },\n  schedule<T>(work: (state: T) => void, delay = 0, state = undefined as T, subs?: Subscription): Subscription {\n    subs = subs || new Subscription();\n    if (delay > 0) {\n      asyncScheduler.schedule(work, delay, state, subs);\n      return subs;\n    }\n    let stop = false;\n    subs.add(() => stop = true);\n    p.then(() => {\n      if (!stop) {\n        work(state);\n      }\n    });\n    return subs;\n  }\n}\n","import { Subscription } from 'rxjs/internal/Subscription';\nimport { asyncScheduler } from 'rxjs/internal/scheduler/asyncScheduler';\nimport { SchedulerLike } from 'rxjs/internal/types';\n\nexport interface QueueSchedulerCtor {\n  new(): QueueScheduler;\n}\n\nexport interface QueueScheduler extends SchedulerLike {\n}\n\nfunction QueueSchedulerImpl(this: any) {\n  this._flushing = false;\n  this._queue = [];\n}\n\nconst proto = QueueSchedulerImpl.prototype;\n\nproto.now = function () {\n  return Date.now();\n};\n\nproto.schedule = function<T>(work: (state: T) => void, delay = 0, state = undefined as T, subs?: Subscription): Subscription {\n  subs = subs || new Subscription();\n  if (delay > 0) {\n    return asyncScheduler.schedule(work, delay, state, subs);\n  }\n  const queue = this._queue;\n  subs.add(() => {\n    const i = queue.indexOf(work);\n    queue.splice(i, 2);\n  });\n  queue.push(work, state);\n  if (!this._flushing) {\n    this._flushing = true;\n    while (queue.length > 0) {\n      queue.shift()(queue.shift());\n    }\n    this._flushing = false;\n  }\n  return subs;\n};\n\nexport const QueueScheduler: QueueSchedulerCtor = QueueSchedulerImpl as any;\n\nexport const queueScheduler: SchedulerLike = new QueueScheduler() as any;\n","import { SchedulerLike } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\nexport interface VirtualTimeSchedulerCtor {\n  new (maxFrames?: number): VirtualTimeScheduler;\n}\n\nexport interface VirtualTimeScheduler extends SchedulerLike {\n  frameTimeFactor: number;\n  index: number;\n  maxFrames: number;\n  flush(): void;\n  frame: number;\n}\n\ninterface VirtualAction<T=any> {\n  index: number;\n  delay: number;\n  work: (state: T) => void;\n  state: T|undefined;\n  subs: Subscription;\n}\n\nfunction VirtualTimeSchedulerImpl(this: any, maxFrames = Number.POSITIVE_INFINITY) {\n  this._actions = [];\n  this._flushing = false;\n  this.maxFrames = Number.POSITIVE_INFINITY;\n  this.frame = 0;\n  this.frameTimeFactor = 1;\n  this.index = -1;\n}\n\nconst proto = VirtualTimeSchedulerImpl.prototype;\n\nproto.schedule = function<T>(this: any, work: (state: T) => void, delay = 0, state = undefined as T, subs?: Subscription): Subscription {\n  subs = subs || new Subscription();\n  const actions = this._actions;\n  const action = {\n    index: this.index++,\n    delay: this.frame + delay,\n    work,\n    state,\n    subs,\n  };\n  subs.add(() => {\n    const i = actions.indexOf(action);\n    if (i >= 0) {\n      actions.splice(i, 1);\n    }\n  });\n  actions.push(action);\n  actions.sort(sortActions);\n  return subs;\n};\n\nproto.now = function () {\n  return this.frame;\n};\n\nproto.flush = function (this: any) {\n  if (!this._flushing) {\n    const actions = this._actions;\n\n    const maxFrames = this.maxFrames;\n    this._flushing = true;\n    let action: VirtualAction;\n    while (action = actions.shift()) {\n      // ) && (this.frame = action.delay) <= maxFrames\n\n      if (this.frame > action.delay) {\n        // skip frames that were scheduled in the past. That shouldn't be possible.\n        continue;\n      }\n\n      this.frame = action.delay;\n      if (this.frame > maxFrames) {\n        break;\n      }\n\n      try {\n        action.work(action.state);\n      } catch (err) {\n        while(actions.length > 0) {\n          actions.shift().subs.unsubscribe();\n        }\n        throw err;\n      }\n    }\n    actions.length = 0;\n    this._flushing = false;\n  }\n}\n\nexport const VirtualTimeScheduler: VirtualTimeSchedulerCtor = VirtualTimeSchedulerImpl as any;\n\nfunction sortActions(a: VirtualAction, b: VirtualAction) {\n  if (a.delay === b.delay) {\n    if (a.index === b.index) {\n      return 0;\n    } else if (a.index > b.index) {\n      return 1;\n    } else {\n      return -1;\n    }\n  } else if (a.delay > b.delay) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n"],"names":["FOType","next","error","complete","tslib_1.__extends","proto"],"mappings":"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"}
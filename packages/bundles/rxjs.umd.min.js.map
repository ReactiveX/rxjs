{"version":3,"file":"rxjs.umd.min.js","sources":["../../src/internal/types.ts","../../src/internal/util/noop.ts","../../src/internal/util/userFunction.ts","../../src/internal/util/UnsubscriptionError.ts","../../src/internal/Subscription.ts","../../src/internal/util/identity.ts","../../src/internal/util/pipe.ts","../../src/internal/util/sinkFromObserver.ts","../../src/internal/util/isPartialObserver.ts","../../src/internal/util/sourceAsObservable.ts","../../src/internal/util/sinkFromHandlers.ts","../../src/internal/util/sourceAsSubject.ts","../../src/internal/util/ObjectUnsubscribedError.ts","../../src/internal/util/isSubscription.ts","../../src/internal/sources/subjectBaseSource.ts","../../src/internal/Subject.ts","../../src/internal/AsyncSubject.ts","../../src/internal/BehaviorSubject.ts","../../src/internal/ConnectableObservable.ts","../../src/internal/EMPTY.ts","../../src/internal/create/of.ts","../../src/internal/create/throwError.ts","../../src/internal/Notification.ts","../../src/internal/RxSubscriber.ts","../../src/internal/Observable.ts","../../src/internal/util/hostReportError.ts","../../src/internal/Subscriber.ts","../../src/internal/ReplaySubject.ts","../../src/internal/NEVER.ts","../../src/internal/util/isArrayLike.ts","../../src/internal/util/isPromiseLike.ts","../../src/internal/util/isIterable.ts","../../src/internal/util/symbolObservable.ts","../../src/internal/util/isInteropObservable.ts","../../src/internal/util/symbolAsyncIterator.ts","../../src/internal/util/isAsyncIterable.ts","../../src/internal/util/isObservable.ts","../../src/internal/sources/fromSource.ts","../../src/internal/sources/promiseSource.ts","../../src/internal/sources/iterableSource.ts","../../src/internal/sources/symbolObservableSource.ts","../../src/internal/sources/asyncIterableSource.ts","../../src/internal/util/lift.ts","../../src/internal/operators/derived/mergeAll.ts","../../src/internal/operators/mergeMap.ts","../../src/internal/operators/derived/concatAll.ts","../../src/internal/create/defer.ts","../../src/internal/create/forkJoin.ts","../../src/internal/create/from.ts","../../src/internal/create/fromScheduled.ts","../../src/internal/scheduler/asyncScheduler.ts","../../src/internal/create/interval.ts","../../src/internal/create/multicast.ts","../../src/internal/util/isObserver.ts","../../src/internal/RecyclableSubscription.ts","../../src/internal/operators/filter.ts","../../src/internal/util/isNumeric.ts","../../src/internal/util/isScheduler.ts","../../src/internal/create/timer.ts","../../src/internal/util/ArgumentOutOfRangeError.ts","../../src/internal/util/EmptyError.ts","../../src/internal/util/TimeoutError.ts","../../src/internal/scheduler/animationFrameScheduler.ts","../../src/internal/scheduler/asapScheduler.ts","../../src/internal/scheduler/QueueScheduler.ts","../../src/internal/scheduler/VirtualTimeScheduler.ts","../../src/internal/create/combineLatest.ts","../../src/internal/create/concat.ts","../../src/internal/create/fromEvent.ts","../../src/internal/create/fromEventPattern.ts","../../src/internal/create/iif.ts","../../src/internal/create/merge.ts","../../src/internal/create/onEmptyResumeNext.ts","../../src/internal/create/onErrorResumeNext.ts","../../src/internal/create/partition.ts","../../src/internal/create/pairs.ts","../../src/internal/create/publish.ts","../../src/internal/create/publishBehavior.ts","../../src/internal/create/publishLast.ts","../../src/internal/create/publishReplay.ts","../../src/internal/create/race.ts","../../src/internal/create/range.ts","../../src/internal/create/using.ts","../../src/internal/create/zip.ts"],"sourcesContent":["import { Subscription } from 'rxjs/internal/Subscription';\nimport { Observable } from 'rxjs/internal/Observable';\n\nexport const enum FOType {\n  SUBSCRIBE = 0,\n  NEXT = 1,\n  COMPLETE = 2,\n  ERROR = 3,\n  DISPOSE = 4,\n}\n\nexport type SinkArg<T> = T | void | any;\n\nexport interface DisposableFObs {\n  (type: FOType.DISPOSE, arg: void, subs: Subscription): void;\n}\n\nexport interface Sink<T> {\n  (type: FOType.NEXT, value: T, subs: Subscription): void;\n  (type: FOType.ERROR, err: any, subs: Subscription): void;\n  (type: FOType.COMPLETE, arg: void, subs: Subscription): void;\n  (type: FOType, arg: FObsArg<T>, subs: Subscription): void;\n}\n\nexport interface Source<T> {\n  (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription): void;\n}\n\nexport interface FObs<T> extends Source<T>, Sink<T> {\n  (type: FOType, arg: FObsArg<T>, subs: Subscription): void;\n}\n\nexport type FObsArg<T> = SinkArg<T> | void;\n\nexport type TeardownLogic = Unsubscribable | (() => void) | void;\n\nexport interface NextObserver<T> {\n  next: (value: T, subscription: Subscription) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n  [key: string]: any;\n}\n\nexport interface ErrorObserver<T> {\n  next?: (value: T, subscription: Subscription) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n  [key: string]: any;\n}\n\nexport interface CompleteObserver<T> {\n  next?: (value: T, subscription: Subscription) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n  [key: string]: any;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompleteObserver<T>;\n\nexport interface Observer<T> {\n  next: (value: T, subscription?: Subscription) => void;\n  error: (err: any) => void;\n  complete: () => void;\n  [key: string]: any;\n}\n\nexport interface SchedulerLike {\n  now(): number;\n  schedule<T>(work: () => void): Subscription;\n  schedule<T>(work: () => void, delay: number): Subscription;\n  schedule<T>(work: (state?: T) => void, delay: number, state: T): Subscription;\n  schedule<T>(work: (state?: T) => void, delay: number, state: T, subs: Subscription): Subscription;\n}\n\nexport type OperatorFunction<T, R> = (source: Observable<T>) => Observable<R>;\n\nexport interface ObservableLike<T> {\n  subscribe(observer: Observer<T>): Unsubscribable;\n}\n\nexport interface InteropObservable<T> {\n  [Symbol.observable](): ObservableLike<T>;\n}\n\nexport type ObservableInput<T> = Observable<T> | ObservableLike<T> | PromiseLike<T> |\n  Array<T> | ArrayLike<T> | InteropObservable<T> | AsyncIterable<T> | Iterable<T>;\n\nexport interface Unsubscribable {\n  unsubscribe(): void;\n}\n\nexport interface SubscriptionLike extends Unsubscribable {\n  unsubscribe(): void;\n  closed: boolean;\n}\n\nexport interface GroupedObservable<K, T> extends Observable<T> {\n  readonly key: K;\n}\n\nexport interface NotificationLike<T> {\n  kind: 'N'|'E'|'C';\n  value?: T;\n  error?: any;\n}\n\nexport interface Timestamped<T> {\n  value: T,\n  timestamp: number;\n}\n\ndeclare global  {\n  interface SymbolConstructor {\n    readonly observable: symbol;\n  }\n}\n\nexport type MonoTypeOperatorFunction<T> = OperatorFunction<T, T>;\n","export function noop() {\n  /* no op */\n}\n","const ERROR_OBJECT = {\n  error: null as any,\n};\n\n/**\n * Executes a user-provided function within a try-catch, and returns either the result\n * or returns {@link ERROR_OBJECT} if an error has occurred. Use {@link resultIsError} to\n * verify whether the result is an error or not.\n *\n * @param fn the user-provided function to wrap in some error handling for safety\n * @param args The arguments to execute the user-provided function with.\n */\nexport function tryUserFunction<R>(fn: (...args: any[]) => R, ...args: any[]): typeof ERROR_OBJECT | R {\n  ERROR_OBJECT.error = null;\n  let result: R;\n  try {\n    result = fn(...args);\n  } catch (err) {\n    ERROR_OBJECT.error = err;\n    return ERROR_OBJECT;\n  }\n  return result;\n}\n\n/**\n * Used to verify whether the result of {@link tryUserFunction} is an error or not. If\n * this returns true, check {@link ERROR_OBJECT}'s error property for the error value.\n */\nexport function resultIsError<R>(result: R|typeof ERROR_OBJECT): result is typeof ERROR_OBJECT {\n  return result === ERROR_OBJECT;\n}\n","export interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  new(errors: any[]): UnsubscriptionError;\n}\n\nfunction UnsubscriptionErrorImpl(this: any, errors: any[]) {\n  Error.call(this);\n  this.message = errors ?\n  `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '';\n  this.name = 'UnsubscriptionError';\n  this.errors = errors;\n  return this;\n}\n\nUnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = UnsubscriptionErrorImpl as any;\n","import { TeardownLogic } from 'rxjs/internal/types';\nimport { noop } from 'rxjs/internal/util/noop';\nimport { isSubscription } from 'rxjs/internal/util/isSubscription';\nimport { tryUserFunction, resultIsError } from './util/userFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n\nexport interface Subscription {\n  unsubscribe(): void;\n  add(...teardowns: TeardownLogic[]): void;\n  remove(...teardowns: TeardownLogic[]): void;\n  readonly closed: boolean;\n}\n\nexport interface SubscriptionConstructor {\n  new(): Subscription;\n  new(...teardowns: TeardownLogic[]): Subscription;\n  EMPTY: Subscription\n}\n\nexport interface SubscriptionContext {\n  _teardowns: TeardownLogic[];\n  _closed: boolean;\n}\n\nexport const Subscription: SubscriptionConstructor = function Subscription(this: SubscriptionContext, ...teardowns: TeardownLogic[]) {\n  this._teardowns = teardowns;\n  this._closed = false;\n} as any;\n\nconst EMPTY_SUBSCRIPTION = new Subscription();\n(EMPTY_SUBSCRIPTION as any)._closed = true;\n\nSubscription.EMPTY = EMPTY_SUBSCRIPTION;\n\nconst subscriptionProto = Subscription.prototype;\n\nsubscriptionProto.add = function (...teardowns: TeardownLogic[]) {\n  const { _teardowns } = this;\n  for (let teardown of teardowns) {\n    if (teardown) {\n      if (this._closed) {\n        teardownToFunction(teardown)();\n      } else {\n        if (isSubscription(teardown)) {\n          teardown.add(() => this.remove(teardown));\n        }\n        _teardowns.push(teardown);\n      }\n    }\n  }\n}\n\nsubscriptionProto.remove = function (...teardowns: TeardownLogic[]) {\n  const { _teardowns } = this;\n  for (let teardown of teardowns) {\n    if (teardown) {\n      const i = _teardowns.indexOf(teardown);\n      if (i >= 0) {\n        _teardowns.splice(i, 1);\n      }\n    }\n  }\n};\n\nsubscriptionProto.unsubscribe = function () {\n  if (!this._closed) {\n    this._closed = true;\n    const { _teardowns } = this;\n    let unsubError: UnsubscriptionError;\n\n    while (_teardowns.length > 0) {\n      const result = tryUserFunction(teardownToFunction(_teardowns.shift()));\n      if (resultIsError(result)) {\n        const err = result.error;\n        unsubError = unsubError || new UnsubscriptionError(err instanceof UnsubscriptionError ? err.errors : []);\n        unsubError.errors.push(err);\n      }\n    }\n    if (unsubError) throw unsubError;\n  }\n};\n\nObject.defineProperty(subscriptionProto, 'closed', {\n  get() {\n    return this._closed;\n  },\n});\n\nexport function teardownToFunction(teardown: any): () => void {\n  if (teardown) {\n    if (typeof teardown.unsubscribe === 'function') {\n      return () => teardown.unsubscribe();\n    } else if (typeof teardown === 'function') {\n      return teardown;\n    }\n  }\n  return noop;\n}\n","export function identity<T>(x: T) {\n  return x;\n}\n","import { identity } from \"rxjs/internal/util/identity\";\n\nexport function pipe<T>(): (value: T) => T;\nexport function pipe<A, R>(fnA: (value: A) => R): (value: A) => R;\nexport function pipe<A, B, R>(fnA: (value: A) => B, fnB: (value: B) => R): (value: A) => R;\nexport function pipe<A, B, C, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => R): (value: A) => R;\nexport function pipe<A, B, C, D, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, F, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => F, fnF: (value: F) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, F, G, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => F, fnF: (value: F) => G, fnG: (value: G) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, F, G, H, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => F, fnF: (value: F) => G, fnG: (value: G) => H, fnH: (value: H) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, F, G, H, I, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => F, fnF: (value: F) => G, fnG: (value: G) => H, fnH: (value: H) => I, fnI: (value: I) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, F, G, H, I, J, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => F, fnF: (value: F) => G, fnG: (value: G) => H, fnH: (value: H) => I, fnI: (value: I) => J, fnJ: (value: J) => R): (value: A) => R;\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, R>(fnA: (value: A) => B, fnB: (value: B) => C, fnC: (value: C) => D, fnD: (value: D) => E, fnE: (value: E) => F, fnF: (value: F) => G, fnG: (value: G) => H, fnH: (value: H) => I, fnI: (value: I) => J, fnJ: (value: J) => K, fnK: (value: K) => R): (value: A) => R;\n\nexport function pipe<T>(...fns: Array<(value: any) => any>): (value: T) => any {\n  return pipeArray(fns);\n}\n\nexport function pipeArray<T>(fns: Array<(value: any) => any>): (value: T) => any {\n  if (fns.length <= 0) {\n    return identity;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return (x: T) => fns.reduce((prev, fn) => fn(prev), x);\n}\n","import { PartialObserver, FOType, Sink, SinkArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\nexport function sinkFromObserver<T>(observer: PartialObserver<T>): Sink<T> {\n  return (type: FOType, arg: SinkArg<T>, subs: Subscription) => {\n    switch (type) {\n      case FOType.NEXT:\n        if (typeof observer.next === 'function') {\n          observer.next(arg, subs);\n        }\n        break;\n      case FOType.ERROR:\n        if (typeof observer.error === 'function') {\n          observer.error(arg);\n        }\n        break;\n      case FOType.COMPLETE:\n        if (typeof observer.complete === 'function') {\n          observer.complete();\n        }\n        break;\n      default:\n        break;\n    }\n  };\n}\n","import { PartialObserver } from \"../types\";\n\n/**\n * Because Subjects are `typeof \"function\"`, we have this method to test to\n * see if something is a partial observer. Technically, anything with at least a `next`,\n * `error`, or `complete` method is a partial observer, and as a legacy, any object,\n * even if it doesn't have any of those methods, is considered a `PartialObserver`.\n *\n * In the future, we will probably want to restrict this only to values with some\n * combination of `next`, `error`, or `complete` methods on them.\n * @param o the value to test\n */\nexport function isPartialObserver(o: any): o is PartialObserver<any> {\n  return o && (\n    typeof o === 'object' ||\n    typeof o.next === 'function' ||\n    typeof o.error === 'function' ||\n    typeof o.complete === 'function'\n  );\n}\n","import { sinkFromHandlers } from 'rxjs/internal/util/sinkFromHandlers';\nimport { OperatorFunction, PartialObserver, FOType, Sink, Source, SinkArg, FObsArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { pipeArray } from 'rxjs/internal/util/pipe';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { sinkFromObserver } from 'rxjs/internal/util/sinkFromObserver';\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\nimport { isPartialObserver } from './isPartialObserver';\n\nexport function sourceAsObservable<T>(source: Source<T>): Observable<T> {\n  const result = source as Observable<T>;\n  result.subscribe = subscribe;\n  result.pipe = observablePipe;\n  result.forEach = forEach;\n  result.toPromise = toPromise;\n  if (Symbol && Symbol.observable) {\n    result[Symbol.observable] = () => result;\n  }\n  return result;\n}\n\nfunction subscribe<T>(this: Source<T>, nextOrObserver?: PartialObserver<T> | ((value: T, subscription: Subscription) => void), errorHandler?: (err: any) => void, completeHandler?: () => void) {\n  const subscription = new Subscription();\n  ;\n  let sink: Sink<T>;\n  if (nextOrObserver || errorHandler || completeHandler) {\n    if (isPartialObserver(nextOrObserver)) {\n      sink = sinkFromObserver(nextOrObserver);\n    }\n    else {\n      sink = sinkFromHandlers(nextOrObserver as any, errorHandler, completeHandler);\n    }\n  }\n  else {\n    sink = () => { };\n  }\n  this(FOType.SUBSCRIBE, safeSink(sink), subscription);\n  return subscription;\n}\n\nfunction safeSink<T>(sink: Sink<T>) {\n  return (type: FOType, arg: FObsArg<T>, subs: Subscription) => {\n    if (subs.closed) {\n      if (type === FOType.ERROR) {\n        console.warn('Error thrown after subscription closed', arg);\n      }\n    } else {\n      sink(type, arg, subs);\n      if (type >= 2) {\n        subs.unsubscribe();\n      }\n    }\n  }\n}\n\nfunction forEach<T>(this: Observable<T>, nextHandler: (value: T) => void, subscription?: Subscription): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    let completed = false;\n    let errored = false;\n    if (subscription) {\n      subscription.add(() => {\n        if (!completed && !errored) {\n          const error = new Error('forEach aborted');\n          error.name = 'AbortError';\n          reject(error);\n        }\n      });\n    }\n    subscription = subscription || new Subscription();\n    this(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, subs: Subscription) => {\n      if (subs.closed) {\n        return;\n      }\n      switch (t) {\n        case FOType.NEXT:\n          const result = tryUserFunction(nextHandler, v);\n          if (resultIsError(result)) {\n            errored = true;\n            reject(result.error);\n            subs.unsubscribe();\n          }\n          break;\n        case FOType.COMPLETE:\n          completed = true;\n          resolve();\n          subs.unsubscribe();\n          break;\n        case FOType.ERROR:\n          errored = true;\n          reject(v);\n          subs.unsubscribe();\n          break;\n        default:\n          break;\n      }\n    }, subscription);\n  });\n}\nfunction toPromise<T>(this: Observable<T>): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    this.subscribe({\n      _last: undefined,\n      next(value) { this._last = value; },\n      error(err) { reject(err); },\n      complete() { resolve(this._last); }\n    });\n  });\n}\n\nfunction observablePipe<T>(this: Observable<T>, ...operations: Array<OperatorFunction<T, T>>): Observable<T> {\n  return pipeArray(operations)(this);\n}\n","import { FOType, SinkArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\nexport function sinkFromHandlers<T>(\n  nextHandler: null|void|((value: T, subscription: Subscription) => void),\n  errorHandler: null|void|((err: any) => void),\n  completeHandler: null|void|(() => void)) {\n  return (type: FOType, arg: SinkArg<T>, subs: Subscription) => {\n    switch (type) {\n      case FOType.NEXT:\n        if (typeof nextHandler === 'function') {\n          nextHandler(arg, subs);\n        }\n        break;\n      case FOType.ERROR:\n        if (typeof errorHandler === 'function') {\n          errorHandler(arg);\n        }\n        break;\n      case FOType.COMPLETE:\n        if (typeof completeHandler === 'function') {\n          completeHandler();\n        }\n        break;\n      default:\n        break;\n    }\n  };\n}\n","import { FOType, FObsArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subject } from 'rxjs/internal/Subject';\n\nexport function sourceAsSubject<T>(source: any): Subject<T> {\n  source = sourceAsObservable(source) as Subject<T>;\n  source.next = next;\n  source.error = error;\n  source.complete = complete;\n  source.unsubscribe = unsubscribe;\n  source.asObservable = asObservable;\n  return source;\n}\n\nfunction next<T>(this: Subject<T>, value: T, subs: Subscription) {\n  this(FOType.NEXT, value, subs);\n}\n\n// NOTE: For error and complete, subscription doesn't matter, as\n// we are passing it from state\n\nfunction error<T>(this: Subject<T>, err: any) {\n  this(FOType.ERROR, err, undefined);\n}\n\nfunction complete<T>(this: Subject<T>) {\n  this(FOType.COMPLETE, undefined, undefined);\n}\n\nfunction unsubscribe<T>(this: Subject<T>) {\n  this(FOType.DISPOSE, undefined, undefined);\n}\n\nfunction asObservable<T>(this: Subject<T>) {\n  return sourceAsObservable((t: FOType, v: FObsArg<T>, subs: Subscription) => {\n    this(t, v, subs);\n  });\n}\n","export interface ObjectUnsubscribedError extends Error {\n}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  new(): ObjectUnsubscribedError;\n}\n\nfunction ObjectUnsubscribedErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'object unsubscribed';\n  this.name = 'ObjectUnsubscribedError';\n  return this;\n}\n\nObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = ObjectUnsubscribedErrorImpl as any;\n","import { Subscription } from \"rxjs/internal/Subscription\";\n\nexport function isSubscription(obj: any): obj is Subscription {\n  return obj && typeof obj.unsubscribe === 'function'\n    && typeof obj.add === 'function'\n    && typeof obj.remove=== 'function' ;\n}\n","import { FOType, FObsArg, FObs } from \"rxjs/internal/types\";\nimport { Subscription } from \"rxjs/internal/Subscription\";\nimport { ObjectUnsubscribedError } from \"../util/ObjectUnsubscribedError\";\n\nexport function subjectBaseSource<T>(): FObs<T> {\n  let state: any[];\n  let disposed = false;\n  return (type: FOType, arg: FObsArg<T>, subs: Subscription) => {\n    if (disposed) {\n      throw new ObjectUnsubscribedError();\n    }\n    if (type === FOType.SUBSCRIBE) {\n      state = (state || []);\n      state.push(arg, subs);\n      subs.add(() => {\n        if (!state) return;\n        const i = state.indexOf(arg);\n        state.splice(i, 2);\n      });\n    } else if (type === FOType.DISPOSE) {\n      disposed = true;\n      state = null;\n    } else if (state) {\n      const copy = state.slice();\n      if (type !== FOType.NEXT) {\n        state = undefined;\n      }\n      for (let i = 0; i < copy.length; i += 2) {\n        copy[i](type, arg, copy[i + 1]);\n      }\n    }\n  };\n}\n","import { Observer, FOType, FObsArg, FObs, Sink, Source } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { sourceAsSubject } from 'rxjs/internal/util/sourceAsSubject';\nimport { subjectBaseSource } from 'rxjs/internal/sources/subjectBaseSource';\nimport { sinkFromObserver } from \"rxjs/internal/util/sinkFromObserver\";\nimport { isPartialObserver } from './util/isPartialObserver';\n\nexport interface Subject<O, I=O> extends Observer<I>, Observable<O> {\n  unsubscribe(): void;\n  asObservable(): Observable<O>;\n}\n\nexport interface SubjectConstructor {\n  <T>(): Subject<T>;\n  <O, I>(observer: Observer<I>, observable: Observable<O>): Subject<O, I>;\n  new<T>(): Subject<T>;\n}\n\nexport const Subject: SubjectConstructor =  (function Subject<T>(observer?: Observer<T>, observable?: Observable<T>) {\n  return sourceAsSubject(\n    arguments.length > 0\n    ? frankenSubjectSource(\n      sinkFromObserver(observer),\n      observable,\n    )\n    : subjectSource<T>()\n  )\n}) as any;\n\nexport function frankenSubjectSource<O, I>(\n  sink: Sink<I>,\n  source: Source<O>\n) {\n  return (type: FOType, arg: FObsArg<O|I>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      source(type, arg, subs);\n    } else {\n      sink(type, arg, subs);\n    }\n  };\n}\n\nexport function subjectSource<T>(): FObs<T> {\n  const base = subjectBaseSource<T>();\n  let _completed = false;\n  let _hasError = false;\n  let _error: any;\n  let _disposed = false;\n\n  return (type: FOType, arg: FObsArg<T>, subs: Subscription) => {\n    if (type === FOType.DISPOSE) {\n      _disposed = true;\n    }\n\n    if (type === FOType.SUBSCRIBE) {\n      if (_completed) {\n        arg(FOType.COMPLETE, undefined, subs);\n      } else if (_hasError) {\n        arg(FOType.ERROR, _error, subs);\n      }\n    }\n\n    if (_disposed || (!_completed && !_hasError)) {\n      if (type === FOType.COMPLETE) {\n        _completed = true;\n      } else if (type === FOType.ERROR) {\n        _hasError = true;\n        _error = arg;\n      }\n      base(type, arg, subs);\n    }\n  };\n}\n","import { Subject, subjectSource } from 'rxjs/internal/Subject';\nimport { FOType, FObsArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { sourceAsSubject } from 'rxjs/internal/util/sourceAsSubject';\n\n\nexport interface AsyncSubjectConstructor {\n  new <T>(): AsyncSubject<T>;\n}\n\nexport interface AsyncSubject<T> extends Subject<T> {\n}\n\nexport const AsyncSubject: AsyncSubjectConstructor = (<T>() => {\n  let hasValue = false;\n  let hasCompleted = false;\n  let hasError = false;\n  let value: T;\n  const subject = subjectSource<T>();\n\n  let result = ((type: FOType, arg: FObsArg<T>, subs: Subscription) => {\n    if (!hasError) {\n      switch (type) {\n        case FOType.SUBSCRIBE:\n          if (hasCompleted && hasValue) {\n            arg(FOType.NEXT, value, subs);\n          }\n          break;\n        case FOType.NEXT:\n          if (!hasCompleted && !hasError) {\n            hasValue = true;\n            value = arg;\n          }\n          return;\n        case FOType.ERROR:\n          hasError = true;\n          break;\n        case FOType.COMPLETE:\n          hasCompleted = true;\n          if (hasValue) {\n            subject(FOType.NEXT, value, subs);\n          }\n          break;\n      }\n    }\n    subject(type, arg, subs);\n  }) as AsyncSubject<T>;\n\n  result = sourceAsSubject(result) as AsyncSubject<T>;\n  return result;\n}) as any;\n\n","import { Subject, subjectSource } from 'rxjs/internal/Subject';\nimport { FOType, FObsArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { sourceAsSubject } from 'rxjs/internal/util/sourceAsSubject';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\n\n\nexport interface BehaviorSubjectConstructor {\n  new <T>(initialValue: T): BehaviorSubject<T>;\n}\n\nexport interface BehaviorSubject<T> extends Subject<T> {\n  getValue(): T;\n}\n\nexport const BehaviorSubject: BehaviorSubjectConstructor = (<T>(initialValue: T) => {\n  let completed = false;\n  let value = initialValue;\n  let hasError = false;\n  let disposed = false;\n  let error: any;\n  const subject = subjectSource<T>();\n\n  let result = ((type: FOType, arg: FObsArg<T>, subs: Subscription) => {\n    switch (type) {\n      case FOType.SUBSCRIBE:\n        if (!completed && !hasError) {\n          arg(FOType.NEXT, value, subs);\n        }\n        break;\n      case FOType.NEXT:\n        value = arg;\n        break;\n      case FOType.ERROR:\n        hasError = true;\n        error = arg;\n        break;\n      case FOType.COMPLETE:\n        completed = true;\n        break;\n      case FOType.DISPOSE:\n        disposed = true;\n        break;\n    }\n    subject(type, arg, subs);\n  }) as BehaviorSubject<T>;\n\n  result = sourceAsSubject(result) as BehaviorSubject<T>;\n  result.getValue = () => {\n    if (disposed) throw new ObjectUnsubscribedError();\n    if (hasError) throw error;\n    return value;\n  };\n  Object.defineProperty(result, 'value', {\n    get() {\n      return value\n    }\n  })\n  return result;\n}) as any;\n\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { Subject } from 'rxjs/internal/Subject';\nimport { FOType, Sink } from 'rxjs/internal/types';\n\nexport interface ConnectableObservable<T> extends Observable<T> {\n  connect(): Subscription;\n  refCount(): Observable<T>;\n}\n\nexport interface ConnectableObservableCtor {\n  new <T>(source: Observable<T>, subjectFactory: () => Subject<T>): ConnectableObservable<T>;\n}\n\nexport const ConnectableObservable: ConnectableObservableCtor = (<T>(source: Observable<T>, subjectFactory: () => Subject<T>) => {\n  let _subject: any;\n\n  let connectable = (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    _subject = _subject || subjectFactory();\n    _subject(FOType.SUBSCRIBE, sink, subs);\n  };\n\n  connectable = sourceAsObservable(connectable);\n\n  (connectable as ConnectableObservable<T>).connect = () => {\n    _subject = _subject || subjectFactory();\n    const subs = new Subscription();\n    source(FOType.SUBSCRIBE, _subject, subs);\n    return subs;\n  };\n\n  (connectable as ConnectableObservable<T>).refCount = refCount;\n\n  return connectable;\n}) as any;\n\n\nfunction refCount<T>(this: ConnectableObservable<T>) {\n  let _refCounter = 0;\n  let _connection: Subscription;\n\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    _refCounter++;\n\n    subs.add(() => {\n      _refCounter--;\n      if (_refCounter === 0) {\n        _connection.unsubscribe();\n      }\n    });\n\n    if (_refCounter === 1) {\n      _connection = this.connect();\n    }\n  });\n}\n","import { Observable } from 'rxjs/internal/Observable';\nimport { Source, FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\n\nexport const EMPTY_SOURCE: Source<never> =\n  (type: FOType.SUBSCRIBE, sink: Sink<never>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      sink(FOType.COMPLETE, undefined, subs);\n    }\n  };\n\nexport const EMPTY: Observable<never> = sourceAsObservable(EMPTY_SOURCE);\n\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink, Source } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\n/* tslint:disable:max-line-length */\nexport function of<T>(a: T): Observable<T>;\nexport function of<T, B>(a: T, b: B): Observable<T|B>;\nexport function of<T, B, C>(a: T, b: B, c: C): Observable<T|B|C>;\nexport function of<T, B, C, D>(a: T, b: B, c: C, d: D): Observable<T|B|C|D>;\nexport function of<T, B, C, D, E>(a: T, b: B, c: C, d: D, e: E): Observable<T|B|C|D|E>;\nexport function of<T, B, C, D, E, F>(a: T, b: B, c: C, d: D, e: E, f: F): Observable<T|B|C|D|E|F>;\nexport function of<T, B, C, D, E, F, G>(a: T, b: B, c: C, d: D, e: E, f: F, g: G):\n  Observable<T|B|C|D|E|F|G>;\nexport function of<T, B, C, D, E, F, G, H>(a: T, b: B, c: C, d: D, e: E, f: F, g: G, h: H):\n  Observable<T|B|C|D|E|F|G|H>;\nexport function of<T, B, C, D, E, F, G, H, I>(a: T, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I):\n  Observable<T|B|C|D|E|F|G|H|I>;\nexport function of<T>(...values: T[]): Observable<T>;\n/* tslint:enable:max-line-length */\n\nexport function of<T>(...values: T[]): Observable<T> {\n  return sourceAsObservable(ofSource(values));\n}\n\nexport function ofSource<T>(values: ArrayLike<T>): Source<T> {\n  return (type: FOType, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      for (let i = 0; i < values.length && !subs.closed; i++) {\n        if (subs.closed) return;\n        sink(FOType.NEXT, values[i], subs);\n      }\n      if (!subs.closed) sink(FOType.COMPLETE, undefined, subs);\n    }\n  };\n}\n\n\nconst x = of(1, 'test');\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\nexport function throwError(err: any): Observable<never> {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<never>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) sink(FOType.ERROR, err, subs);\n  });\n}\n","import { PartialObserver, NotificationLike } from './types';\nimport { Observable } from './Observable';\nimport { Subscription } from './Subscription';\nimport { isPartialObserver } from './util/isPartialObserver';\nimport { EMPTY } from './EMPTY';\nimport { of } from './create/of';\nimport { throwError } from './create/throwError';\n\nexport interface Notification<T> extends NotificationLike<T> {\n  /** @deprecated test `kind` for value `\"N\"` instead. */\n  hasValue: boolean;\n  observe(observer: PartialObserver<T>): void;\n  do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): void;\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) : void;\n  toObservable(): Observable<T>;\n}\n\nexport interface NotificationCtor {\n  new(kind: 'N'): Notification<void>;\n  new<T>(kind: 'N', value: T): Notification<T>;\n  new(kind: 'E', value: void, error: any): Notification<never>;\n  new(kind: 'C'): Notification<never>;\n\n  createNext(): Notification<void>;\n  createNext<T>(value: T): Notification<T>;\n  createError(error?: any): Notification<never>;\n  createComplete(): Notification<never>;\n}\n\nexport const Notification: NotificationCtor = (function <T>(this: Notification<T>, kind: 'N'|'E'|'C', value?: T, error?: any) {\n  this.kind = kind;\n  this.value = value;\n  this.error = error;\n}) as any;\n\nNotification.prototype = Object.create(Object.prototype);\nNotification.prototype.constructor = Notification;\n\nObject.defineProperty(Notification.prototype, 'hasValue', {\n  get() {\n    return this.kind === 'N';\n  }\n});\n\nNotification.prototype.observe = function <T>(observer: PartialObserver<T>, subscription?: Subscription) {\n  switch (this.kind) {\n    case 'N':\n      return observer.next && observer.next(this.value, subscription || new Subscription());\n    case 'E':\n      return observer.error && observer.error(this.error);\n    case 'C':\n      return observer.complete && observer.complete();\n  }\n};\n\nNotification.prototype.do = function<T>(next: (value: T, subscription: Subscription) => void, error?: (err: any) => void, complete?: () => void, subscription?: Subscription) {\n  const kind = this.kind;\n  switch (kind) {\n    case 'N':\n      return next && next(this.value, subscription || new Subscription());\n    case 'E':\n      return error && error(this.error);\n    case 'C':\n      return complete && complete();\n  }\n};\n\nNotification.prototype.accept = function<T>(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void, subscription?: Subscription) {\n  if (isPartialObserver(nextOrObserver)) {\n    return this.observe(<PartialObserver<T>>nextOrObserver, subscription);\n  } else {\n    return this.do(<(value: T) => void>nextOrObserver, error, complete, subscription);\n  }\n};\n\nNotification.prototype.toObservable = function<T>() {\n  const kind = this.kind;\n  switch (kind) {\n    case 'N':\n      return of(this.value);\n    case 'E':\n      return throwError(this.error);\n    case 'C':\n      return EMPTY;\n  }\n  throw new Error('unexpected notification kind value');\n}\n\nconst COMPLETE_NOTIFICATION = new Notification('C');\nconst UNDEFINED_NEXT_NOTIFICATION = new Notification('N');\n\nNotification.createNext = <T>(value?: T) => value === undefined ? UNDEFINED_NEXT_NOTIFICATION : new Notification('N', value);\n\nNotification.createError = (error: any) => new Notification('E', undefined, error);\n\nNotification.createComplete = () => COMPLETE_NOTIFICATION;\n","import { FOType, Sink, SinkArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\nexport interface RxSubscriber<T> extends Sink<T> {\n  next(value: T): void;\n  error(err: any): void;\n  complete(): void;\n  readonly closed: boolean;\n}\n\nconst CLOSED = 'closed';\n\nconst rxSubs = Symbol('rxjs subscription');\n\nexport function createSubscriber<T>(dest: Sink<T>, subs: Subscription): RxSubscriber<T> {\n  let closed = false;\n  subs.add(() => closed = true);\n  const result = ((type: FOType, arg: SinkArg<T>, subs: Subscription) => {\n    switch (type) {\n      case FOType.NEXT:\n        if (!closed) {\n          dest(FOType.NEXT, arg, subs);\n        }\n        break;\n      case FOType.ERROR:\n        if (!closed) {\n          closed = true;\n          dest(FOType.ERROR, arg, subs);\n          subs.unsubscribe();\n        }\n        break;\n      case FOType.COMPLETE:\n        if (!closed) {\n          closed = true;\n          dest(FOType.COMPLETE, undefined, subs);\n          subs.unsubscribe();\n        }\n        break;\n      default:\n    }\n  }) as RxSubscriber<T>;\n\n  result.next = next;\n  result.error = error;\n  result.complete = complete;\n  result[rxSubs] = subs;\n  Object.defineProperty(result, CLOSED, {\n    get() { return closed; },\n  });\n  return result;\n}\n\nfunction next<T>(this: RxSubscriber<T>, value: T) {\n  this(FOType.NEXT, value, this[rxSubs]);\n}\n\nfunction error<T>(this: RxSubscriber<T>, err: any) {\n  this(FOType.ERROR, err, this[rxSubs]);\n}\n\nfunction complete<T>(this: RxSubscriber<T>) {\n  this(FOType.COMPLETE, undefined, this[rxSubs]);\n}\n","import { FObs, OperatorFunction, PartialObserver, FOType, Sink, SinkArg, TeardownLogic } from 'rxjs/internal/types';\nimport { RxSubscriber, createSubscriber } from 'rxjs/internal/RxSubscriber';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\n\nexport interface ObservableConstructor {\n  <T>(init?: (subscriber: RxSubscriber<T>) => void): Observable<T>;\n  new<T>(init?: (subscriber: RxSubscriber<T>) => void): Observable<T>;\n}\n\nexport interface Observable<T> extends FObs<T> {\n  subscribe(observer: PartialObserver<T>): Subscription;\n  subscribe(\n    nextHandler?: (value: T, subscription: Subscription) => void,\n    errorHandler?: (err: any) => void,\n    completeHandler?: () => void,\n  ): Subscription;\n  subscribe(): Subscription;\n\n  forEach(nextHandler: (value: T) => void, subscription?: Subscription): Promise<void>;\n\n  toPromise(): Promise<T>;\n\n  pipe(): Observable<T>;\n  pipe<R>(op1: OperatorFunction<T, R>, ): Observable<R>;\n  pipe<A, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, R>, ): Observable<R>;\n  pipe<A, B, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, R>, ): Observable<R>;\n  pipe<A, B, C, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, R>, ): Observable<R>;\n  pipe<A, B, C, D, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, F, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op8: OperatorFunction<F, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, F, G, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op8: OperatorFunction<F, G>, op9: OperatorFunction<G, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, F, G, H, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op8: OperatorFunction<F, G>, op9: OperatorFunction<G, H>, op10: OperatorFunction<H, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, F, G, H, I, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op8: OperatorFunction<F, G>, op9: OperatorFunction<G, H>, op10: OperatorFunction<H, I>, op11: OperatorFunction<I, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, F, G, H, I, J, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op8: OperatorFunction<F, G>, op9: OperatorFunction<G, H>, op10: OperatorFunction<H, I>, op11: OperatorFunction<I, J>, op12: OperatorFunction<J, R>, ): Observable<R>;\n  pipe<A, B, C, D, E, F, G, H, I, J, K, R>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op8: OperatorFunction<F, G>, op9: OperatorFunction<G, H>, op10: OperatorFunction<H, I>, op11: OperatorFunction<I, J>, op12: OperatorFunction<J, K>, op13: OperatorFunction<K, R>, ): Observable<R>;\n  pipe(...operations: Array<OperatorFunction<any, any>>): Observable<any>;\n}\n\n/** The Observable constructor */\nexport const Observable: ObservableConstructor = function <T>(init?: (subscriber: RxSubscriber<T>) => TeardownLogic) {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, dest: Sink<T>, subs: Subscription) => {\n    if (init) {\n      const subscriber = createSubscriber(dest, subs);\n      const teardown = tryUserFunction(init, subscriber);\n      if (resultIsError(teardown)) {\n        subscriber(FOType.ERROR, teardown.error, subs);\n        subs.unsubscribe();\n        return;\n      }\n      subs.add(teardown);\n    }\n  });\n} as any;\n\n\n","export function hostReportError(err: any) {\n  setTimeout(() => { throw err; });\n}\n","import { Subscription } from \"./Subscription\";\nimport { Observer, PartialObserver } from \"./types\";\nimport { hostReportError } from \"./util/hostReportError\";\n\nconst EMPTY_OBSERVER = {\n  next() {},\n  error() {},\n  complete() {}\n};\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n * @deprecated Do not use or subclass. This type is being phased out and is not used in RxJS 7.\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  /** @internal */ syncErrorValue: any = null;\n  /** @internal */ syncErrorThrown: boolean = false;\n  /** @internal */ syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: Observer<T>;\n\n  private _parentSubscription: Subscription | null = null;\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = EMPTY_OBSERVER;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = EMPTY_OBSERVER;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            this.destination = destinationOrNext;\n            destinationOrNext.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value, this);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n}\n\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n * @deprecated Do not use, legacy support for RxJS 6\n */\nexport class SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(\n    private _parentSubscriber: Subscriber<T>,\n    observerOrNext?: PartialObserver<T> | ((value: T) => void),\n    error?: (e?: any) => void,\n    complete?: () => void\n  ) {\n    super();\n\n    let next: ((value: T, subscription: Subscription) => void);\n    let context: any = this;\n\n    if (typeof observerOrNext === 'function') {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== EMPTY_OBSERVER) {\n        context = Object.create(observerOrNext);\n        if (typeof context.unsubscribe === 'function') {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = (value: T) => next(value, this);\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._error) {\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else {\n        hostReportError(err);\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      hostReportError(err);\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      hostReportError(err);\n      return true;\n    }\n    return false;\n  }\n\n  /** @internal This is an internal implementation detail, do not use. */\n  _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n","import { Subject } from 'rxjs/internal/Subject';\nimport { FOType, FObsArg, SinkArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { sourceAsSubject } from 'rxjs/internal/util/sourceAsSubject';\nimport { subjectBaseSource } from 'rxjs/internal/sources/subjectBaseSource';\n\nexport interface ReplaySubjectConstructor {\n  new <T>(bufferSize?: number, windowTime?: number): Subject<T>;\n}\n\ninterface ReplayValue<T> {\n  arg: SinkArg<T>,\n  timeout: number,\n}\n\nexport const ReplaySubject: ReplaySubjectConstructor =\n  (<T>(\n    bufferSize = Number.POSITIVE_INFINITY,\n    windowTime = Number.POSITIVE_INFINITY,\n  ) => {\n\n  return sourceAsSubject(replaySubjectSource(bufferSize, windowTime));\n}) as any;\n\nexport function replaySubjectSource<T>(\n  bufferSize = Number.POSITIVE_INFINITY,\n  windowTime = Number.POSITIVE_INFINITY,\n) {\n  const _base = subjectBaseSource<T>();\n  const _buffer: ReplayValue<T>[] = [];\n  let _endType: FOType;\n  let _endArg: any;\n\n  return ((type: FOType, arg: FObsArg<T>, subs: Subscription) => {\n    _base(type, arg, subs);\n    const now = Date.now();\n\n    for (let i = 0; i < _buffer.length; i++) {\n      const { arg: a, timeout } = _buffer[i];\n      if (timeout < now) {\n        _buffer.splice(i);\n        break;\n      }\n      if (type === FOType.SUBSCRIBE) {\n        arg(FOType.NEXT, a, subs);\n      }\n    }\n\n    if (_endType) {\n      if (type === FOType.SUBSCRIBE) {\n        arg(_endType, _endArg, subs);\n        subs.unsubscribe();\n      }\n      return;\n    }\n\n    switch (type) {\n      case FOType.NEXT:\n        _buffer.push({ arg, timeout: now + windowTime });\n        if(_buffer.length > bufferSize) {\n          _buffer.splice(0, _buffer.length - bufferSize);\n        }\n        break;\n      case FOType.ERROR:\n        _endType = FOType.ERROR;\n        _endArg = arg;\n        break;\n      case FOType.COMPLETE:\n        _endType = FOType.COMPLETE;\n        break;\n      default:\n        break;\n    }\n  });\n}\n\n","import { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\n\nexport const NEVER = sourceAsObservable(() => { /* noop */ });\n","export function isArrayLike<T>(obj: any): obj is ArrayLike<T> {\n  return obj != null && typeof obj !== 'function' && typeof obj.length === 'number';\n}\n","export function isPromiseLike<T>(obj: any): obj is PromiseLike<T> {\n  return obj != null && typeof obj.then === 'function';\n}\n","export function isIterable<T>(obj: any): obj is Iterable<T> {\n  return typeof obj[Symbol.iterator] === 'function';\n}\n","export const symbolObservable = Symbol && Symbol.observable || '@@observable';\n","import { InteropObservable } from \"rxjs/internal/types\";\nimport { symbolObservable } from 'rxjs/internal/util/symbolObservable';\n\nexport function isInteropObservable<T>(obj: any): obj is InteropObservable<T> {\n  return typeof obj[symbolObservable] === 'function';\n}\n","export const symbolAsyncIterator = (Symbol && Symbol.asyncIterator) || '@@asyncIterator';\n","import { symbolAsyncIterator } from 'rxjs/internal/util/symbolAsyncIterator';\n\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\n  return typeof obj[symbolAsyncIterator] === 'function';\n}\n","import { Observable } from 'rxjs/internal/Observable';\n\nexport function isObservable<T>(obj: any): obj is Observable<T> {\n  return typeof obj === 'function' && typeof obj.subscribe === 'function' && typeof obj.toPromise === 'function';\n}\n","import { ObservableInput, Source } from 'rxjs/internal/types';\nimport { ofSource } from 'rxjs/internal/create/of';\nimport { isArrayLike } from 'rxjs/internal/util/isArrayLike';\nimport { isPromiseLike } from 'rxjs/internal/util/isPromiseLike';\nimport { isIterable } from 'rxjs/internal/util/isIterable';\nimport { isInteropObservable } from 'rxjs/internal/util/isInteropObservable';\nimport { isAsyncIterable } from 'rxjs/internal/util/isAsyncIterable';\nimport { isObservable } from 'rxjs/internal/util/isObservable';\nimport { asyncIterableSource } from \"rxjs/internal/sources/asyncIterableSource\";\nimport { symbolObservableSource } from \"rxjs/internal/sources/symbolObservableSource\";\nimport { iterableSource } from \"rxjs/internal/sources/iterableSource\";\nimport { promiseSource } from \"rxjs/internal/sources/promiseSource\";\nexport function fromSource<T>(input: ObservableInput<T>): Source<T> {\n  if (isObservable(input)) {\n    return input;\n  }\n  else if (isPromiseLike(input)) {\n    return promiseSource(input);\n  }\n  else if (isArrayLike(input)) {\n    return ofSource(input);\n  }\n  else if (isIterable(input)) {\n    return iterableSource(input);\n  }\n  else if (isInteropObservable(input)) {\n    return symbolObservableSource(input);\n  }\n  else if (isAsyncIterable(input)) {\n    return asyncIterableSource(input);\n  }\n  throw new Error('Unable to convert from input to Observable source');\n}\n","import { Source, FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nexport function promiseSource<T>(promise: PromiseLike<T>): Source<T> {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      promise.then(value => {\n        if (!subs.closed) {\n          sink(FOType.NEXT, value, subs);\n          sink(FOType.COMPLETE, undefined, subs);\n        }\n      }, err => {\n        if (!subs.closed) {\n          sink(FOType.ERROR, err, subs);\n        }\n      });\n    }\n  };\n}\n","import { Source, FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nexport function iterableSource<T>(iterable: Iterable<T>): Source<T> {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const iterator = iterable[Symbol.iterator]();\n      while (true) {\n        if (subs.closed)\n          return;\n        const { done, value } = iterator.next();\n        if (done)\n          break;\n        sink(FOType.NEXT, value, subs);\n      }\n      sink(FOType.COMPLETE, undefined, subs);\n    }\n  };\n}\n","import { FOType, Sink, InteropObservable, ObservableLike } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { symbolObservable } from 'rxjs/internal/util/symbolObservable';\nexport function symbolObservableSource<T>(input: InteropObservable<T>) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const obs: ObservableLike<T> = input[symbolObservable]();\n      if (!obs) {\n        sink(FOType.ERROR, new Error('invalid Symbol.observable implementation, observable not returned'), subs);\n      }\n      if (typeof obs.subscribe !== 'function') {\n        sink(FOType.ERROR, new Error('invalid Symbol.observable implementation, no subscribe method on returned value'), subs);\n        return;\n      }\n      let subscription: any;\n      subs.add(() => {\n        if (subscription && typeof subscription.unsubscribe === 'function') {\n          subscription.unsubscribe();\n        }\n      });\n      subscription = obs.subscribe({\n        next(value: T) { sink(FOType.NEXT, value, subs); },\n        error(err: any) { sink(FOType.ERROR, err, subs); },\n        complete() { sink(FOType.COMPLETE, undefined, subs); },\n      });\n    }\n  };\n}\n","import { FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { symbolAsyncIterator } from 'rxjs/internal/util/symbolAsyncIterator';\n\nexport function asyncIterableSource<T>(input: AsyncIterable<T>) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const ai = input[symbolAsyncIterator]() as AsyncIterator<T>;\n      let getNextValue: () => Promise<void>;\n      getNextValue = () => ai.next().then(result => {\n        if (result.done) {\n          sink(FOType.COMPLETE, undefined, subs);\n        }\n        else {\n          sink(FOType.NEXT, result.value, subs);\n          getNextValue();\n        }\n      }, err => {\n        sink(FOType.ERROR, err, subs);\n      });\n      getNextValue();\n    }\n  };\n}\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\nexport function lift<T, R>(operatorDef: (source: Observable<T>, dest: Sink<R>, subs: Subscription) => void) {\n  return (source: Observable<T>) =>\n    sourceAsObservable((type: FOType, dest: Sink<R>, subs: Subscription) => {\n      if (type === FOType.SUBSCRIBE) {\n        operatorDef(source, dest, subs);\n      }\n    });\n}\n","import { mergeMap } from 'rxjs/internal/operators/mergeMap';\nimport { identity } from 'rxjs/internal/util/identity';\nimport { OperatorFunction } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\n\nexport const mergeAll = <T extends Observable<R>, R>(concurrent = Number.POSITIVE_INFINITY) => mergeMap<T, R>(identity, concurrent);\n","import { ObservableInput, OperatorFunction, FOType, Sink, SinkArg, Source } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { fromSource } from \"rxjs/internal/sources/fromSource\";\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\nimport { lift } from 'rxjs/internal/util/lift';\n\nexport function mergeMap<T, R>(\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent = Number.POSITIVE_INFINITY,\n): OperatorFunction<T, R> {\n  return lift((source: Observable<T>, dest: Sink<R>, subs: Subscription) => {\n    let counter = 0;\n    let active = 0;\n    let outerComplete = false;\n    const buffer: Array<{outerValue: T, outerIndex: number}> = [];\n\n    let startNextInner: () => void;\n    startNextInner = () => {\n      while (buffer.length > 0 && active < concurrent) {\n        active++;\n        const { outerValue, outerIndex } = buffer.shift();\n\n        const innerSource = tryUserFunction(() => fromSource(project(outerValue, outerIndex)));\n        if (resultIsError(innerSource)) {\n          dest(FOType.ERROR, innerSource.error, subs);\n          subs.unsubscribe();\n          return;\n        }\n\n        const innerSubs = new Subscription();\n        subs.add(innerSubs);\n\n        // INNER subscription\n        innerSource(FOType.SUBSCRIBE, (type: FOType, v: SinkArg<R>, innerSubs: Subscription) => {\n          switch (type) {\n            case FOType.NEXT:\n              dest(FOType.NEXT, v, subs);\n              break;\n            case FOType.ERROR:\n              dest(FOType.ERROR, v, subs);\n              subs.unsubscribe();\n              break;\n            case FOType.COMPLETE:\n              subs.remove(innerSubs);\n              active--;\n              if (buffer.length > 0) {\n                startNextInner();\n              }\n              if (outerComplete && buffer.length == 0 && active === 0) {\n                dest(FOType.COMPLETE, undefined, subs);\n              }\n\n            default:\n          }\n        }, innerSubs);\n      }\n    }\n\n    // OUTER subscription\n    source(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>) => {\n      switch (t) {\n        case FOType.NEXT:\n          let outerIndex = counter++;\n          buffer.push({ outerValue: v, outerIndex });\n          startNextInner();\n          break;\n        case FOType.ERROR:\n          if (!subs.closed) {\n            dest(FOType.ERROR, v, subs);\n            subs.unsubscribe();\n          }\n          break;\n        case FOType.COMPLETE:\n          outerComplete = true;\n          if (buffer.length > 0) {\n            startNextInner();\n          } else if (active === 0) {\n            dest(FOType.COMPLETE, undefined, subs);\n          }\n          break;\n        default:\n      }\n    }, subs);\n  });\n}\n","import { mergeAll } from 'rxjs/internal/operators/derived/mergeAll';\nimport { identity } from 'rxjs/internal/util/identity';\nimport { OperatorFunction } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\n\nexport const concatAll = <T extends Observable<R>, R>() => mergeAll<T, R>(1);\n","import { ObservableInput, FOType, Sink, Source } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { fromSource } from \"rxjs/internal/sources/fromSource\";\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\n\nexport function defer<T>(fn: () => ObservableInput<T>): Observable<T> {\n  return sourceAsObservable(deferSource(fn));\n}\n\nexport function deferSource<T>(fn: () => ObservableInput<T>): Source<T> {\n  return (type: FOType, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const result = tryUserFunction(() => fromSource(fn()));\n      if (resultIsError(result)) {\n        sink(FOType.ERROR, result.error, subs);\n        return;\n      }\n      result(FOType.SUBSCRIBE, sink, subs);\n    }\n  };\n}\n","import { ObservableInput, FOType, Sink, SinkArg } from \"rxjs/internal/types\";\nimport { Observable } from \"rxjs/internal/Observable\";\nimport { sourceAsObservable } from \"rxjs/internal/util/sourceAsObservable\";\nimport { Subscription } from \"rxjs/internal/Subscription\";\nimport { tryUserFunction, resultIsError } from \"rxjs/internal/util/userFunction\";\nimport { fromSource } from \"rxjs/internal/sources/fromSource\";\nimport { EMPTY } from \"rxjs/internal/EMPTY\";\n\n/* tslint:disable:max-line-length */\n// forkJoin([a$, b$, c$]);\nexport function forkJoin<T>(sources: [ObservableInput<T>]): Observable<T[]>;\nexport function forkJoin<T, T2>(sources: [ObservableInput<T>, ObservableInput<T2>]): Observable<[T, T2]>;\nexport function forkJoin<T, T2, T3>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>]): Observable<[T, T2, T3]>;\nexport function forkJoin<T, T2, T3, T4>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>]): Observable<[T, T2, T3, T4]>;\nexport function forkJoin<T, T2, T3, T4, T5>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>, ObservableInput<T5>]): Observable<[T, T2, T3, T4, T5]>;\nexport function forkJoin<T, T2, T3, T4, T5, T6>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>, ObservableInput<T5>, ObservableInput<T6>]): Observable<[T, T2, T3, T4, T5, T6]>;\nexport function forkJoin<T>(sources: Array<ObservableInput<T>>): Observable<T[]>;\n\n// forkJoin(a$, b$, c$)\nexport function forkJoin<T>(v1: ObservableInput<T>): Observable<T[]>;\nexport function forkJoin<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\nexport function forkJoin<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\nexport function forkJoin<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\nexport function forkJoin<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\nexport function forkJoin<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\n\nexport function forkJoin<T>(...sources: ObservableInput<T>[]): Observable<T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Joins last values emitted by passed Observables.\n *\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n *\n * ![](forkJoin.png)\n *\n * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n * or directly as arguments. If no input Observables are provided, resulting stream will complete\n * immediately.\n *\n * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n * array will have `n` values, where first value is the last thing emitted by the first Observable,\n * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n * not emit more than once and it will complete after that. If you need to emit combined values not only\n * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n * or {@link zip} instead.\n *\n * In order for resulting array to have the same length as the number of input Observables, whenever any of\n * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n * and it will not emit anything either, even if it already has some last values from other Observables.\n * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n * unless at any point some other Observable completes without emitting value, which brings us back to\n * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n * have to emit something at least once and complete.\n *\n * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n * will be immediately unsubscribed.\n *\n * Optionally `forkJoin` accepts project function, that will be called with values which normally\n * would land in emitted array. Whatever is returned by project function, will appear in output\n * Observable instead. This means that default project can be thought of as a function that takes\n * all its arguments and puts them into an array. Note that project function will be called only\n * when output Observable is supposed to emit a result.\n *\n * ## Examples\n * ### Use forkJoin with operator emitting immediately\n * ```javascript\n * import { forkJoin, of } from 'rxjs';\n *\n * const observable = forkJoin(\n *   of(1, 2, 3, 4),\n *   of(5, 6, 7, 8),\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!'),\n * );\n *\n * // Logs:\n * // [4, 8]\n * // \"This is how it ends!\"\n * ```\n *\n * ### Use forkJoin with operator emitting after some time\n * ```javascript\n * import { forkJoin, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const observable = forkJoin(\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\n *   interval(500).pipe(take(4)),  // emit 0, 1, 2, 3 every half a second and complete\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!'),\n * );\n *\n * // Logs:\n * // [2, 3] after 3 seconds\n * // \"This is how it ends!\" immediately after\n * ```\n *\n * ### Use forkJoin with project function\n * ```javascript\n * import { forkJoin, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const observable = forkJoin(\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\n *   interval(500).pipe(take(4)),  // emit 0, 1, 2, 3 every half a second and complete\n * ).pipe(\n *   map(([n, m]) => n + m),\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!'),\n * );\n *\n * // Logs:\n * // 5 after 3 seconds\n * // \"This is how it ends!\" immediately after\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n *\n * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments\n * passed directly to the operator.\n * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n * or value from project function.\n */\nexport function forkJoin<T>(\n  ...sources: Array<ObservableInput<T> | ObservableInput<T>[]>\n): Observable<T[]> {\n  if (sources.length === 0) {\n    return EMPTY;\n  }\n\n  if (sources.length === 1 && Array.isArray(sources[0])) {\n    return forkJoin(...(sources[0] as ObservableInput<T>[]));\n  }\n\n  const validSources = sources as ObservableInput<T>[];\n\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<T[]>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const state = validSources.map(toEmptyState);\n\n      for (let i = 0; i < validSources.length && !subs.closed; i++) {\n        const source = tryUserFunction(fromSource, validSources[i]);\n        if (resultIsError(source)) {\n          sink(FOType.ERROR, source.error, subs);\n        } else {\n          source(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, subs: Subscription) => {\n            const s = state[i];\n            if (t === FOType.NEXT) {\n              s.hasValue = true;\n              s.value = v;\n            } else if (t === FOType.COMPLETE) {\n              s.completed = true;\n              if (!s.hasValue || state.every(isComplete)) {\n                if (state.every(hasValue)) {\n                  sink(FOType.NEXT, state.map(getValue), subs);\n                }\n                sink(FOType.COMPLETE, undefined, subs);\n              }\n            } else if (t === FOType.ERROR) {\n              sink(FOType.ERROR, v, subs);\n            }\n          }, subs);\n        }\n      }\n    }\n  });\n}\n\nfunction toEmptyState<T>() {\n  return {\n    hasValue: false,\n    completed: false,\n    value: undefined as T\n  };\n}\n\nfunction isComplete(s: { completed: boolean }) {\n  return s.completed;\n}\nfunction hasValue(s: { hasValue: boolean }) {\n  return s.hasValue;\n}\n\nfunction getValue<T>(o: { value: T } ) {\n  return o.value;\n}\n","import { ObservableInput } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { fromSource } from 'rxjs/internal/sources/fromSource';\n\nexport function from<T>(input: ObservableInput<T>): Observable<T> {\n  return sourceAsObservable(fromSource(input));\n}\n\n\n","// TODO: require rxjs/core as a peer dep\nimport { SchedulerLike, ObservableInput, FOType, Sink, SinkArg, InteropObservable } from 'rxjs/internal/types';\nimport { isArrayLike } from 'rxjs/internal/util/isArrayLike';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { isIterable } from 'rxjs/internal/util/isIterable';\nimport { isObservable } from 'rxjs/internal/util/isObservable';\nimport { isInteropObservable } from 'rxjs/internal/util/isInteropObservable';\nimport { isPromiseLike } from 'rxjs/internal/util/isPromiseLike';\nimport { isAsyncIterable } from 'rxjs/internal/util/isAsyncIterable';\nimport { symbolAsyncIterator } from 'rxjs/internal/util/symbolAsyncIterator';\n\nexport function fromScheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\n  if (isObservable(input)) {\n    return sourceAsObservable(fromObservableScheduledSource(input, scheduler));\n  } else if (isInteropObservable(input)) {\n    return sourceAsObservable(fromInteropObservableSource(input, scheduler));\n  } else if (isPromiseLike(input)) {\n    return sourceAsObservable(fromPromiseLikeSource(input, scheduler));\n  } else if (isAsyncIterable(input)) {\n    return sourceAsObservable(fromAsyncIterableSource(input, scheduler));\n  } else if (isIterable(input)) {\n    return sourceAsObservable(fromIterableScheduledSource(input as Iterable<T>, scheduler));\n  } else if (isArrayLike(input)) {\n    return sourceAsObservable(fromArrayLikeScheduledSource(input, scheduler));\n  } else {\n    throw new Error('not implemented yet');\n  }\n}\n\n// TODO: this could be refactored with subscribeOn and observeOn (perhaps \"scheduleOn\")?\nfunction fromObservableScheduledSource<T>(\n  input: Observable<T>,\n  scheduler: SchedulerLike,\n) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      scheduler.schedule(() => {\n        input(FOType.SUBSCRIBE, (t: FOType, a: SinkArg<T>, subs: Subscription) => {\n          scheduler.schedule(() => {\n            sink(t, a, subs);\n          }, 0, null, subs);\n        }, subs);\n      }, 0, null, subs);\n    }\n  };\n}\n\nfunction fromInteropObservableSource<T>(\n  input: InteropObservable<T>,\n  scheduler: SchedulerLike,\n) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      scheduler.schedule(() => {\n        const source = input[Symbol.observable]();\n        const innerSubs = source.subscribe({\n          next(value) {\n            scheduler.schedule(() => sink(FOType.NEXT, value, subs), 0, null, subs);\n          },\n          error(err) {\n            scheduler.schedule(() => {\n              sink(FOType.ERROR, err, subs);\n            }, 0, null, subs);\n          },\n          complete() {\n            scheduler.schedule(() => {\n              sink(FOType.COMPLETE, undefined, subs);\n            }, 0, null, subs);\n          }\n        });\n        subs.add(innerSubs);\n      }, 0, null, subs);\n    }\n  };\n}\n\nfunction fromPromiseLikeSource<T>(\n  input: PromiseLike<T>,\n  scheduler: SchedulerLike,\n) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      scheduler.schedule(() => {\n        input.then(\n          value => {\n            scheduler.schedule(() => {\n              sink(FOType.NEXT, value, subs);\n              scheduler.schedule(() => sink(FOType.COMPLETE, undefined, subs), 0, null, subs);\n            }, 0, null, subs);\n          },\n          err => {\n            scheduler.schedule(() => sink(FOType.ERROR, err, subs), 0, null, subs);\n          },\n        );\n      }, 0, null, subs);\n    }\n  };\n}\n\nfunction fromAsyncIterableSource<T>(\n  input: AsyncIterable<T>,\n  scheduler: SchedulerLike,\n) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      scheduler.schedule(() => {\n        const ai: AsyncIterator<T> = input[symbolAsyncIterator]();\n        const go = () => scheduler.schedule(() => {\n          ai.next().then(\n            result => {\n              const { done, value } = result;\n              if (done) {\n                scheduler.schedule(() => sink(FOType.COMPLETE, undefined, subs), 0, null, subs);\n              } else {\n                scheduler.schedule(() => sink(FOType.NEXT, value, subs), 0, null, subs);\n                go();\n              }\n            },\n            err => {\n              scheduler.schedule(() => sink(FOType.ERROR, err, subs), 0, null, subs);\n            }\n          );\n        }, 0, null, subs);\n        go();\n      }, 0, null, subs);\n    }\n  };\n}\n\nfunction fromArrayLikeScheduledSource<T>(\n  input: ArrayLike<T>,\n  scheduler: SchedulerLike,\n) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      let i = 0;\n      scheduler.schedule(fromArrayLikeWork as any, 0, { i, input, subs, sink, scheduler }, subs);\n    }\n  };\n}\n\nfunction fromArrayLikeWork<T>(state: { i: number, input: ArrayLike<T>, subs: Subscription, sink: Sink<T>, scheduler: SchedulerLike}) {\n  const { i, input, subs, sink, scheduler } = state;\n  if (subs.closed) return;\n  if (i < input.length) {\n    if (i < input.length) {\n      sink(FOType.NEXT, input[state.i++], subs);\n      if (subs.closed) return;\n      scheduler.schedule(fromArrayLikeWork as any, 0, state, subs);\n    } else {\n      sink(FOType.COMPLETE, undefined, subs);\n    }\n  }\n}\n\nfunction fromIterableScheduledSource<T>(\n  input: Iterable<T>,\n  scheduler: SchedulerLike,\n) {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const iterator = input[Symbol.iterator]();\n      scheduler.schedule(fromIterableWork as any, 0, { iterator, subs, sink, scheduler }, subs);\n    }\n  };\n}\n\nfunction fromIterableWork<T>(state: { iterator: Iterator<T>, subs: Subscription, sink: Sink<T>, scheduler: SchedulerLike }) {\n  const { iterator, subs, sink, scheduler } = state;\n  if (subs.closed) return;\n  const { done, value } = iterator.next();\n  if (done) {\n    sink(FOType.COMPLETE, undefined, subs);\n  } else {\n    sink(FOType.NEXT, value, subs);\n    scheduler.schedule(fromIterableWork as any, 0, state, subs);\n  }\n}\n","import { Subscription } from 'rxjs/internal/Subscription';\nimport { SchedulerLike } from 'rxjs/internal/types';\n\nexport const asyncScheduler: SchedulerLike = {\n  now() {\n    return Date.now();\n  },\n  schedule<T>(work: (state: T) =>void, delay = 0, state = undefined as T, subs?: Subscription): Subscription {\n    subs = subs || new Subscription();\n    const id = setTimeout(() => work(state), delay);\n    subs.add(() => clearTimeout(id));\n    return subs;\n  }\n}\n","import { sourceAsObservable } from  'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink, SchedulerLike } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { asyncScheduler } from 'rxjs/internal/scheduler/asyncScheduler';\n\nexport function interval(interval: number, scheduler: SchedulerLike = asyncScheduler) {\n  interval = Math.max(0, interval);\n  return sourceAsObservable((type: FOType.SUBSCRIBE, dest: Sink<number>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const state = { i: 0, subs, interval, dest, scheduler };\n      scheduler.schedule(intervalWork, interval, state, subs);\n    }\n  });\n}\n\nexport function intervalWork(state: { i: number, subs: Subscription, interval: number, dest: Sink<number>, scheduler: SchedulerLike }) {\n  const { subs, dest, interval, scheduler } = state;\n  if (!subs.closed) {\n    dest(FOType.NEXT, state.i++, subs);\n    scheduler.schedule(intervalWork, interval, state, subs);\n  }\n}\n","import { ConnectableObservable } from 'rxjs/internal/ConnectableObservable';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { Subject } from 'rxjs/internal/Subject';\nimport { isObserver } from 'rxjs/internal/util/isObserver';\n\nexport function multicast<T>(source: Observable<T>, subjectOrFactory: Subject<T>|(() => Subject<T>)): ConnectableObservable<T> {\n  const subjectFactory = isObserver(subjectOrFactory) ? () => subjectOrFactory as Subject<T> : subjectOrFactory as (() => Subject<T>);\n  return new ConnectableObservable(source, subjectFactory);\n}\n","export function isObserver(obj: any) {\n  return obj != null &&\n    typeof obj.next === 'function' &&\n    typeof obj.error === 'function' &&\n    typeof obj.complete === 'function';\n}\n","import { Subscription, SubscriptionContext, teardownToFunction } from 'rxjs/internal/Subscription';\nimport { TeardownLogic } from 'rxjs/internal/types';\n\nexport interface RecyclableSubscription extends Subscription {\n  recycle(): void;\n}\n\nexport interface RecyclableSubscriptionConstructor {\n  new(...teardowns: TeardownLogic[]): RecyclableSubscription;\n}\n\nexport const RecyclableSubscription: RecyclableSubscriptionConstructor =\n  function RecyclableSubscription(this: any, ...teardowns: TeardownLogic[]) {\n    Subscription.apply(this, teardowns);\n  } as any;\n\nRecyclableSubscription.prototype = Object.create(Subscription.prototype);\n\nRecyclableSubscription.prototype.recycle = function (this: SubscriptionContext) {\n  const { _teardowns } = this;\n  while (_teardowns.length > 0) {\n    teardownToFunction(_teardowns.shift())();\n  }\n}\n","import { Observable } from 'rxjs/internal/Observable';\nimport { OperatorFunction, FOType, Sink, SinkArg, FObs } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\nimport { lift } from 'rxjs/internal/util/lift';\n\nexport function filter<T>(predicate: (value: T, index: number) => boolean): OperatorFunction<T, T> {\n  return lift((source: Observable<T>, dest: Sink<T>, subs: Subscription) => {\n    let i = 0;\n    source(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, subs: Subscription) => {\n      if (t === FOType.NEXT) {\n        const result = tryUserFunction(predicate, v, i++);\n        if (resultIsError(result)) {\n          dest(FOType.ERROR, result.error, subs);\n          subs.unsubscribe();\n          return;\n        }\n        if (!result) return;\n      }\n      dest(t, v, subs);\n    }, subs);\n  });\n}\n","export function isNumeric(val: any): val is number | string {\n  // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n  // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n  // subtraction forces infinities to NaN\n  // adding 1 corrects loss of precision from parseFloat (#15100)\n  return !Array.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\n","import { SchedulerLike } from 'rxjs/internal/types';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return Boolean(value && typeof (<any>value).schedule === 'function');\n}\n","import { FOType, Sink, SchedulerLike }  from 'rxjs/internal/types';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { asyncScheduler } from 'rxjs/internal/scheduler/asyncScheduler';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { isNumeric } from 'rxjs/internal/util/isNumeric';\nimport { isScheduler } from 'rxjs/internal/util/isScheduler';\n\nexport function timer(): Observable<0>;\nexport function timer(delay: number|Date): Observable<0>;\nexport function timer(delay: number|Date, scheduler: SchedulerLike): Observable<0>;\nexport function timer(delay: number|Date, interval: number): Observable<number>;\nexport function timer(delay: number|Date, interval: number, scheduler: SchedulerLike): Observable<number>;\n\n/**\n * Creates an Observable that starts emitting after an `dueTime` and\n * emits ever increasing numbers after each `period` of time thereafter.\n *\n * <span class=\"informal\">Its like {@link index/interval}, but you can specify when\n * should the emissions start.</span>\n *\n * ![](timer.png)\n *\n * `timer` returns an Observable that emits an infinite sequence of ascending\n * integers, with a constant interval of time, `period` of your choosing\n * between those emissions. The first emission happens after the specified\n * `dueTime`. The initial delay may be a `Date`. By default, this\n * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you\n * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output\n * Observable emits only one value, `0`. Otherwise, it emits an infinite\n * sequence.\n *\n * ## Examples\n * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds\n * ```javascript\n * const numbers = timer(3000, 1000);\n * numbers.subscribe(x => console.log(x));\n * ```\n *\n * ### Emits one number after five seconds\n * ```javascript\n * const numbers = timer(5000);\n * numbers.subscribe(x => console.log(x));\n * ```\n * @see {@link index/interval}\n * @see {@link delay}\n *\n * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting\n * milliseconds to wait before emitting the first value of 0`.\n * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the\n * subsequent numbers.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a `0` after the\n * `dueTime` and ever increasing numbers after each `period` of time\n * thereafter.\n * @static true\n * @name timer\n * @owner Observable\n */\nexport function timer(dueTime: number | Date = 0,\n  periodOrScheduler?: number | SchedulerLike,\n  scheduler?: SchedulerLike): Observable<number> {\n\n  let period = -1;\n  if (isNumeric(periodOrScheduler)) {\n    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);\n  } else if (isScheduler(periodOrScheduler)) {\n    scheduler = periodOrScheduler as any;\n  }\n\n  if (!isScheduler(scheduler)) {\n    scheduler = asyncScheduler;\n  }\n\n  return sourceAsObservable((type = FOType.SUBSCRIBE, dest: Sink<number>, subs: Subscription) => {\n    const due = isNumeric(dueTime)\n      ? (dueTime as number)\n      : (+dueTime - scheduler.now());\n\n    if (type === FOType.SUBSCRIBE) {\n      scheduler.schedule(timerDelayWork as any, due, {\n        dest,\n        scheduler,\n        subs,\n        i: 0,\n        period,\n      }, subs);\n    }\n  });\n}\n\nfunction timerDelayWork<T>(state: { dest: Sink<T>, scheduler: SchedulerLike, subs: Subscription, i: number, period: number }) {\n  const { dest, scheduler, subs, period } = state;\n  if (subs.closed) return;\n  dest(FOType.NEXT, state.i++, subs);\n  if (!subs.closed) {\n    if (period >= 0) {\n      scheduler.schedule(timerDelayWork as any, period, state, subs);\n    } else {\n      dest(FOType.COMPLETE, undefined, subs);\n    }\n  }\n}\n","export interface ArgumentOutOfRangeError extends Error {\n}\n\nexport interface ArgumentOutOfRangeErrorCtor {\n  new(): ArgumentOutOfRangeError;\n}\n\nfunction ArgumentOutOfRangeErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'argument out of range';\n  this.name = 'ArgumentOutOfRangeError';\n  return this;\n}\n\nArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = ArgumentOutOfRangeErrorImpl as any;\n","export interface EmptyError extends Error {\n}\n\nexport interface EmptyErrorCtor {\n  new(): EmptyError;\n}\n\nfunction EmptyErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'no elements in sequence';\n  this.name = 'EmptyError';\n  return this;\n}\n\nEmptyErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nexport const EmptyError: EmptyErrorCtor = EmptyErrorImpl as any;\n","export interface TimeoutError extends Error {\n}\n\nexport interface TimeoutErrorCtor {\n  new(): TimeoutError;\n}\n\nfunction TimeoutErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'Timeout has occurred';\n  this.name = 'TimeoutError';\n  return this;\n}\n\nTimeoutErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nexport const TimeoutError: TimeoutErrorCtor = TimeoutErrorImpl as any;\n","import { asyncScheduler } from 'rxjs/internal/scheduler/asyncScheduler';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { SchedulerLike } from 'rxjs/internal/types';\n\nconst toAnimate: any[] = [];\nlet animId = 0;\nexport const animationFrameScheduler: SchedulerLike = {\n  now() {\n    return Date.now();\n  },\n  schedule<T>(work: (state: T) => void,delay = 0, state = undefined as T, subs?: Subscription): Subscription {\n    subs = subs || new Subscription();\n    if (delay > 0) {\n      asyncScheduler.schedule((state) => {\n        animationFrameScheduler.schedule(work, 0, state, subs);\n      }, delay, state, subs);\n    } else {\n      toAnimate.push(work, state);\n      subs.add(() => {\n        const i = toAnimate.indexOf(work);\n        if (i >= 0) {\n          toAnimate.splice(i, 2);\n          if (toAnimate.length === 0) {\n            cancelAnimationFrame(animId);\n          }\n        }\n      });\n      if (toAnimate.length === 2) {\n        animId = requestAnimationFrame(() => {\n          while (toAnimate.length > 0) {\n            toAnimate.shift()(toAnimate.shift());\n          }\n        });\n      }\n    }\n    return subs;\n  }\n}\n","import { SchedulerLike } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { asyncScheduler } from 'rxjs/internal/scheduler/asyncScheduler';\n\nconst p = Promise.resolve();\n\nexport const asapScheduler: SchedulerLike = {\n  now() {\n    return Date.now();\n  },\n  schedule<T>(work: (state: T) => void, delay = 0, state = undefined as T, subs?: Subscription): Subscription {\n    subs = subs || new Subscription();\n    if (delay > 0) {\n      asyncScheduler.schedule(work, delay, state, subs);\n      return subs;\n    }\n    let stop = false;\n    subs.add(() => stop = true);\n    p.then(() => {\n      if (!stop) {\n        work(state);\n      }\n    });\n    return subs;\n  }\n}\n","import { Subscription } from 'rxjs/internal/Subscription';\nimport { asyncScheduler } from 'rxjs/internal/scheduler/asyncScheduler';\nimport { SchedulerLike } from 'rxjs/internal/types';\n\nexport interface QueueSchedulerCtor {\n  new(): QueueScheduler;\n}\n\nexport interface QueueScheduler extends SchedulerLike {\n}\n\nfunction QueueSchedulerImpl(this: any) {\n  this._flushing = false;\n  this._queue = [];\n}\n\nconst proto = QueueSchedulerImpl.prototype;\n\nproto.now = function () {\n  return Date.now();\n};\n\nproto.schedule = function<T>(work: (state: T) => void, delay = 0, state = undefined as T, subs?: Subscription): Subscription {\n  subs = subs || new Subscription();\n  if (delay > 0) {\n    return asyncScheduler.schedule(work, delay, state, subs);\n  }\n  const queue = this._queue;\n  subs.add(() => {\n    const i = queue.indexOf(work);\n    queue.splice(i, 2);\n  });\n  queue.push(work, state);\n  if (!this._flushing) {\n    this._flushing = true;\n    while (queue.length > 0) {\n      queue.shift()(queue.shift());\n    }\n    this._flushing = false;\n  }\n  return subs;\n};\n\nexport const QueueScheduler: QueueSchedulerCtor = QueueSchedulerImpl as any;\n\nexport const queueScheduler: SchedulerLike = new QueueScheduler() as any;\n","import { SchedulerLike } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\nexport interface VirtualTimeSchedulerCtor {\n  new (maxFrames?: number): VirtualTimeScheduler;\n}\n\nexport interface VirtualTimeScheduler extends SchedulerLike {\n  frameTimeFactor: number;\n  index: number;\n  maxFrames: number;\n  flush(): void;\n  frame: number;\n}\n\ninterface VirtualAction<T=any> {\n  index: number;\n  delay: number;\n  work: (state: T) => void;\n  state: T|undefined;\n  subs: Subscription;\n}\n\nfunction VirtualTimeSchedulerImpl(this: any, maxFrames = Number.POSITIVE_INFINITY) {\n  this._actions = [];\n  this._flushing = false;\n  this.maxFrames = Number.POSITIVE_INFINITY;\n  this.frame = 0;\n  this.frameTimeFactor = 1;\n  this.index = -1;\n}\n\nconst proto = VirtualTimeSchedulerImpl.prototype;\n\nproto.schedule = function<T>(this: any, work: (state: T) => void, delay = 0, state = undefined as T, subs?: Subscription): Subscription {\n  subs = subs || new Subscription();\n  const actions = this._actions;\n  const action = {\n    index: this.index++,\n    delay: this.frame + delay,\n    work,\n    state,\n    subs,\n  };\n  subs.add(() => {\n    const i = actions.indexOf(action);\n    if (i >= 0) {\n      actions.splice(i, 1);\n    }\n  });\n  actions.push(action);\n  actions.sort(sortActions);\n  return subs;\n};\n\nproto.now = function () {\n  return this.frame;\n};\n\nproto.flush = function (this: any) {\n  if (!this._flushing) {\n    const actions = this._actions;\n\n    const maxFrames = this.maxFrames;\n    this._flushing = true;\n    let action: VirtualAction;\n    while (action = actions.shift()) {\n      // ) && (this.frame = action.delay) <= maxFrames\n\n      if (this.frame > action.delay) {\n        // skip frames that were scheduled in the past. That shouldn't be possible.\n        continue;\n      }\n\n      this.frame = action.delay;\n      if (this.frame > maxFrames) {\n        break;\n      }\n\n      try {\n        action.work(action.state);\n      } catch (err) {\n        while(actions.length > 0) {\n          actions.shift().subs.unsubscribe();\n        }\n        throw err;\n      }\n    }\n    actions.length = 0;\n    this._flushing = false;\n  }\n}\n\nexport const VirtualTimeScheduler: VirtualTimeSchedulerCtor = VirtualTimeSchedulerImpl as any;\n\nfunction sortActions(a: VirtualAction, b: VirtualAction) {\n  if (a.delay === b.delay) {\n    if (a.index === b.index) {\n      return 0;\n    } else if (a.index > b.index) {\n      return 1;\n    } else {\n      return -1;\n    }\n  } else if (a.delay > b.delay) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n","import { ObservableInput, FOType, Sink, Source, SinkArg } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { fromSource } from \"rxjs/internal/sources/fromSource\";\nimport { identity } from 'rxjs/internal/util/identity';\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\n\n/* tslint:disable:max-line-length */\nexport function combineLatest<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\nexport function combineLatest<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\nexport function combineLatest<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\nexport function combineLatest<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\nexport function combineLatest<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\nexport function combineLatest<T>(array: ObservableInput<T>[]): Observable<T[]>;\nexport function combineLatest<R>(array: ObservableInput<any>[]): Observable<R>;\nexport function combineLatest<T>(...observables: Array<ObservableInput<T>>): Observable<T[]>;\n/* tslint:enable:max-line-length */\n\nexport function combineLatest<T>(...sources: ObservableInput<T>[]): Observable<T> {\n  if (sources && sources.length === 1 && Array.isArray(sources[0])) {\n    sources = sources[0] as any;\n  }\n  return sourceAsObservable(combineLatestSource(sources));\n}\n\nexport function combineLatestSource<T>(sources: ObservableInput<T>[]): Source<T> {\n  return (type: FOType, dest: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const values = new Array(sources.length);\n      let emittedOnce = sources.map(() => false);\n      let completed = sources.map(() => false);\n      let hasValues = false;\n\n      for (let s = 0; s < sources.length; s++) {\n        const source = sources[s];\n        const src = tryUserFunction(fromSource, source);\n        if (resultIsError(src)) {\n          dest(FOType.ERROR, src.error, subs);\n          return;\n        }\n\n        src(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, subs: Subscription) => {\n          switch (t) {\n            case FOType.NEXT:\n              values[s] = v;\n              emittedOnce[s] = true;\n              if (hasValues || (hasValues = emittedOnce.every(identity))) {\n                dest(FOType.NEXT, values.slice(0), subs);\n              }\n              break;\n            case FOType.ERROR:\n              dest(t, v, subs);\n              break;\n            case FOType.COMPLETE:\n              completed[s] = true;\n              if (completed.every(identity)) {\n                dest(FOType.COMPLETE, undefined, subs);\n              }\n              break;\n            default:\n              break;\n          }\n        }, subs);\n      }\n    }\n  };\n}\n","import { ObservableInput } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { of } from 'rxjs/internal/create/of';\nimport { concatAll } from 'rxjs/internal/operators/derived/concatAll';\n\nexport function concat<T>(...sources: ObservableInput<T>[]): Observable<T> {\n  return of(...sources).pipe(concatAll());\n}\n","import { Observable } from \"rxjs/internal/Observable\";\nimport { sourceAsObservable } from \"rxjs/internal/util/sourceAsObservable\";\nimport { Subscription } from \"rxjs/internal/Subscription\";\nimport { FOType, Sink } from \"rxjs/internal/types\";\n\nexport interface NodeStyleEventEmitter {\n  addListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n  removeListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n}\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\n// For APIs that implement `addListener` and `removeListener` methods that may\n// not use the same arguments or return EventEmitter values\n// such as React Native\nexport interface NodeCompatibleEventEmitter {\n  addListener: (eventName: string, handler: NodeEventHandler) => void | {};\n  removeListener: (eventName: string, handler: NodeEventHandler) => void | {};\n}\n\nexport interface JQueryStyleEventEmitter {\n  on: (eventName: string, handler: Function) => void;\n  off: (eventName: string, handler: Function) => void;\n}\n\nexport interface HasEventTargetAddRemove<E> {\n  addEventListener(type: string, listener: ((evt: E) => void) | null, options?: boolean | AddEventListenerOptions): void;\n  removeEventListener(type: string, listener?: ((evt: E) => void) | null, options?: EventListenerOptions | boolean): void;\n}\n\nexport type EventTargetLike<T> = HasEventTargetAddRemove<T> | NodeStyleEventEmitter | NodeCompatibleEventEmitter | JQueryStyleEventEmitter;\n\nexport type FromEventTarget<T> = EventTargetLike<T> | ArrayLike<EventTargetLike<T>>;\n\nexport interface EventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n}\n\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\n/* tslint:disable:max-line-length */\nexport function fromEvent<T>(target: FromEventTarget<T>, eventName: string): Observable<T>;\nexport function fromEvent<T>(target: FromEventTarget<T>, eventName: string, options: EventListenerOptions): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an Observable that emits events of a specific type coming from the\n * given event target.\n *\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n * EventEmitter events or others.</span>\n *\n * ![](fromEvent.png)\n *\n * `fromEvent` accepts as a first argument event target, which is an object with methods\n * for registering event handler functions. As a second argument it takes string that indicates\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n * which are described in detail below. If your event target does not match any of the ones listed,\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n * handler functions have different names, but they all accept a string describing event type\n * and function itself, which will be called whenever said event happens.\n *\n * Every time resulting Observable is subscribed, event handler function will be registered\n * to event target on given event type. When that event fires, value\n * passed as a first argument to registered function will be emitted by output Observable.\n * When Observable is unsubscribed, function will be unregistered from event target.\n *\n * Note that if event target calls registered function with more than one argument, second\n * and following arguments will not appear in resulting stream. In order to get access to them,\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\n * passed to event handler. Output Observable will then emit value returned by project function,\n * instead of the usual value.\n *\n * Remember that event targets listed below are checked via duck typing. It means that\n * no matter what kind of object you have and no matter what environment you work in,\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\n * of course they behave as was described above). So for example if Node.js library exposes\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n * a good choice.\n *\n * If the API you use is more callback then event handler oriented (subscribed\n * callback function fires only once and thus there is no need to manually\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n * instead.\n *\n * `fromEvent` supports following types of event targets:\n *\n * **DOM EventTarget**\n *\n * This is an object with `addEventListener` and `removeEventListener` methods.\n *\n * In the browser, `addEventListener` accepts - apart from event type string and event\n * handler function arguments - optional third parameter, which is either an object or boolean,\n * both used for additional configuration how and when passed function will be called. When\n * `fromEvent` is used with event target of that type, you can provide this values\n * as third parameter as well.\n *\n * **Node.js EventEmitter**\n *\n * An object with `addListener` and `removeListener` methods.\n *\n * **JQuery-style event target**\n *\n * An object with `on` and `off` methods\n *\n * **DOM NodeList**\n *\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n *\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n * it contains and install event handler function in every of them. When returned Observable\n * is unsubscribed, function will be removed from all Nodes.\n *\n * **DOM HtmlCollection**\n *\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n * installed and removed in each of elements.\n *\n *\n * ## Examples\n * ### Emits clicks happening on the DOM document\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * clicks.subscribe(x => console.log(x));\n *\n * // Results in:\n * // MouseEvent object logged to console every time a click\n * // occurs on the document.\n * ```\n *\n * ### Use addEventListener with capture option\n * ```javascript\n * const clicksInDocument = fromEvent(document, 'click', true); // note optional configuration parameter\n *                                                              // which will be passed to addEventListener\n * const clicksInDiv = fromEvent(someDivInDocument, 'click');\n *\n * clicksInDocument.subscribe(() => console.log('document'));\n * clicksInDiv.subscribe(() => console.log('div'));\n *\n * // By default events bubble UP in DOM tree, so normally\n * // when we would click on div in document\n * // \"div\" would be logged first and then \"document\".\n * // Since we specified optional `capture` option, document\n * // will catch event when it goes DOWN DOM tree, so console\n * // will log \"document\" and then \"div\".\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n * @see {@link fromEventPattern}\n *\n * @param {FromEventTarget<T>} target The DOM EventTarget, Node.js\n * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n * @param {string} eventName The event name of interest, being emitted by the\n * `target`.\n * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n * @return {Observable<T>}\n * @name fromEvent\n */\nexport function fromEvent<T>(\n  target: FromEventTarget<T>,\n  eventName: string,\n  options?: EventListenerOptions,\n): Observable<T> {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    function handler(e: T) {\n      const arg = arguments.length > 1 ? Array.from(arguments) : e;\n      sink(FOType.NEXT, arg, subs);\n    }\n    setupSubscription(target, eventName, handler, subs, sink,  options as EventListenerOptions);\n  });\n}\n\nfunction setupSubscription<T>(sourceObj: FromEventTarget<T>, eventName: string,\n  handler: (...args: any[]) => void, subs: Subscription, sink: Sink<T>,\n  options?: EventListenerOptions) {\n  let unsubscribe: () => void;\n  if (isEventTarget(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.addEventListener(eventName, handler, options);\n    unsubscribe = () => source.removeEventListener(eventName, handler, options);\n  } else if (isJQueryStyleEventEmitter(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.on(eventName, handler);\n    unsubscribe = () => source.off(eventName, handler);\n  } else if (isNodeStyleEventEmitter(sourceObj)) {\n    const source = sourceObj;\n    sourceObj.addListener(eventName, handler as NodeEventHandler);\n    unsubscribe = () => source.removeListener(eventName, handler as NodeEventHandler);\n  } else if (sourceObj && (sourceObj as any).length) {\n    for (let i = 0, len = (sourceObj as any).length; i < len; i++) {\n      setupSubscription(sourceObj[i], eventName, handler, subs, sink, options);\n    }\n  } else {\n    sink(FOType.ERROR, new TypeError('Invalid event target'), subs);\n    return;\n  }\n\n  subs.add(unsubscribe);\n}\n\nfunction isNodeStyleEventEmitter(sourceObj: any): sourceObj is NodeStyleEventEmitter {\n  return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\n\nfunction isJQueryStyleEventEmitter(sourceObj: any): sourceObj is JQueryStyleEventEmitter {\n  return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\n\nfunction isEventTarget(sourceObj: any): sourceObj is HasEventTargetAddRemove<any> {\n  return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\n\n/**\n * Creates an Observable from an arbitrary API for registering event handlers.\n *\n * <span class=\"informal\">When that method for adding event handler was something {@link fromEvent}\n * was not prepared for.</span>\n *\n * ![](fromEventPattern.png)\n *\n * `fromEventPattern` allows you to convert into an Observable any API that supports registering handler functions\n * for events. It is similar to {@link fromEvent}, but far\n * more flexible. In fact, all use cases of {@link fromEvent} could be easily handled by\n * `fromEventPattern` (although in slightly more verbose way).\n *\n * This operator accepts as a first argument an `addHandler` function, which will be injected with\n * handler parameter. That handler is actually an event handler function that you now can pass\n * to API expecting it. `addHandler` will be called whenever Observable\n * returned by the operator is subscribed, so registering handler in API will not\n * necessarily happen when `fromEventPattern` is called.\n *\n * After registration, every time an event that we listen to happens,\n * Observable returned by `fromEventPattern` will emit value that event handler\n * function was called with. Note that if event handler was called with more\n * then one argument, second and following arguments will not appear in the Observable.\n *\n * If API you are using allows to unregister event handlers as well, you can pass to `fromEventPattern`\n * another function - `removeHandler` - as a second parameter. It will be injected\n * with the same handler function as before, which now you can use to unregister\n * it from the API. `removeHandler` will be called when consumer of resulting Observable\n * unsubscribes from it.\n *\n * In some APIs unregistering is actually handled differently. Method registering an event handler\n * returns some kind of token, which is later used to identify which function should\n * be unregistered or it itself has method that unregisters event handler.\n * If that is the case with your API, make sure token returned\n * by registering method is returned by `addHandler`. Then it will be passed\n * as a second argument to `removeHandler`, where you will be able to use it.\n *\n * If you need access to all event handler parameters (not only the first one),\n * or you need to transform them in any way, you can call `fromEventPattern` with optional\n * third parameter - project function which will accept all arguments passed to\n * event handler when it is called. Whatever is returned from project function will appear on\n * resulting stream instead of usual event handlers first argument. This means\n * that default project can be thought of as function that takes its first parameter\n * and ignores the rest.\n *\n * ## Example\n * ### Emits clicks happening on the DOM document\n *\n * ```javascript\n * function addClickHandler(handler) {\n *   document.addEventListener('click', handler);\n * }\n *\n * function removeClickHandler(handler) {\n *   document.removeEventListener('click', handler);\n * }\n *\n * const clicks = fromEventPattern(\n *   addClickHandler,\n *   removeClickHandler\n * );\n * clicks.subscribe(x => console.log(x));\n *\n * // Whenever you click anywhere in the browser, DOM MouseEvent\n * // object will be logged.\n * ```\n *\n * ## Example\n * ### Use with API that returns cancellation token\n *\n * ```javascript\n * const token = someAPI.registerEventHandler(function() {});\n * someAPI.unregisterEventHandler(token); // this APIs cancellation method accepts\n *                                        // not handler itself, but special token.\n *\n * const someAPIObservable = fromEventPattern(\n *   function(handler) { return someAPI.registerEventHandler(handler); }, // Note that we return the token here...\n *   function(handler, token) { someAPI.unregisterEventHandler(token); }  // ...to then use it here.\n * );\n * ```\n *\n * ## Example\n * ### Use with project function\n *\n * ```javascript\n * someAPI.registerEventHandler((eventType, eventMessage) => {\n *   console.log(eventType, eventMessage); // Logs \"EVENT_TYPE\" \"EVENT_MESSAGE\" to console.\n * });\n *\n * const someAPIObservable = fromEventPattern(\n *   handler => someAPI.registerEventHandler(handler),\n *   handler => someAPI.unregisterEventHandler(handler)\n *   (eventType, eventMessage) => eventType + \" --- \" + eventMessage // without that function only \"EVENT_TYPE\"\n * );                                                                // would be emitted by the Observable\n *\n * someAPIObservable.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"EVENT_TYPE --- EVENT_MESSAGE\"\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n *\n * @param {function(handler: Function): any} addHandler A function that takes\n * a `handler` function as argument and attaches it somehow to the actual\n * source of events.\n * @param {function(handler: Function, token?: any): void} [removeHandler] A function that\n * takes a `handler` function as an argument and removes it from the event source. If `addHandler`\n * returns some kind of token, `removeHandler` function will have it as a second parameter.\n * @param {function(...args: any): T} [project] A function to\n * transform results. It takes the arguments from the event handler and\n * should return a single value.\n * @return {Observable<T>} Observable which, when an event happens, emits first parameter\n * passed to registered event handler. Alternatively it emits whatever project function returns\n * at that moment.\n * @static true\n * @name fromEventPattern\n * @owner Observable\n */\n\nexport function fromEventPattern<T>(\n  addHandler: (handler: Function) => any,\n  removeHandler?: (handler: Function, signal?: any) => void\n): Observable<T | T[]> {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    const handler = (...e: T[]) => sink(FOType.NEXT, e.length === 1 ? e[0] : e, subs);\n\n    const retValue = tryUserFunction(addHandler, handler);\n    if (resultIsError(retValue)) {\n      sink(FOType.ERROR, retValue.error, subs);\n      return;\n    }\n\n    if (typeof removeHandler !== 'function') {\n      return;\n    }\n\n    subs.add(() => removeHandler(handler, retValue));\n  });\n}\n","import { ObservableInput } from '../types';\nimport { EMPTY } from '../EMPTY';\nimport { Observable } from '../Observable';\nimport { defer } from './defer';\n\n/**\n * Decides at subscription time which Observable will actually be subscribed.\n *\n * <span class=\"informal\">`If` statement for Observables.</span>\n *\n * `iif` accepts a condition function and two Observables. When\n * an Observable returned by the operator is subscribed, condition function will be called.\n * Based on what boolean it returns at that moment, consumer will subscribe either to\n * the first Observable (if condition was true) or to the second (if condition was false). Condition\n * function may also not return anything - in that case condition will be evaluated as false and\n * second Observable will be subscribed.\n *\n * Note that Observables for both cases (true and false) are optional. If condition points to an Observable that\n * was left undefined, resulting stream will simply complete immediately. That allows you to, rather\n * then controlling which Observable will be subscribed, decide at runtime if consumer should have access\n * to given Observable or not.\n *\n * If you have more complex logic that requires decision between more than two Observables, {@link defer}\n * will probably be a better choice. Actually `iif` can be easily implemented with {@link defer}\n * and exists only for convenience and readability reasons.\n *\n *\n * ## Examples\n * ### Change at runtime which Observable will be subscribed\n * ```javascript\n * let subscribeToFirst;\n * const firstOrSecond = iif(\n *   () => subscribeToFirst,\n *   of('first'),\n *   of('second'),\n * );\n *\n * subscribeToFirst = true;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"first\"\n *\n * subscribeToFirst = false;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"second\"\n *\n * ```\n *\n * ### Control an access to an Observable\n * ```javascript\n * let accessGranted;\n * const observableIfYouHaveAccess = iif(\n *   () => accessGranted,\n *   of('It seems you have an access...'), // Note that only one Observable is passed to the operator.\n * );\n *\n * accessGranted = true;\n * observableIfYouHaveAccess.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('The end'),\n * );\n *\n * // Logs:\n * // \"It seems you have an access...\"\n * // \"The end\"\n *\n * accessGranted = false;\n * observableIfYouHaveAccess.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('The end'),\n * );\n *\n * // Logs:\n * // \"The end\"\n * ```\n *\n * @see {@link defer}\n *\n * @param {function(): boolean} condition Condition which Observable should be chosen.\n * @param {Observable} [trueObservable] An Observable that will be subscribed if condition is true.\n * @param {Observable} [falseObservable] An Observable that will be subscribed if condition is false.\n * @return {Observable} Either first or second Observable, depending on condition.\n * @static true\n * @name iif\n * @owner Observable\n */\nexport function iif<T, F>(\n  condition: () => boolean,\n  trueResult: ObservableInput<T> = EMPTY,\n  falseResult: ObservableInput<F> = EMPTY\n): Observable<T|F> {\n  return defer<T|F>(() => condition() ? trueResult : falseResult);\n}\n","import { ObservableInput } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { of } from 'rxjs/internal/create/of';\nimport { mergeAll } from 'rxjs/internal/operators/derived/mergeAll';\n\nexport function merge<T>(...sources: ObservableInput<T>[]): Observable<T> {\n  return of(...sources).pipe(mergeAll());\n}\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink, SinkArg} from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { RecyclableSubscription } from 'rxjs/internal/RecyclableSubscription';\n\nexport function onEmptyResumeNext<T>(...sources: Array<Observable<T>>): Observable<T> {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, dest: Sink<T>, downstreamSubs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const remainingSources = sources.slice();\n      let hasValue = false;\n      const upstreamSubs = new RecyclableSubscription();\n      downstreamSubs.add(upstreamSubs);\n\n      let subscribe: () => void;\n      subscribe = () => {\n        const source = remainingSources.shift();\n        hasValue = false;\n        source(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, _: Subscription) => {\n          hasValue = hasValue || t === FOType.NEXT;\n          if (t === FOType.COMPLETE && !hasValue) {\n            upstreamSubs.recycle();\n            subscribe();\n          } else {\n            dest(t, v, downstreamSubs);\n          }\n        }, upstreamSubs);\n      };\n\n      subscribe();\n    }\n  });\n}\n\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink, SinkArg, ObservableInput} from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { RecyclableSubscription } from 'rxjs/internal/RecyclableSubscription';\nimport { tryUserFunction, resultIsError } from '../util/userFunction';\nimport { fromSource } from '../sources/fromSource';\n\nexport function onErrorResumeNext<T>(...sources: ObservableInput<T>[]): Observable<T> {\n  if (sources.length === 1 && Array.isArray(sources[0])) {\n    return onErrorResumeNext(...(sources[0] as any[]));\n  }\n  return sourceAsObservable((type: FOType.SUBSCRIBE, dest: Sink<T>, downstreamSubs: Subscription) => {\n    const remainingSources = sources.slice();\n    const upstreamSubs = new RecyclableSubscription();\n    downstreamSubs.add(upstreamSubs);\n\n    let subscribe: () => void;\n    subscribe = () => {\n      const input = remainingSources.shift();\n      const source = tryUserFunction(fromSource, input);\n      if (resultIsError(source)) {\n        upstreamSubs.recycle();\n        subscribe();\n        return;\n      }\n      source(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, _: Subscription) => {\n        if (t === FOType.ERROR && remainingSources.length > 0) {\n          upstreamSubs.recycle();\n          subscribe();\n        } else {\n          if (t === FOType.ERROR) {\n            t = FOType.COMPLETE;\n          }\n          dest(t, v, downstreamSubs);\n        }\n      }, upstreamSubs);\n    };\n\n    subscribe();\n  });\n}\n\n","import { filter } from 'rxjs/internal/operators/filter';\nimport { Observable } from 'rxjs/internal/Observable';\n\n\nexport function partition<T>(source: Observable<T>, predicate: (value: T, index: number) => boolean) {\n  return [\n    source.pipe(filter(predicate)),\n    source.pipe(filter((v, i) => !predicate(v, i))),\n  ];\n}\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { FOType, Sink } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\n\n/**\n * Convert an object into an Observable of `[key, value]` pairs.\n *\n * <span class=\"informal\">Turn entries of an object into a stream.</span>\n *\n * <img src=\"./img/pairs.png\" width=\"100%\">\n *\n * `pairs` takes an arbitrary object and returns an Observable that emits arrays. Each\n * emitted array has exactly two elements - the first is a key from the object\n * and the second is a value corresponding to that key. Keys are extracted from\n * an object via `Object.keys` function, which means that they will be only\n * enumerable keys that are present on an object directly - not ones inherited\n * via prototype chain.\n *\n * By default these arrays are emitted synchronously. To change that you can\n * pass a {@link SchedulerLike} as a second argument to `pairs`.\n *\n * @example <caption>Converts a javascript object to an Observable</caption>\n * ```javascript\n * const obj = {\n *   foo: 42,\n *   bar: 56,\n *   baz: 78\n * };\n *\n * pairs(obj)\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n *\n * // Logs:\n * // [\"foo\", 42],\n * // [\"bar\", 56],\n * // [\"baz\", 78],\n * // \"the end!\"\n * ```\n *\n * @param {Object} obj The object to inspect and turn into an\n * Observable sequence.\n * @returns {(Observable<Array<string|T>>)} An observable sequence of\n * [key, value] pairs from the object.\n */\nexport function pairs<T>(obj: Object): Observable<[string, T]> {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<[string, T]>, subs: Subscription) => {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length && !subs.closed; i++) {\n      const key = keys[i];\n      if (obj.hasOwnProperty(key)) {\n        sink(FOType.NEXT, [key, obj[key]], subs);\n      }\n    }\n    sink(FOType.COMPLETE, undefined, subs);\n  });\n}\n","import { multicast } from 'rxjs/internal/create/multicast';\nimport { ConnectableObservable } from 'rxjs/internal/ConnectableObservable';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { Subject } from 'rxjs/internal/Subject';\n\nexport function publish<T>(source: Observable<T>): ConnectableObservable<T> {\n  return multicast(source, new Subject<T>());\n}\n","import { multicast } from 'rxjs/internal/create/multicast';\nimport { ConnectableObservable } from 'rxjs/internal/ConnectableObservable';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { BehaviorSubject } from 'rxjs/internal/BehaviorSubject';\n\nexport function publishBehavior<T>(source: Observable<T>, initialValue: T): ConnectableObservable<T> {\n  return multicast(source, new BehaviorSubject<T>(initialValue));\n}\n","import { multicast } from 'rxjs/internal/create/multicast';\nimport { ConnectableObservable } from 'rxjs/internal/ConnectableObservable';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { AsyncSubject } from 'rxjs/internal/AsyncSubject';\n\nexport function publishLast<T>(source: Observable<T>): ConnectableObservable<T> {\n  return multicast(source, new AsyncSubject<T>());\n}\n","import { multicast } from 'rxjs/internal/create/multicast';\nimport { ConnectableObservable } from 'rxjs/internal/ConnectableObservable';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { ReplaySubject } from 'rxjs/internal/ReplaySubject';\n\nexport function publishReplay<T>(source: Observable<T>, bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY): ConnectableObservable<T> {\n  return multicast(source, new ReplaySubject<T>(bufferSize, windowTime));\n}\n","import { ObservableInput, FOType, Sink, Source, SinkArg } from 'rxjs/internal/types';\nimport { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { fromSource } from \"rxjs/internal/sources/fromSource\";\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\n\n\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item.\n *\n * ## Example\n * ### Subscribes to the observable that was the first to start emitting.\n *\n * ```javascript\n * const obs1 = interval(1000).pipe(mapTo('fast one'));\n * const obs2 = interval(3000).pipe(mapTo('medium one'));\n * const obs3 = interval(5000).pipe(mapTo('slow one'));\n *\n * race(obs3, obs1, obs2)\n * .subscribe(\n *   winner => console.log(winner)\n * );\n *\n * // result:\n * // a series of 'fast one'\n * ```\n *\n * @param {...ObservableInput<T>[]} sources ...observables sources used to race for which Observable emits first.\n * @return {ObservableInput[]} an Observable that mirrors the output of the first Observable to emit an item.\n * @static true\n * @name race\n * @owner Observable\n */\nexport function race<T>(sources: Array<ObservableInput<T>>): Observable<T>;\nexport function race<T>(...sources: ObservableInput<T>[]): Observable<T>;\nexport function race<T>(...sources: ObservableInput<T>[]): Observable<T> {\n  if (sources.length === 1 && Array.isArray(sources[0])) {\n    sources = sources[0] as any;\n  }\n  return sourceAsObservable(raceSource(sources));\n}\n\nexport function raceSource<T>(sources: ObservableInput<T>[]): Source<T> {\n  return (type: FOType, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      let allSubs: Subscription[] = [];\n      for (let s = 0; s < sources.length; s++) {\n        const source = sources[s];\n        const src = tryUserFunction(fromSource, source);\n        if (resultIsError(src)) {\n          sink(FOType.ERROR, src.error, subs);\n          return;\n        }\n\n        const mySubs = new Subscription();\n        subs.add(mySubs);\n        allSubs.push(mySubs);\n        src(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, mySubs: Subscription) => {\n          if (allSubs && t === FOType.NEXT) {\n            for (let childSubs of allSubs) {\n              if (childSubs !== mySubs) childSubs.unsubscribe();\n            }\n            allSubs = null;\n          }\n          sink(t, v, subs);\n        }, mySubs);\n      }\n    }\n  };\n}\n","import { Observable } from \"rxjs/internal/Observable\";\nimport { sourceAsObservable } from \"rxjs/internal/util/sourceAsObservable\";\nimport { FOType, Sink } from \"rxjs/internal/types\";\nimport { Subscription } from \"rxjs/internal/Subscription\";\n\n/**\n * Creates an Observable that emits a sequence of numbers within a specified\n * range.\n *\n * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n *\n * ![](range.png)\n *\n * `range` operator emits a range of sequential integers, in order, where you\n * select the `start` of the range and its `length`. By default, uses no\n * {@link SchedulerLike} and just delivers the notifications synchronously, but may use\n * an optional {@link SchedulerLike} to regulate those deliveries.\n *\n * ## Example\n * Emits the numbers 1 to 10</caption>\n * ```javascript\n * const numbers = range(1, 10);\n * numbers.subscribe(x => console.log(x));\n * ```\n * @see {@link timer}\n * @see {@link index/interval}\n *\n * @param {number} [start=0] The value of the first integer in the sequence.\n * @param {number} [count=0] The number of sequential integers to generate.\n * @return {Observable} An Observable of numbers that emits a finite range of\n * sequential integers.\n * @static true\n * @name range\n * @owner Observable\n */\nexport function range(start = 0, count = 0): Observable<number> {\n  return sourceAsObservable((type: FOType.SUBSCRIBE, sink: Sink<number>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      const end = start + count;\n      for (let n = start; n < end && !subs.closed; n++) {\n        sink(FOType.NEXT, n, subs);\n      }\n      sink(FOType.COMPLETE, undefined, subs);\n    }\n  });\n}\n","import { Unsubscribable, ObservableInput, FOType, Sink } from \"../types\";\nimport { Observable } from \"../Observable\";\nimport { from } from \"./from\";\nimport { EMPTY } from \"../EMPTY\";\n\n/**\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\n *\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\n *\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\n * that object and should return an Observable. That Observable can use resource object during its execution.\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\n * resource object will be shared in any way between subscriptions.\n *\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\n *\n * @see {@link defer}\n *\n * @param {function(): ISubscription} resourceFactory A function which creates any resource object\n * that implements `unsubscribe` method.\n * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which\n * creates an Observable, that can use injected resource object.\n * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\n */\nexport function using<T>(\n  resourceFactory: () => Unsubscribable | void,\n  observableFactory: (resource: Unsubscribable | void) => ObservableInput<T> | void\n): Observable<T> {\n  return new Observable<T>(subscriber => {\n    let resource: Unsubscribable | void;\n\n    try {\n      resource = resourceFactory();\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n\n    let result: ObservableInput<T> | void;\n    try {\n      result = observableFactory(resource);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n\n    const source = result ? from(result) : EMPTY;\n    const subscription = source.subscribe(subscriber);\n    return () => {\n      subscription.unsubscribe();\n      if (resource) {\n        resource.unsubscribe();\n      }\n    };\n  });\n}\n","import { Observable } from 'rxjs/internal/Observable';\nimport { sourceAsObservable } from 'rxjs/internal/util/sourceAsObservable';\nimport { ObservableInput, Source, FOType, Sink, SinkArg } from 'rxjs/internal/types';\nimport { Subscription } from 'rxjs/internal/Subscription';\nimport { fromSource } from \"rxjs/internal/sources/fromSource\";\nimport { identity } from 'rxjs/internal/util/identity';\nimport { tryUserFunction, resultIsError } from 'rxjs/internal/util/userFunction';\nimport { isIterable } from '../util/isIterable';\n\n/* tslint:disable:max-line-length */\nexport function zip<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\nexport function zip<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\nexport function zip<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\nexport function zip<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\nexport function zip<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\n\nexport function zip<T>(array: ObservableInput<T>[]): Observable<T[]>;\nexport function zip<R>(array: ObservableInput<any>[]): Observable<R>;\nexport function zip<T>(...observables: Array<ObservableInput<T>>): Observable<T[]>;\nexport function zip<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): Observable<R>;\nexport function zip<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\n/* tslint:enable:max-line-length */\n\nexport function zip<T>(...sources: ObservableInput<T>[]): Observable<T> {\n  return sourceAsObservable(zipSource(sources));\n}\n\nfunction zipSource<T>(sources: ObservableInput<T>[]): Source<T> {\n  return (type: FOType.SUBSCRIBE, sink: Sink<T>, subs: Subscription) => {\n    if (type === FOType.SUBSCRIBE) {\n      if (sources.length === 0) {\n        sink(FOType.COMPLETE, undefined, subs);\n        return;\n      }\n      const state: Array<{ buffer: T[], complete: boolean }> = [];\n      for (let i = 0; i < sources.length; i++) {\n        const buffer = [] as T[];\n        const currentState = {\n          buffer,\n          complete: false,\n        };\n        state.push(currentState);\n\n        const source = sources[i];\n        const src = tryUserFunction(fromSource, source);\n        if (resultIsError(src)) {\n          sink(FOType.ERROR, src.error, subs);\n          return;\n        }\n\n        src(FOType.SUBSCRIBE, (t: FOType, v: SinkArg<T>, subs: Subscription) => {\n          switch (t) {\n            case FOType.NEXT:\n              buffer.push(v);\n              while (state.length === sources.length && state.every(({ buffer }) => buffer.length > 0)) {\n                sink(FOType.NEXT, state.map(s => s.buffer.shift()), subs);\n              }\n              if (state.some(s => s.complete && s.buffer.length === 0)) {\n                sink(FOType.COMPLETE, undefined, subs);\n                subs.unsubscribe();\n              }\n              break;\n            case FOType.ERROR:\n              sink(t, v, subs);\n              break;\n            case FOType.COMPLETE:\n              currentState.complete = true;\n              if (buffer.length === 0) {\n                sink(t, v, subs);\n                subs.unsubscribe();\n              }\n              break;\n            default:\n              break;\n          }\n        }, subs);\n      }\n    }\n  };\n}\n"],"names":["FOType","noop","ERROR_OBJECT","error","tryUserFunction","fn","result","_i","args","err","resultIsError","UnsubscriptionErrorImpl","errors","Error","call","this","message","length","map","i","toString","join","name","prototype","Object","create","UnsubscriptionError","Subscription","teardowns","_teardowns","_closed","EMPTY_SUBSCRIPTION","EMPTY","subscriptionProto","teardownToFunction","teardown","unsubscribe","identity","x","pipeArray","fns","reduce","prev","sinkFromObserver","observer","type","arg","subs","NEXT","next","ERROR","COMPLETE","complete","isPartialObserver","o","sourceAsObservable","source","subscribe","pipe","observablePipe","forEach","toPromise","Symbol","observable","nextOrObserver","errorHandler","completeHandler","sink","subscription","nextHandler","sinkFromHandlers","SUBSCRIBE","closed","console","warn","safeSink","Promise","resolve","reject","completed","errored","add","_this","t","v","_last","undefined","value","operations","sourceAsSubject","asObservable","DISPOSE","ObjectUnsubscribedErrorImpl","obj","this_1","remove","push","teardowns_1","_a","teardowns_2","indexOf","splice","unsubError","shift","defineProperty","get","ObjectUnsubscribedError","subjectBaseSource","state","disposed","copy","slice","Subject","arguments","subjectSource","_error","base","_completed","_hasError","_disposed","AsyncSubject","hasValue","hasCompleted","hasError","subject","BehaviorSubject","initialValue","getValue","ConnectableObservable","subjectFactory","_subject","connectable","connect","refCount","_connection","_refCounter","of","values","ofSource","throwError","Notification","kind","constructor","observe","accept","toObservable","COMPLETE_NOTIFICATION","UNDEFINED_NEXT_NOTIFICATION","createNext","createError","createComplete","CLOSED","rxSubs","Observable","init","dest","subscriber","createSubscriber","hostReportError","setTimeout","EMPTY_OBSERVER","destinationOrNext","_super","destination","Subscriber","syncErrorThrowable","SafeSubscriber","tslib_1.__extends","isStopped","_next","_complete","_parentSubscriber","observerOrNext","context","bind","_context","__tryOrSetError","__tryOrUnsub","wrappedComplete","parent","ReplaySubject","bufferSize","windowTime","Number","POSITIVE_INFINITY","_endType","_endArg","_base","_buffer","now","Date","a","timeout","replaySubjectSource","NEVER","isArrayLike","isPromiseLike","then","isIterable","iterator","symbolObservable","isInteropObservable","symbolAsyncIterator","asyncIterator","isAsyncIterable","isObservable","fromSource","input","promise","iterable","done","subscription_1","obs","symbolObservableSource","getNextValue_1","ai_1","asyncIterableSource","lift","operatorDef","mergeAll","concurrent","project","startNextInner","counter","active","outerComplete","buffer","outerValue","outerIndex","innerSource","innerSubs","mergeMap","concatAll","defer","deferSource","toEmptyState","isComplete","s","from","fromArrayLikeWork","scheduler","schedule","fromIterableWork","asyncScheduler","work","delay","id","clearTimeout","intervalWork","interval","multicast","subjectOrFactory","RecyclableSubscription","apply","filter","predicate","isNumeric","val","Array","isArray","parseFloat","isScheduler","Boolean","timerDelayWork","period","ArgumentOutOfRangeErrorImpl","recycle","ArgumentOutOfRangeError","EmptyErrorImpl","EmptyError","TimeoutErrorImpl","TimeoutError","toAnimate","animId","animationFrameScheduler","cancelAnimationFrame","requestAnimationFrame","p","asapScheduler","stop","QueueSchedulerImpl","_flushing","_queue","proto","queue","QueueScheduler","queueScheduler","VirtualTimeSchedulerImpl","maxFrames","_actions","frame","frameTimeFactor","index","actions","action","sort","sortActions","flush","VirtualTimeScheduler","b","sources","values_1","emittedOnce_1","completed_1","hasValues_1","src","every","combineLatestSource","forkJoin","validSources","state_1","target","eventName","options","setupSubscription","sourceObj","handler","addEventListener","removeEventListener","isEventTarget","source_1","on","off","isJQueryStyleEventEmitter","source_2","addListener","removeListener","isNodeStyleEventEmitter","source_3","TypeError","len","e","addHandler","removeHandler","retValue","fromObservableScheduledSource","fromInteropObservableSource","fromPromiseLikeSource","ai","go","fromAsyncIterableSource","fromIterableScheduledSource","fromArrayLikeScheduledSource","condition","trueResult","falseResult","Math","max","downstreamSubs","subscribe_1","remainingSources_1","hasValue_1","upstreamSubs_1","_","onErrorResumeNext","remainingSources","upstreamSubs","keys","key","hasOwnProperty","allSubs_1","mySubs","allSubs_2","childSubs","raceSource","start","count","end","n","dueTime","periodOrScheduler","due","resourceFactory","observableFactory","resource","state_2","currentState","some","zipSource"],"mappings":"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"}
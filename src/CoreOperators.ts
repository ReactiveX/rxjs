import {Observable} from './Observable';
import {Scheduler} from './Scheduler';

import {CombineLatestSignature} from './operator/combineLatest';
import {WithLatestFromSignature} from './operator/withLatestFrom';
import {ZipSignature} from './operator/zip';
import {BufferSignature} from './operator/buffer';
import {BufferCountSignature} from './operator/bufferCount';
import {BufferTimeSignature} from './operator/bufferTime';
import {BufferToggleSignature} from './operator/bufferToggle';
import {BufferWhenSignature} from './operator/bufferWhen';
import {WindowSignature} from './operator/window';
import {WindowCountSignature} from './operator/windowCount';
import {WindowTimeSignature} from './operator/windowTime';
import {WindowToggleSignature} from './operator/windowToggle';
import {WindowWhenSignature} from './operator/windowWhen';
import {CacheSignature} from './operator/cache';
import {CatchSignature} from './operator/catch';
import {CountSignature} from './operator/count';
import {DematerializeSignature} from './operator/dematerialize';
import {DebounceSignature} from './operator/debounce';
import {DebounceTimeSignature} from './operator/debounceTime';
import {DefaultIfEmptySignature} from './operator/defaultIfEmpty';
import {DelaySignature} from './operator/delay';
import {DelayWhenSignature} from './operator/delayWhen';
import {DistinctUntilChangedSignature} from './operator/distinctUntilChanged';
import {DoSignature} from './operator/do';
import {ExpandSignature} from './operator/expand';
import {FilterSignature} from './operator/filter';
import {FinallySignature} from './operator/finally';
import {FirstSignature} from './operator/first';
import {GroupBySignature} from './operator/groupBy';
import {IgnoreElementsSignature} from './operator/ignoreElements';
import {InspectSignature} from './operator/inspect';
import {InspectTimeSignature} from './operator/inspectTime';
import {LastSignature} from './operator/last';
import {LetSignature} from './operator/let';
import {EverySignature} from './operator/every';
import {MaterializeSignature} from './operator/materialize';
import {MulticastSignature} from './operator/multicast';
import {ObserveOnSignature} from './operator/observeOn';
import {PartitionSignature} from './operator/partition';
import {PluckSignature} from './operator/pluck';
import {PublishSignature} from './operator/publish';
import {PublishBehaviorSignature} from './operator/publishBehavior';
import {PublishReplaySignature} from './operator/publishReplay';
import {PublishLastSignature} from './operator/publishLast';
import {RaceSignature} from './operator/race';
import {ReduceSignature} from './operator/reduce';
import {RepeatSignature} from './operator/repeat';
import {RetrySignature} from './operator/retry';
import {RetryWhenSignature} from './operator/retryWhen';
import {SampleSignature} from './operator/sample';
import {SampleTimeSignature} from './operator/sampleTime';
import {ScanSignature} from './operator/scan';
import {ShareSignature} from './operator/share';
import {SingleSignature} from './operator/single';
import {SkipSignature} from './operator/skip';
import {SkipUntilSignature} from './operator/skipUntil';
import {SkipWhileSignature} from './operator/skipWhile';
import {StartWithSignature} from './operator/startWith';
import {SubscribeOnSignature} from './operator/subscribeOn';
import {TakeSignature} from './operator/take';
import {TakeLastSignature} from './operator/takeLast';
import {TakeUntilSignature} from './operator/takeUntil';
import {TakeWhileSignature} from './operator/takeWhile';
import {ThrottleSignature} from './operator/throttle';
import {ThrottleTimeSignature} from './operator/throttleTime';
import {TimeoutSignature} from './operator/timeout';
import {TimeoutWithSignature} from './operator/timeoutWith';
import {ToArraySignature} from './operator/toArray';
import {ToPromiseSignature} from './operator/toPromise';

export interface CoreOperators<T> {
  buffer: BufferSignature<T>;
  bufferCount: BufferCountSignature<T>;
  bufferTime: BufferTimeSignature<T>;
  bufferToggle: BufferToggleSignature<T>;
  bufferWhen: BufferWhenSignature<T>;
  cache: CacheSignature<T>;
  catch: CatchSignature<T>;
  combineAll: <R>(project?: (...values: Array<any>) => R) => Observable<R>;
  combineLatest: CombineLatestSignature<T>;
  concat?: <R>(...observables: (Observable<any> | Scheduler)[]) => Observable<R>;
  concatAll?: () => Observable<T>;
  concatMap?: <R>(project: ((x: T, ix: number) => Observable<any>), projectResult?: (x: T, y: any, ix: number, iy: number) => R) => Observable<R>;
  concatMapTo?: <R>(observable: Observable<any>, projectResult?: (x: T, y: any, ix: number, iy: number) => R) => Observable<R>;
  count: CountSignature<T>;
  dematerialize: DematerializeSignature<T>;
  debounce: DebounceSignature<T>;
  debounceTime: DebounceTimeSignature<T>;
  defaultIfEmpty: DefaultIfEmptySignature<T>;
  delay: DelaySignature<T>;
  delayWhen: DelayWhenSignature<T>;
  distinctUntilChanged: DistinctUntilChangedSignature<T>;
  do: DoSignature<T>;
  expand: ExpandSignature<T>;
  filter: FilterSignature<T>;
  finally: FinallySignature<T>;
  first: FirstSignature<T>;
  flatMap?: <R>(project: ((x: T, ix: number) => Observable<any>),
                projectResult?: (x: T, y: any, ix: number, iy: number) => R,
                concurrent?: number) => Observable<R>;
  flatMapTo?: <R>(observable: Observable<any>, projectResult?: (x: T, y: any, ix: number, iy: number) => R, concurrent?: number) => Observable<R>;
  groupBy: GroupBySignature<T>;
  ignoreElements: IgnoreElementsSignature<T>;
  inspect: InspectSignature<T>;
  inspectTime: InspectTimeSignature<T>;
  last: LastSignature<T>;
  let: LetSignature<T>;
  letBind: LetSignature<T>;
  every: EverySignature<T>;
  map?: <R>(project: (x: T, ix?: number) => R, thisArg?: any) => Observable<R>;
  mapTo?: <R>(value: R) => Observable<R>;
  materialize: MaterializeSignature<T>;
  merge?: (...observables: any[]) => Observable<any>;
  mergeAll?: (concurrent?: number) => Observable<T>;
  mergeMap?: <R>(project: ((x: T, ix: number) => Observable<any>),
                 projectResult?: (x: T, y: any, ix: number, iy: number) => R, concurrent?: number) => Observable<R>;
  mergeMapTo?: <R>(observable: Observable<any>, projectResult?: (x: T, y: any, ix: number, iy: number) => R, concurrent?: number) => Observable<R>;
  multicast: MulticastSignature<T>;
  observeOn: ObserveOnSignature<T>;
  partition: PartitionSignature<T>;
  pluck: PluckSignature<T>;
  publish: PublishSignature<T>;
  publishBehavior: PublishBehaviorSignature<T>;
  publishReplay: PublishReplaySignature<T>;
  publishLast: PublishLastSignature<T>;
  race: RaceSignature<T>;
  reduce: ReduceSignature<T>;
  repeat: RepeatSignature<T>;
  retry: RetrySignature<T>;
  retryWhen: RetryWhenSignature<T>;
  sample: SampleSignature<T>;
  sampleTime: SampleTimeSignature<T>;
  scan: ScanSignature<T>;
  share: ShareSignature<T>;
  single: SingleSignature<T>;
  skip: SkipSignature<T>;
  skipUntil: SkipUntilSignature<T>;
  skipWhile: SkipWhileSignature<T>;
  startWith: StartWithSignature<T>;
  subscribeOn: SubscribeOnSignature<T>;
  switch?: () => Observable<T>;
  switchMap?: <R>(project: ((x: T, ix: number) => Observable<any>), projectResult?: (x: T, y: any, ix: number, iy: number) => R) => Observable<R>;
  switchMapTo?: <R>(observable: Observable<any>, projectResult?: (x: T, y: any, ix: number, iy: number) => R) => Observable<R>;
  take: TakeSignature<T>;
  takeLast: TakeLastSignature<T>;
  takeUntil: TakeUntilSignature<T>;
  takeWhile: TakeWhileSignature<T>;
  throttle: ThrottleSignature<T>;
  throttleTime: ThrottleTimeSignature<T>;
  timeout: TimeoutSignature<T>;
  timeoutWith: TimeoutWithSignature<T>;
  toArray: ToArraySignature<T>;
  toPromise: ToPromiseSignature<T>;
  window: WindowSignature<T>;
  windowCount: WindowCountSignature<T>;
  windowTime: WindowTimeSignature<T>;
  windowToggle: WindowToggleSignature<T>;
  windowWhen: WindowWhenSignature<T>;
  withLatestFrom: WithLatestFromSignature<T>;
  zip: ZipSignature<T>;
  zipAll?: <R>(project?: (...values: Array<any>) => R) => Observable<R>;
}

{
  "type": "Program",
  "body": [
    {
      "type": "ImportDeclaration",
      "specifiers": [
        {
          "type": "ImportSpecifier",
          "local": {
            "type": "Identifier",
            "name": "Observable",
            "range": [
              9,
              19
            ],
            "loc": {
              "start": {
                "line": 1,
                "column": 9
              },
              "end": {
                "line": 1,
                "column": 19
              }
            }
          },
          "imported": {
            "type": "Identifier",
            "name": "Observable",
            "range": [
              9,
              19
            ],
            "loc": {
              "start": {
                "line": 1,
                "column": 9
              },
              "end": {
                "line": 1,
                "column": 19
              }
            }
          },
          "range": [
            9,
            19
          ],
          "loc": {
            "start": {
              "line": 1,
              "column": 9
            },
            "end": {
              "line": 1,
              "column": 19
            }
          }
        }
      ],
      "source": {
        "type": "Literal",
        "value": "./Observable",
        "raw": "'./Observable'",
        "range": [
          27,
          41
        ],
        "loc": {
          "start": {
            "line": 1,
            "column": 27
          },
          "end": {
            "line": 1,
            "column": 41
          }
        }
      },
      "range": [
        0,
        42
      ],
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 42
        }
      }
    },
    {
      "type": "ImportDeclaration",
      "specifiers": [],
      "source": {
        "type": "Literal",
        "value": "./scheduler/MiscJSDoc",
        "raw": "'./scheduler/MiscJSDoc'",
        "range": [
          50,
          73
        ],
        "loc": {
          "start": {
            "line": 2,
            "column": 7
          },
          "end": {
            "line": 2,
            "column": 30
          }
        }
      },
      "range": [
        43,
        74
      ],
      "loc": {
        "start": {
          "line": 2,
          "column": 0
        },
        "end": {
          "line": 2,
          "column": 31
        }
      }
    },
    {
      "type": "ImportDeclaration",
      "specifiers": [],
      "source": {
        "type": "Literal",
        "value": "./observable/dom/MiscJSDoc",
        "raw": "'./observable/dom/MiscJSDoc'",
        "range": [
          82,
          110
        ],
        "loc": {
          "start": {
            "line": 3,
            "column": 7
          },
          "end": {
            "line": 3,
            "column": 35
          }
        }
      },
      "range": [
        75,
        111
      ],
      "loc": {
        "start": {
          "line": 3,
          "column": 0
        },
        "end": {
          "line": 3,
          "column": 36
        }
      },
      "trailingComments": [
        {
          "type": "Block",
          "value": "*\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n ",
          "range": [
            112,
            206
          ],
          "loc": {
            "start": {
              "line": 4,
              "column": 0
            },
            "end": {
              "line": 8,
              "column": 3
            }
          }
        }
      ]
    },
    {
      "type": "ExportNamedDeclaration",
      "declaration": {
        "type": "ClassDeclaration",
        "id": {
          "type": "Identifier",
          "name": "ObservableDoc",
          "range": [
            220,
            233
          ],
          "loc": {
            "start": {
              "line": 9,
              "column": 13
            },
            "end": {
              "line": 9,
              "column": 26
            }
          }
        },
        "superClass": null,
        "body": {
          "type": "ClassBody",
          "body": [
            {
              "type": "MethodDefinition",
              "key": {
                "type": "Identifier",
                "name": "create",
                "range": [
                  5497,
                  5503
                ],
                "loc": {
                  "start": {
                    "line": 129,
                    "column": 11
                  },
                  "end": {
                    "line": 129,
                    "column": 17
                  }
                }
              },
              "value": {
                "type": "FunctionExpression",
                "id": null,
                "params": [
                  {
                    "type": "Identifier",
                    "name": "onSubscription",
                    "range": [
                      5504,
                      5518
                    ],
                    "loc": {
                      "start": {
                        "line": 129,
                        "column": 18
                      },
                      "end": {
                        "line": 129,
                        "column": 32
                      }
                    }
                  }
                ],
                "body": {
                  "type": "BlockStatement",
                  "body": [
                    {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "NewExpression",
                        "callee": {
                          "type": "Identifier",
                          "name": "Observable",
                          "range": [
                            5541,
                            5551
                          ],
                          "loc": {
                            "start": {
                              "line": 130,
                              "column": 19
                            },
                            "end": {
                              "line": 130,
                              "column": 29
                            }
                          }
                        },
                        "arguments": [
                          {
                            "type": "Identifier",
                            "name": "onSubscription",
                            "range": [
                              5552,
                              5566
                            ],
                            "loc": {
                              "start": {
                                "line": 130,
                                "column": 30
                              },
                              "end": {
                                "line": 130,
                                "column": 44
                              }
                            }
                          }
                        ],
                        "range": [
                          5537,
                          5567
                        ],
                        "loc": {
                          "start": {
                            "line": 130,
                            "column": 15
                          },
                          "end": {
                            "line": 130,
                            "column": 45
                          }
                        }
                      },
                      "range": [
                        5530,
                        5568
                      ],
                      "loc": {
                        "start": {
                          "line": 130,
                          "column": 8
                        },
                        "end": {
                          "line": 130,
                          "column": 46
                        }
                      }
                    }
                  ],
                  "range": [
                    5520,
                    5574
                  ],
                  "loc": {
                    "start": {
                      "line": 129,
                      "column": 34
                    },
                    "end": {
                      "line": 131,
                      "column": 5
                    }
                  }
                },
                "generator": false,
                "expression": false,
                "range": [
                  5503,
                  5574
                ],
                "loc": {
                  "start": {
                    "line": 129,
                    "column": 17
                  },
                  "end": {
                    "line": 131,
                    "column": 5
                  }
                }
              },
              "kind": "method",
              "computed": false,
              "range": [
                5490,
                5574
              ],
              "loc": {
                "start": {
                  "line": 129,
                  "column": 4
                },
                "end": {
                  "line": 131,
                  "column": 5
                }
              },
              "leadingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * Creates a new Observable, that will execute the specified function when an\n     * {@link Observer} subscribes to it.\n     *\n     * <span class=\"informal\">Create custom Observable, that does whatever you like.</span>\n     *\n     * <img src=\"./img/create.png\" width=\"100%\">\n     *\n     * `create` converts an `onSubscription` function to an actual Observable.\n     * Whenever someone subscribes to that Observable, the function will be called\n     * with an {@link Observer} instance as a first and only parameter. `onSubscription` should\n     * then invoke the Observers `next`, `error` and `complete` methods.\n     *\n     * Calling `next` with a value will emit that value to the observer. Calling `complete`\n     * means that Observable finished emitting and will not do anything else.\n     * Calling `error` means that something went wrong - value passed to `error` method should\n     * provide details on what exactly happened.\n     *\n     * A well-formed Observable can emit as many values as it needs via `next` method,\n     * but `complete` and `error` methods can be called only once and nothing else can be called\n     * thereafter. If you try to invoke `next`, `complete` or `error` methods after created\n     * Observable already completed or ended with an error, these calls will be ignored to\n     * preserve so called *Observable Contract*. Note that you are not required to call\n     * `complete` at any point - it is perfectly fine to create an Observable that never ends,\n     * depending on your needs.\n     *\n     * `onSubscription` can optionally return either a function or an object with\n     * `unsubscribe` method. In both cases function or method will be called when\n     * subscription to Observable is being cancelled and should be used to clean up all\n     * resources. So, for example, if you are using `setTimeout` in your custom\n     * Observable, when someone unsubscribes, you can clear planned timeout, so that\n     * it does not fire needlessly and browser (or other environment) does not waste\n     * computing power on timing event that no one will listen to anyways.\n     *\n     * Most of the times you should not need to use `create`, because existing\n     * operators allow you to create an Observable for most of the use cases.\n     * That being said, `create` is low-level mechanism allowing you to create\n     * any Observable, if you have very specific needs.\n     *\n     * **TypeScript signature issue**\n     *\n     * Because Observable extends class which already has defined static `create` function,\n     * but with different type signature, it was impossible to assign proper signature to\n     * `Observable.create`. Because of that, it has very general type `Function` and thus\n     * function passed to `create` will not be type checked, unless you explicitly state\n     * what signature it should have.\n     *\n     * When using TypeScript we recommend to declare type signature of function passed to\n     * `create` as `(observer: Observer) => TeardownLogic`, where {@link Observer}\n     * and {@link TeardownLogic} are interfaces provided by the library.\n     *\n     * @example <caption>Emit three numbers, then complete.</caption>\n     * var observable = Rx.Observable.create(function (observer) {\n     *   observer.next(1);\n     *   observer.next(2);\n     *   observer.next(3);\n     *   observer.complete();\n     * });\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('this is the end')\n     * );\n     *\n     * // Logs\n     * // 1\n     * // 2\n     * // 3\n     * // \"this is the end\"\n     *\n     *\n     * @example <caption>Emit an error</caption>\n     * const observable = Rx.Observable.create((observer) => {\n     *   observer.error('something went really wrong...');\n     * });\n     *\n     * observable.subscribe(\n     *   value => console.log(value), // will never be called\n     *   err => console.log(err),\n     *   () => console.log('complete') // will never be called\n     * );\n     *\n     * // Logs\n     * // \"something went really wrong...\"\n     *\n     *\n     * @example <caption>Return unsubscribe function</caption>\n     *\n     * const observable = Rx.Observable.create(observer => {\n     *   const id = setTimeout(() => observer.next('...'), 5000); // emit value after 5s\n     *\n     *   return () => { clearTimeout(id); console.log('cleared!'); };\n     * });\n     *\n     * const subscription = observable.subscribe(value => console.log(value));\n     *\n     * setTimeout(() => subscription.unsubscribe(), 3000); // cancel subscription after 3s\n     *\n     * // Logs:\n     * // \"cleared!\" after 3s\n     *\n     * // Never logs \"...\"\n     *\n     *\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @param {function(observer: Observer): TeardownLogic} onSubscription A\n     * function that accepts an Observer, and invokes its `next`,\n     * `error`, and `complete` methods as appropriate, and optionally returns some\n     * logic for cleaning up resources.\n     * @return {Observable} An Observable that, whenever subscribed, will execute the\n     * specified function.\n     * @static true\n     * @name create\n     * @owner Observable\n     ",
                  "range": [
                    240,
                    5485
                  ],
                  "loc": {
                    "start": {
                      "line": 10,
                      "column": 4
                    },
                    "end": {
                      "line": 128,
                      "column": 7
                    }
                  }
                }
              ],
              "static": true
            }
          ],
          "range": [
            234,
            5582
          ],
          "loc": {
            "start": {
              "line": 9,
              "column": 27
            },
            "end": {
              "line": 133,
              "column": 1
            }
          }
        },
        "range": [
          214,
          5582
        ],
        "loc": {
          "start": {
            "line": 9,
            "column": 7
          },
          "end": {
            "line": 133,
            "column": 1
          }
        },
        "leadingComments": [
          {
            "type": "Block",
            "value": "*\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n ",
            "range": [
              112,
              206
            ],
            "loc": {
              "start": {
                "line": 4,
                "column": 0
              },
              "end": {
                "line": 8,
                "column": 3
              }
            }
          }
        ],
        "trailingComments": [
          {
            "type": "Block",
            "value": "*\n * An interface for a consumer of push-based notifications delivered by an\n * {@link Observable}.\n *\n * ```ts\n * interface Observer<T> {\n *   closed?: boolean;\n *   next: (value: T) => void;\n *   error: (err: any) => void;\n *   complete: () => void;\n * }\n * ```\n *\n * An object conforming to the Observer interface is usually\n * given to the `observable.subscribe(observer)` method, and the Observable will\n * call the Observer's `next(value)` method to provide notifications. A\n * well-behaved Observable will call an Observer's `complete()` method exactly\n * once or the Observer's `error(err)` method exactly once, as the last\n * notification delivered.\n *\n * @interface\n * @name Observer\n * @noimport true\n ",
            "range": [
              5583,
              6300
            ],
            "loc": {
              "start": {
                "line": 134,
                "column": 0
              },
              "end": {
                "line": 157,
                "column": 3
              }
            }
          }
        ]
      },
      "specifiers": [],
      "source": null,
      "range": [
        207,
        5582
      ],
      "loc": {
        "start": {
          "line": 9,
          "column": 0
        },
        "end": {
          "line": 133,
          "column": 1
        }
      },
      "leadingComments": [
        {
          "type": "Block",
          "value": "*\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n ",
          "range": [
            112,
            206
          ],
          "loc": {
            "start": {
              "line": 4,
              "column": 0
            },
            "end": {
              "line": 8,
              "column": 3
            }
          }
        }
      ],
      "trailingComments": [
        {
          "type": "Block",
          "value": "*\n * An interface for a consumer of push-based notifications delivered by an\n * {@link Observable}.\n *\n * ```ts\n * interface Observer<T> {\n *   closed?: boolean;\n *   next: (value: T) => void;\n *   error: (err: any) => void;\n *   complete: () => void;\n * }\n * ```\n *\n * An object conforming to the Observer interface is usually\n * given to the `observable.subscribe(observer)` method, and the Observable will\n * call the Observer's `next(value)` method to provide notifications. A\n * well-behaved Observable will call an Observer's `complete()` method exactly\n * once or the Observer's `error(err)` method exactly once, as the last\n * notification delivered.\n *\n * @interface\n * @name Observer\n * @noimport true\n ",
          "range": [
            5583,
            6300
          ],
          "loc": {
            "start": {
              "line": 134,
              "column": 0
            },
            "end": {
              "line": 157,
              "column": 3
            }
          }
        }
      ]
    },
    {
      "type": "ExportNamedDeclaration",
      "declaration": {
        "type": "ClassDeclaration",
        "id": {
          "type": "Identifier",
          "name": "ObserverDoc",
          "range": [
            6314,
            6325
          ],
          "loc": {
            "start": {
              "line": 158,
              "column": 13
            },
            "end": {
              "line": 158,
              "column": 24
            }
          }
        },
        "superClass": null,
        "body": {
          "type": "ClassBody",
          "body": [
            {
              "type": "MethodDefinition",
              "key": {
                "type": "Identifier",
                "name": "constructor",
                "range": [
                  6332,
                  6343
                ],
                "loc": {
                  "start": {
                    "line": 159,
                    "column": 4
                  },
                  "end": {
                    "line": 159,
                    "column": 15
                  }
                }
              },
              "value": {
                "type": "FunctionExpression",
                "id": null,
                "params": [],
                "body": {
                  "type": "BlockStatement",
                  "body": [
                    {
                      "type": "ExpressionStatement",
                      "expression": {
                        "type": "AssignmentExpression",
                        "operator": "=",
                        "left": {
                          "type": "MemberExpression",
                          "computed": false,
                          "object": {
                            "type": "ThisExpression",
                            "range": [
                              6559,
                              6563
                            ],
                            "loc": {
                              "start": {
                                "line": 165,
                                "column": 8
                              },
                              "end": {
                                "line": 165,
                                "column": 12
                              }
                            }
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "closed",
                            "range": [
                              6564,
                              6570
                            ],
                            "loc": {
                              "start": {
                                "line": 165,
                                "column": 13
                              },
                              "end": {
                                "line": 165,
                                "column": 19
                              }
                            }
                          },
                          "range": [
                            6559,
                            6570
                          ],
                          "loc": {
                            "start": {
                              "line": 165,
                              "column": 8
                            },
                            "end": {
                              "line": 165,
                              "column": 19
                            }
                          }
                        },
                        "right": {
                          "type": "Literal",
                          "value": false,
                          "raw": "false",
                          "range": [
                            6573,
                            6578
                          ],
                          "loc": {
                            "start": {
                              "line": 165,
                              "column": 22
                            },
                            "end": {
                              "line": 165,
                              "column": 27
                            }
                          }
                        },
                        "range": [
                          6559,
                          6578
                        ],
                        "loc": {
                          "start": {
                            "line": 165,
                            "column": 8
                          },
                          "end": {
                            "line": 165,
                            "column": 27
                          }
                        }
                      },
                      "range": [
                        6559,
                        6579
                      ],
                      "loc": {
                        "start": {
                          "line": 165,
                          "column": 8
                        },
                        "end": {
                          "line": 165,
                          "column": 28
                        }
                      },
                      "leadingComments": [
                        {
                          "type": "Block",
                          "value": "*\n         * An optional flag to indicate whether this Observer, when used as a\n         * subscriber, has already been unsubscribed from its Observable.\n         * @type {boolean}\n         ",
                          "range": [
                            6356,
                            6550
                          ],
                          "loc": {
                            "start": {
                              "line": 160,
                              "column": 8
                            },
                            "end": {
                              "line": 164,
                              "column": 11
                            }
                          }
                        }
                      ]
                    }
                  ],
                  "range": [
                    6346,
                    6585
                  ],
                  "loc": {
                    "start": {
                      "line": 159,
                      "column": 18
                    },
                    "end": {
                      "line": 166,
                      "column": 5
                    }
                  }
                },
                "generator": false,
                "expression": false,
                "range": [
                  6343,
                  6585
                ],
                "loc": {
                  "start": {
                    "line": 159,
                    "column": 15
                  },
                  "end": {
                    "line": 166,
                    "column": 5
                  }
                }
              },
              "kind": "constructor",
              "computed": false,
              "range": [
                6332,
                6585
              ],
              "loc": {
                "start": {
                  "line": 159,
                  "column": 4
                },
                "end": {
                  "line": 166,
                  "column": 5
                }
              },
              "trailingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * The callback to receive notifications of type `next` from the Observable,\n     * with a value. The Observable may call this method 0 or more times.\n     * @param {T} value The `next` value.\n     * @return {void}\n     ",
                  "range": [
                    6590,
                    6820
                  ],
                  "loc": {
                    "start": {
                      "line": 167,
                      "column": 4
                    },
                    "end": {
                      "line": 172,
                      "column": 7
                    }
                  }
                }
              ],
              "static": false
            },
            {
              "type": "MethodDefinition",
              "key": {
                "type": "Identifier",
                "name": "next",
                "range": [
                  6825,
                  6829
                ],
                "loc": {
                  "start": {
                    "line": 173,
                    "column": 4
                  },
                  "end": {
                    "line": 173,
                    "column": 8
                  }
                }
              },
              "value": {
                "type": "FunctionExpression",
                "id": null,
                "params": [
                  {
                    "type": "Identifier",
                    "name": "value",
                    "range": [
                      6830,
                      6835
                    ],
                    "loc": {
                      "start": {
                        "line": 173,
                        "column": 9
                      },
                      "end": {
                        "line": 173,
                        "column": 14
                      }
                    }
                  }
                ],
                "body": {
                  "type": "BlockStatement",
                  "body": [
                    {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "UnaryExpression",
                        "operator": "void",
                        "argument": {
                          "type": "Literal",
                          "value": 0,
                          "raw": "0",
                          "range": [
                            6859,
                            6860
                          ],
                          "loc": {
                            "start": {
                              "line": 174,
                              "column": 20
                            },
                            "end": {
                              "line": 174,
                              "column": 21
                            }
                          }
                        },
                        "prefix": true,
                        "range": [
                          6854,
                          6860
                        ],
                        "loc": {
                          "start": {
                            "line": 174,
                            "column": 15
                          },
                          "end": {
                            "line": 174,
                            "column": 21
                          }
                        }
                      },
                      "range": [
                        6847,
                        6861
                      ],
                      "loc": {
                        "start": {
                          "line": 174,
                          "column": 8
                        },
                        "end": {
                          "line": 174,
                          "column": 22
                        }
                      }
                    }
                  ],
                  "range": [
                    6837,
                    6867
                  ],
                  "loc": {
                    "start": {
                      "line": 173,
                      "column": 16
                    },
                    "end": {
                      "line": 175,
                      "column": 5
                    }
                  }
                },
                "generator": false,
                "expression": false,
                "range": [
                  6829,
                  6867
                ],
                "loc": {
                  "start": {
                    "line": 173,
                    "column": 8
                  },
                  "end": {
                    "line": 175,
                    "column": 5
                  }
                }
              },
              "kind": "method",
              "computed": false,
              "range": [
                6825,
                6867
              ],
              "loc": {
                "start": {
                  "line": 173,
                  "column": 4
                },
                "end": {
                  "line": 175,
                  "column": 5
                }
              },
              "leadingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * The callback to receive notifications of type `next` from the Observable,\n     * with a value. The Observable may call this method 0 or more times.\n     * @param {T} value The `next` value.\n     * @return {void}\n     ",
                  "range": [
                    6590,
                    6820
                  ],
                  "loc": {
                    "start": {
                      "line": 167,
                      "column": 4
                    },
                    "end": {
                      "line": 172,
                      "column": 7
                    }
                  }
                }
              ],
              "trailingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * The callback to receive notifications of type `error` from the Observable,\n     * with an attached {@link Error}. Notifies the Observer that the Observable\n     * has experienced an error condition.\n     * @param {any} err The `error` exception.\n     * @return {void}\n     ",
                  "range": [
                    6872,
                    7158
                  ],
                  "loc": {
                    "start": {
                      "line": 176,
                      "column": 4
                    },
                    "end": {
                      "line": 182,
                      "column": 7
                    }
                  }
                }
              ],
              "static": false
            },
            {
              "type": "MethodDefinition",
              "key": {
                "type": "Identifier",
                "name": "error",
                "range": [
                  7163,
                  7168
                ],
                "loc": {
                  "start": {
                    "line": 183,
                    "column": 4
                  },
                  "end": {
                    "line": 183,
                    "column": 9
                  }
                }
              },
              "value": {
                "type": "FunctionExpression",
                "id": null,
                "params": [
                  {
                    "type": "Identifier",
                    "name": "err",
                    "range": [
                      7169,
                      7172
                    ],
                    "loc": {
                      "start": {
                        "line": 183,
                        "column": 10
                      },
                      "end": {
                        "line": 183,
                        "column": 13
                      }
                    }
                  }
                ],
                "body": {
                  "type": "BlockStatement",
                  "body": [
                    {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "UnaryExpression",
                        "operator": "void",
                        "argument": {
                          "type": "Literal",
                          "value": 0,
                          "raw": "0",
                          "range": [
                            7196,
                            7197
                          ],
                          "loc": {
                            "start": {
                              "line": 184,
                              "column": 20
                            },
                            "end": {
                              "line": 184,
                              "column": 21
                            }
                          }
                        },
                        "prefix": true,
                        "range": [
                          7191,
                          7197
                        ],
                        "loc": {
                          "start": {
                            "line": 184,
                            "column": 15
                          },
                          "end": {
                            "line": 184,
                            "column": 21
                          }
                        }
                      },
                      "range": [
                        7184,
                        7198
                      ],
                      "loc": {
                        "start": {
                          "line": 184,
                          "column": 8
                        },
                        "end": {
                          "line": 184,
                          "column": 22
                        }
                      }
                    }
                  ],
                  "range": [
                    7174,
                    7204
                  ],
                  "loc": {
                    "start": {
                      "line": 183,
                      "column": 15
                    },
                    "end": {
                      "line": 185,
                      "column": 5
                    }
                  }
                },
                "generator": false,
                "expression": false,
                "range": [
                  7168,
                  7204
                ],
                "loc": {
                  "start": {
                    "line": 183,
                    "column": 9
                  },
                  "end": {
                    "line": 185,
                    "column": 5
                  }
                }
              },
              "kind": "method",
              "computed": false,
              "range": [
                7163,
                7204
              ],
              "loc": {
                "start": {
                  "line": 183,
                  "column": 4
                },
                "end": {
                  "line": 185,
                  "column": 5
                }
              },
              "leadingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * The callback to receive notifications of type `error` from the Observable,\n     * with an attached {@link Error}. Notifies the Observer that the Observable\n     * has experienced an error condition.\n     * @param {any} err The `error` exception.\n     * @return {void}\n     ",
                  "range": [
                    6872,
                    7158
                  ],
                  "loc": {
                    "start": {
                      "line": 176,
                      "column": 4
                    },
                    "end": {
                      "line": 182,
                      "column": 7
                    }
                  }
                }
              ],
              "trailingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * The callback to receive a valueless notification of type `complete` from\n     * the Observable. Notifies the Observer that the Observable has finished\n     * sending push-based notifications.\n     * @return {void}\n     ",
                  "range": [
                    7209,
                    7441
                  ],
                  "loc": {
                    "start": {
                      "line": 186,
                      "column": 4
                    },
                    "end": {
                      "line": 191,
                      "column": 7
                    }
                  }
                }
              ],
              "static": false
            },
            {
              "type": "MethodDefinition",
              "key": {
                "type": "Identifier",
                "name": "complete",
                "range": [
                  7446,
                  7454
                ],
                "loc": {
                  "start": {
                    "line": 192,
                    "column": 4
                  },
                  "end": {
                    "line": 192,
                    "column": 12
                  }
                }
              },
              "value": {
                "type": "FunctionExpression",
                "id": null,
                "params": [],
                "body": {
                  "type": "BlockStatement",
                  "body": [
                    {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "UnaryExpression",
                        "operator": "void",
                        "argument": {
                          "type": "Literal",
                          "value": 0,
                          "raw": "0",
                          "range": [
                            7479,
                            7480
                          ],
                          "loc": {
                            "start": {
                              "line": 193,
                              "column": 20
                            },
                            "end": {
                              "line": 193,
                              "column": 21
                            }
                          }
                        },
                        "prefix": true,
                        "range": [
                          7474,
                          7480
                        ],
                        "loc": {
                          "start": {
                            "line": 193,
                            "column": 15
                          },
                          "end": {
                            "line": 193,
                            "column": 21
                          }
                        }
                      },
                      "range": [
                        7467,
                        7481
                      ],
                      "loc": {
                        "start": {
                          "line": 193,
                          "column": 8
                        },
                        "end": {
                          "line": 193,
                          "column": 22
                        }
                      }
                    }
                  ],
                  "range": [
                    7457,
                    7487
                  ],
                  "loc": {
                    "start": {
                      "line": 192,
                      "column": 15
                    },
                    "end": {
                      "line": 194,
                      "column": 5
                    }
                  }
                },
                "generator": false,
                "expression": false,
                "range": [
                  7454,
                  7487
                ],
                "loc": {
                  "start": {
                    "line": 192,
                    "column": 12
                  },
                  "end": {
                    "line": 194,
                    "column": 5
                  }
                }
              },
              "kind": "method",
              "computed": false,
              "range": [
                7446,
                7487
              ],
              "loc": {
                "start": {
                  "line": 192,
                  "column": 4
                },
                "end": {
                  "line": 194,
                  "column": 5
                }
              },
              "leadingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * The callback to receive a valueless notification of type `complete` from\n     * the Observable. Notifies the Observer that the Observable has finished\n     * sending push-based notifications.\n     * @return {void}\n     ",
                  "range": [
                    7209,
                    7441
                  ],
                  "loc": {
                    "start": {
                      "line": 186,
                      "column": 4
                    },
                    "end": {
                      "line": 191,
                      "column": 7
                    }
                  }
                }
              ],
              "static": false
            }
          ],
          "range": [
            6326,
            7489
          ],
          "loc": {
            "start": {
              "line": 158,
              "column": 25
            },
            "end": {
              "line": 195,
              "column": 1
            }
          }
        },
        "range": [
          6308,
          7489
        ],
        "loc": {
          "start": {
            "line": 158,
            "column": 7
          },
          "end": {
            "line": 195,
            "column": 1
          }
        },
        "leadingComments": [
          {
            "type": "Block",
            "value": "*\n * An interface for a consumer of push-based notifications delivered by an\n * {@link Observable}.\n *\n * ```ts\n * interface Observer<T> {\n *   closed?: boolean;\n *   next: (value: T) => void;\n *   error: (err: any) => void;\n *   complete: () => void;\n * }\n * ```\n *\n * An object conforming to the Observer interface is usually\n * given to the `observable.subscribe(observer)` method, and the Observable will\n * call the Observer's `next(value)` method to provide notifications. A\n * well-behaved Observable will call an Observer's `complete()` method exactly\n * once or the Observer's `error(err)` method exactly once, as the last\n * notification delivered.\n *\n * @interface\n * @name Observer\n * @noimport true\n ",
            "range": [
              5583,
              6300
            ],
            "loc": {
              "start": {
                "line": 134,
                "column": 0
              },
              "end": {
                "line": 157,
                "column": 3
              }
            }
          }
        ],
        "trailingComments": [
          {
            "type": "Block",
            "value": "*\n * `SubscribableOrPromise` interface describes values that behave like either\n * Observables or Promises. Every operator that accepts arguments annotated\n * with this interface, can be also used with parameters that are not necessarily\n * RxJS Observables.\n *\n * Following types of values might be passed to operators expecting this interface:\n *\n * ## Observable\n *\n * RxJS {@link Observable} instance.\n *\n * ## Observable-like (Subscribable)\n *\n * This might be any object that has `Symbol.observable` method. This method,\n * when called, should return object with `subscribe` method on it, which should\n * behave the same as RxJS `Observable.subscribe`.\n *\n * `Symbol.observable` is part of https://github.com/tc39/proposal-observable proposal.\n * Since currently it is not supported natively, and every symbol is equal only to itself,\n * you should use https://github.com/blesh/symbol-observable polyfill, when implementing\n * custom Observable-likes.\n *\n * **TypeScript Subscribable interface issue**\n *\n * Although TypeScript interface claims that Subscribable is an object that has `subscribe`\n * method declared directly on it, passing custom objects that have `subscribe`\n * method but not `Symbol.observable` method will fail at runtime. Conversely, passing\n * objects with `Symbol.observable` but without `subscribe` will fail at compile time\n * (if you use TypeScript).\n *\n * TypeScript has problem supporting interfaces with methods defined as symbol\n * properties. To get around that, you should implement `subscribe` directly on\n * passed object, and make `Symbol.observable` method simply return `this`. That way\n * everything will work as expected, and compiler will not complain. If you really\n * do not want to put `subscribe` directly on your object, you will have to type cast\n * it to `any`, before passing it to an operator.\n *\n * When this issue is resolved, Subscribable interface will only permit Observable-like\n * objects with `Symbol.observable` defined, no matter if they themselves implement\n * `subscribe` method or not.\n *\n * ## ES6 Promise\n *\n * Promise can be interpreted as Observable that emits value and completes\n * when it is resolved or errors when it is rejected.\n *\n * ## Promise-like (Thenable)\n *\n * Promises passed to operators do not have to be native ES6 Promises.\n * They can be implementations from popular Promise libraries, polyfills\n * or even custom ones. They just need to have `then` method that works\n * as the same as ES6 Promise `then`.\n *\n * @example <caption>Use merge and then map with non-RxJS observable</caption>\n * const nonRxJSObservable = {\n *   subscribe(observer) {\n *     observer.next(1000);\n *     observer.complete();\n *   },\n *   [Symbol.observable]() {\n *     return this;\n *   }\n * };\n *\n * Rx.Observable.merge(nonRxJSObservable)\n * .map(value => \"This value is \" + value)\n * .subscribe(result => console.log(result)); // Logs \"This value is 1000\"\n *\n *\n * @example <caption>Use combineLatest with ES6 Promise</caption>\n * Rx.Observable.combineLatest(Promise.resolve(5), Promise.resolve(10), Promise.resolve(15))\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n * // Logs\n * // [5, 10, 15]\n * // \"the end!\"\n *\n *\n * @interface\n * @name SubscribableOrPromise\n * @noimport true\n ",
            "range": [
              7490,
              10808
            ],
            "loc": {
              "start": {
                "line": 196,
                "column": 0
              },
              "end": {
                "line": 281,
                "column": 3
              }
            }
          }
        ]
      },
      "specifiers": [],
      "source": null,
      "range": [
        6301,
        7489
      ],
      "loc": {
        "start": {
          "line": 158,
          "column": 0
        },
        "end": {
          "line": 195,
          "column": 1
        }
      },
      "leadingComments": [
        {
          "type": "Block",
          "value": "*\n * An interface for a consumer of push-based notifications delivered by an\n * {@link Observable}.\n *\n * ```ts\n * interface Observer<T> {\n *   closed?: boolean;\n *   next: (value: T) => void;\n *   error: (err: any) => void;\n *   complete: () => void;\n * }\n * ```\n *\n * An object conforming to the Observer interface is usually\n * given to the `observable.subscribe(observer)` method, and the Observable will\n * call the Observer's `next(value)` method to provide notifications. A\n * well-behaved Observable will call an Observer's `complete()` method exactly\n * once or the Observer's `error(err)` method exactly once, as the last\n * notification delivered.\n *\n * @interface\n * @name Observer\n * @noimport true\n ",
          "range": [
            5583,
            6300
          ],
          "loc": {
            "start": {
              "line": 134,
              "column": 0
            },
            "end": {
              "line": 157,
              "column": 3
            }
          }
        }
      ],
      "trailingComments": [
        {
          "type": "Block",
          "value": "*\n * `SubscribableOrPromise` interface describes values that behave like either\n * Observables or Promises. Every operator that accepts arguments annotated\n * with this interface, can be also used with parameters that are not necessarily\n * RxJS Observables.\n *\n * Following types of values might be passed to operators expecting this interface:\n *\n * ## Observable\n *\n * RxJS {@link Observable} instance.\n *\n * ## Observable-like (Subscribable)\n *\n * This might be any object that has `Symbol.observable` method. This method,\n * when called, should return object with `subscribe` method on it, which should\n * behave the same as RxJS `Observable.subscribe`.\n *\n * `Symbol.observable` is part of https://github.com/tc39/proposal-observable proposal.\n * Since currently it is not supported natively, and every symbol is equal only to itself,\n * you should use https://github.com/blesh/symbol-observable polyfill, when implementing\n * custom Observable-likes.\n *\n * **TypeScript Subscribable interface issue**\n *\n * Although TypeScript interface claims that Subscribable is an object that has `subscribe`\n * method declared directly on it, passing custom objects that have `subscribe`\n * method but not `Symbol.observable` method will fail at runtime. Conversely, passing\n * objects with `Symbol.observable` but without `subscribe` will fail at compile time\n * (if you use TypeScript).\n *\n * TypeScript has problem supporting interfaces with methods defined as symbol\n * properties. To get around that, you should implement `subscribe` directly on\n * passed object, and make `Symbol.observable` method simply return `this`. That way\n * everything will work as expected, and compiler will not complain. If you really\n * do not want to put `subscribe` directly on your object, you will have to type cast\n * it to `any`, before passing it to an operator.\n *\n * When this issue is resolved, Subscribable interface will only permit Observable-like\n * objects with `Symbol.observable` defined, no matter if they themselves implement\n * `subscribe` method or not.\n *\n * ## ES6 Promise\n *\n * Promise can be interpreted as Observable that emits value and completes\n * when it is resolved or errors when it is rejected.\n *\n * ## Promise-like (Thenable)\n *\n * Promises passed to operators do not have to be native ES6 Promises.\n * They can be implementations from popular Promise libraries, polyfills\n * or even custom ones. They just need to have `then` method that works\n * as the same as ES6 Promise `then`.\n *\n * @example <caption>Use merge and then map with non-RxJS observable</caption>\n * const nonRxJSObservable = {\n *   subscribe(observer) {\n *     observer.next(1000);\n *     observer.complete();\n *   },\n *   [Symbol.observable]() {\n *     return this;\n *   }\n * };\n *\n * Rx.Observable.merge(nonRxJSObservable)\n * .map(value => \"This value is \" + value)\n * .subscribe(result => console.log(result)); // Logs \"This value is 1000\"\n *\n *\n * @example <caption>Use combineLatest with ES6 Promise</caption>\n * Rx.Observable.combineLatest(Promise.resolve(5), Promise.resolve(10), Promise.resolve(15))\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n * // Logs\n * // [5, 10, 15]\n * // \"the end!\"\n *\n *\n * @interface\n * @name SubscribableOrPromise\n * @noimport true\n ",
          "range": [
            7490,
            10808
          ],
          "loc": {
            "start": {
              "line": 196,
              "column": 0
            },
            "end": {
              "line": 281,
              "column": 3
            }
          }
        }
      ]
    },
    {
      "type": "ExportNamedDeclaration",
      "declaration": {
        "type": "ClassDeclaration",
        "id": {
          "type": "Identifier",
          "name": "SubscribableOrPromiseDoc",
          "range": [
            10822,
            10846
          ],
          "loc": {
            "start": {
              "line": 282,
              "column": 13
            },
            "end": {
              "line": 282,
              "column": 37
            }
          }
        },
        "superClass": null,
        "body": {
          "type": "ClassBody",
          "body": [],
          "range": [
            10847,
            10850
          ],
          "loc": {
            "start": {
              "line": 282,
              "column": 38
            },
            "end": {
              "line": 283,
              "column": 1
            }
          }
        },
        "range": [
          10816,
          10850
        ],
        "loc": {
          "start": {
            "line": 282,
            "column": 7
          },
          "end": {
            "line": 283,
            "column": 1
          }
        },
        "leadingComments": [
          {
            "type": "Block",
            "value": "*\n * `SubscribableOrPromise` interface describes values that behave like either\n * Observables or Promises. Every operator that accepts arguments annotated\n * with this interface, can be also used with parameters that are not necessarily\n * RxJS Observables.\n *\n * Following types of values might be passed to operators expecting this interface:\n *\n * ## Observable\n *\n * RxJS {@link Observable} instance.\n *\n * ## Observable-like (Subscribable)\n *\n * This might be any object that has `Symbol.observable` method. This method,\n * when called, should return object with `subscribe` method on it, which should\n * behave the same as RxJS `Observable.subscribe`.\n *\n * `Symbol.observable` is part of https://github.com/tc39/proposal-observable proposal.\n * Since currently it is not supported natively, and every symbol is equal only to itself,\n * you should use https://github.com/blesh/symbol-observable polyfill, when implementing\n * custom Observable-likes.\n *\n * **TypeScript Subscribable interface issue**\n *\n * Although TypeScript interface claims that Subscribable is an object that has `subscribe`\n * method declared directly on it, passing custom objects that have `subscribe`\n * method but not `Symbol.observable` method will fail at runtime. Conversely, passing\n * objects with `Symbol.observable` but without `subscribe` will fail at compile time\n * (if you use TypeScript).\n *\n * TypeScript has problem supporting interfaces with methods defined as symbol\n * properties. To get around that, you should implement `subscribe` directly on\n * passed object, and make `Symbol.observable` method simply return `this`. That way\n * everything will work as expected, and compiler will not complain. If you really\n * do not want to put `subscribe` directly on your object, you will have to type cast\n * it to `any`, before passing it to an operator.\n *\n * When this issue is resolved, Subscribable interface will only permit Observable-like\n * objects with `Symbol.observable` defined, no matter if they themselves implement\n * `subscribe` method or not.\n *\n * ## ES6 Promise\n *\n * Promise can be interpreted as Observable that emits value and completes\n * when it is resolved or errors when it is rejected.\n *\n * ## Promise-like (Thenable)\n *\n * Promises passed to operators do not have to be native ES6 Promises.\n * They can be implementations from popular Promise libraries, polyfills\n * or even custom ones. They just need to have `then` method that works\n * as the same as ES6 Promise `then`.\n *\n * @example <caption>Use merge and then map with non-RxJS observable</caption>\n * const nonRxJSObservable = {\n *   subscribe(observer) {\n *     observer.next(1000);\n *     observer.complete();\n *   },\n *   [Symbol.observable]() {\n *     return this;\n *   }\n * };\n *\n * Rx.Observable.merge(nonRxJSObservable)\n * .map(value => \"This value is \" + value)\n * .subscribe(result => console.log(result)); // Logs \"This value is 1000\"\n *\n *\n * @example <caption>Use combineLatest with ES6 Promise</caption>\n * Rx.Observable.combineLatest(Promise.resolve(5), Promise.resolve(10), Promise.resolve(15))\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n * // Logs\n * // [5, 10, 15]\n * // \"the end!\"\n *\n *\n * @interface\n * @name SubscribableOrPromise\n * @noimport true\n ",
            "range": [
              7490,
              10808
            ],
            "loc": {
              "start": {
                "line": 196,
                "column": 0
              },
              "end": {
                "line": 281,
                "column": 3
              }
            }
          }
        ],
        "trailingComments": [
          {
            "type": "Block",
            "value": "*\n * `ObservableInput` interface describes all values that are either an\n * {@link SubscribableOrPromise} or some kind of collection of values that\n * can be transformed to Observable emitting that values. Every operator that\n * accepts arguments annotated with this interface, can be also used with\n * parameters that are not necessarily RxJS Observables.\n *\n * `ObservableInput` extends {@link SubscribableOrPromise} with following types:\n *\n * ## Array\n *\n * Arrays can be interpreted as observables that emit all values in array one by one,\n * from left to right, and then complete immediately.\n *\n * ## Array-like\n *\n * Arrays passed to operators do not have to be built-in JavaScript Arrays. They\n * can be also, for example, `arguments` property available inside every function,\n * [DOM NodeList](https://developer.mozilla.org/pl/docs/Web/API/NodeList),\n * or, actually, any object that has `length` property (which is a number)\n * and stores values under non-negative (zero and up) integers.\n *\n * ## ES6 Iterable\n *\n * Operators will accept both built-in and custom ES6 Iterables, by treating them as\n * observables that emit all its values in order of iteration and then complete\n * when iteration ends. Note that contrary to arrays, Iterables do not have to\n * necessarily be finite, so creating Observables that never complete is possible as well.\n *\n * Note that you can make iterator an instance of Iterable by having it return itself\n * in `Symbol.iterator` method. It means that every operator accepting Iterables accepts,\n * though indirectly, iterators themselves as well. All native ES6 iterators are instances\n * of Iterable by default, so you do not have to implement their `Symbol.iterator` method\n * yourself.\n *\n * **TypeScript Iterable interface issue**\n *\n * TypeScript `ObservableInput` interface actually lacks type signature for Iterables,\n * because of issues it caused in some projects (see [this issue](https://github.com/ReactiveX/rxjs/issues/2306)).\n * If you want to use Iterable as argument for operator, cast it to `any` first.\n * Remember of course that, because of casting, you have to yourself ensure that passed\n * argument really implements said interface.\n *\n *\n * @example <caption>Use merge with arrays</caption>\n * Rx.Observable.merge([1, 2], [4], [5, 6])\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * // \"ta dam!\"\n *\n *\n * @example <caption>Use merge with array-like</caption>\n * Rx.Observable.merge({0: 1, 1: 2, length: 2}, {0: 3, length: 1})\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('nice, huh?')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // \"nice, huh?\"\n *\n * @example <caption>Use merge with an Iterable (Map)</caption>\n * const firstMap = new Map([[1, 'a'], [2, 'b']]);\n * const secondMap = new Map([[3, 'c'], [4, 'd']]);\n *\n * Rx.Observable.merge(\n *   firstMap,          // pass Iterable\n *   secondMap.values() // pass iterator, which is itself an Iterable\n * ).subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('yup!')\n * );\n *\n * // Logs\n * // [1, \"a\"]\n * // [2, \"b\"]\n * // \"c\"\n * // \"d\"\n * // \"yup!\"\n *\n * @example <caption>Use from with generator (returning infinite iterator)</caption>\n * // infinite stream of incrementing numbers\n * const infinite = function* () {\n *   let i = 0;\n *\n *   while (true) {\n *     yield i++;\n *   }\n * };\n *\n * Rx.Observable.from(infinite())\n * .take(3) // only take 3, cause this is infinite\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 0\n * // 1\n * // 2\n * // \"ta dam!\"\n *\n * @interface\n * @name ObservableInput\n * @noimport true\n ",
            "range": [
              10851,
              14670
            ],
            "loc": {
              "start": {
                "line": 284,
                "column": 0
              },
              "end": {
                "line": 407,
                "column": 3
              }
            }
          }
        ]
      },
      "specifiers": [],
      "source": null,
      "range": [
        10809,
        10850
      ],
      "loc": {
        "start": {
          "line": 282,
          "column": 0
        },
        "end": {
          "line": 283,
          "column": 1
        }
      },
      "leadingComments": [
        {
          "type": "Block",
          "value": "*\n * `SubscribableOrPromise` interface describes values that behave like either\n * Observables or Promises. Every operator that accepts arguments annotated\n * with this interface, can be also used with parameters that are not necessarily\n * RxJS Observables.\n *\n * Following types of values might be passed to operators expecting this interface:\n *\n * ## Observable\n *\n * RxJS {@link Observable} instance.\n *\n * ## Observable-like (Subscribable)\n *\n * This might be any object that has `Symbol.observable` method. This method,\n * when called, should return object with `subscribe` method on it, which should\n * behave the same as RxJS `Observable.subscribe`.\n *\n * `Symbol.observable` is part of https://github.com/tc39/proposal-observable proposal.\n * Since currently it is not supported natively, and every symbol is equal only to itself,\n * you should use https://github.com/blesh/symbol-observable polyfill, when implementing\n * custom Observable-likes.\n *\n * **TypeScript Subscribable interface issue**\n *\n * Although TypeScript interface claims that Subscribable is an object that has `subscribe`\n * method declared directly on it, passing custom objects that have `subscribe`\n * method but not `Symbol.observable` method will fail at runtime. Conversely, passing\n * objects with `Symbol.observable` but without `subscribe` will fail at compile time\n * (if you use TypeScript).\n *\n * TypeScript has problem supporting interfaces with methods defined as symbol\n * properties. To get around that, you should implement `subscribe` directly on\n * passed object, and make `Symbol.observable` method simply return `this`. That way\n * everything will work as expected, and compiler will not complain. If you really\n * do not want to put `subscribe` directly on your object, you will have to type cast\n * it to `any`, before passing it to an operator.\n *\n * When this issue is resolved, Subscribable interface will only permit Observable-like\n * objects with `Symbol.observable` defined, no matter if they themselves implement\n * `subscribe` method or not.\n *\n * ## ES6 Promise\n *\n * Promise can be interpreted as Observable that emits value and completes\n * when it is resolved or errors when it is rejected.\n *\n * ## Promise-like (Thenable)\n *\n * Promises passed to operators do not have to be native ES6 Promises.\n * They can be implementations from popular Promise libraries, polyfills\n * or even custom ones. They just need to have `then` method that works\n * as the same as ES6 Promise `then`.\n *\n * @example <caption>Use merge and then map with non-RxJS observable</caption>\n * const nonRxJSObservable = {\n *   subscribe(observer) {\n *     observer.next(1000);\n *     observer.complete();\n *   },\n *   [Symbol.observable]() {\n *     return this;\n *   }\n * };\n *\n * Rx.Observable.merge(nonRxJSObservable)\n * .map(value => \"This value is \" + value)\n * .subscribe(result => console.log(result)); // Logs \"This value is 1000\"\n *\n *\n * @example <caption>Use combineLatest with ES6 Promise</caption>\n * Rx.Observable.combineLatest(Promise.resolve(5), Promise.resolve(10), Promise.resolve(15))\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n * // Logs\n * // [5, 10, 15]\n * // \"the end!\"\n *\n *\n * @interface\n * @name SubscribableOrPromise\n * @noimport true\n ",
          "range": [
            7490,
            10808
          ],
          "loc": {
            "start": {
              "line": 196,
              "column": 0
            },
            "end": {
              "line": 281,
              "column": 3
            }
          }
        }
      ],
      "trailingComments": [
        {
          "type": "Block",
          "value": "*\n * `ObservableInput` interface describes all values that are either an\n * {@link SubscribableOrPromise} or some kind of collection of values that\n * can be transformed to Observable emitting that values. Every operator that\n * accepts arguments annotated with this interface, can be also used with\n * parameters that are not necessarily RxJS Observables.\n *\n * `ObservableInput` extends {@link SubscribableOrPromise} with following types:\n *\n * ## Array\n *\n * Arrays can be interpreted as observables that emit all values in array one by one,\n * from left to right, and then complete immediately.\n *\n * ## Array-like\n *\n * Arrays passed to operators do not have to be built-in JavaScript Arrays. They\n * can be also, for example, `arguments` property available inside every function,\n * [DOM NodeList](https://developer.mozilla.org/pl/docs/Web/API/NodeList),\n * or, actually, any object that has `length` property (which is a number)\n * and stores values under non-negative (zero and up) integers.\n *\n * ## ES6 Iterable\n *\n * Operators will accept both built-in and custom ES6 Iterables, by treating them as\n * observables that emit all its values in order of iteration and then complete\n * when iteration ends. Note that contrary to arrays, Iterables do not have to\n * necessarily be finite, so creating Observables that never complete is possible as well.\n *\n * Note that you can make iterator an instance of Iterable by having it return itself\n * in `Symbol.iterator` method. It means that every operator accepting Iterables accepts,\n * though indirectly, iterators themselves as well. All native ES6 iterators are instances\n * of Iterable by default, so you do not have to implement their `Symbol.iterator` method\n * yourself.\n *\n * **TypeScript Iterable interface issue**\n *\n * TypeScript `ObservableInput` interface actually lacks type signature for Iterables,\n * because of issues it caused in some projects (see [this issue](https://github.com/ReactiveX/rxjs/issues/2306)).\n * If you want to use Iterable as argument for operator, cast it to `any` first.\n * Remember of course that, because of casting, you have to yourself ensure that passed\n * argument really implements said interface.\n *\n *\n * @example <caption>Use merge with arrays</caption>\n * Rx.Observable.merge([1, 2], [4], [5, 6])\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * // \"ta dam!\"\n *\n *\n * @example <caption>Use merge with array-like</caption>\n * Rx.Observable.merge({0: 1, 1: 2, length: 2}, {0: 3, length: 1})\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('nice, huh?')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // \"nice, huh?\"\n *\n * @example <caption>Use merge with an Iterable (Map)</caption>\n * const firstMap = new Map([[1, 'a'], [2, 'b']]);\n * const secondMap = new Map([[3, 'c'], [4, 'd']]);\n *\n * Rx.Observable.merge(\n *   firstMap,          // pass Iterable\n *   secondMap.values() // pass iterator, which is itself an Iterable\n * ).subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('yup!')\n * );\n *\n * // Logs\n * // [1, \"a\"]\n * // [2, \"b\"]\n * // \"c\"\n * // \"d\"\n * // \"yup!\"\n *\n * @example <caption>Use from with generator (returning infinite iterator)</caption>\n * // infinite stream of incrementing numbers\n * const infinite = function* () {\n *   let i = 0;\n *\n *   while (true) {\n *     yield i++;\n *   }\n * };\n *\n * Rx.Observable.from(infinite())\n * .take(3) // only take 3, cause this is infinite\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 0\n * // 1\n * // 2\n * // \"ta dam!\"\n *\n * @interface\n * @name ObservableInput\n * @noimport true\n ",
          "range": [
            10851,
            14670
          ],
          "loc": {
            "start": {
              "line": 284,
              "column": 0
            },
            "end": {
              "line": 407,
              "column": 3
            }
          }
        }
      ]
    },
    {
      "type": "ExportNamedDeclaration",
      "declaration": {
        "type": "ClassDeclaration",
        "id": {
          "type": "Identifier",
          "name": "ObservableInputDoc",
          "range": [
            14684,
            14702
          ],
          "loc": {
            "start": {
              "line": 408,
              "column": 13
            },
            "end": {
              "line": 408,
              "column": 31
            }
          }
        },
        "superClass": null,
        "body": {
          "type": "ClassBody",
          "body": [],
          "range": [
            14703,
            14706
          ],
          "loc": {
            "start": {
              "line": 408,
              "column": 32
            },
            "end": {
              "line": 409,
              "column": 1
            }
          }
        },
        "range": [
          14678,
          14706
        ],
        "loc": {
          "start": {
            "line": 408,
            "column": 7
          },
          "end": {
            "line": 409,
            "column": 1
          }
        },
        "leadingComments": [
          {
            "type": "Block",
            "value": "*\n * `ObservableInput` interface describes all values that are either an\n * {@link SubscribableOrPromise} or some kind of collection of values that\n * can be transformed to Observable emitting that values. Every operator that\n * accepts arguments annotated with this interface, can be also used with\n * parameters that are not necessarily RxJS Observables.\n *\n * `ObservableInput` extends {@link SubscribableOrPromise} with following types:\n *\n * ## Array\n *\n * Arrays can be interpreted as observables that emit all values in array one by one,\n * from left to right, and then complete immediately.\n *\n * ## Array-like\n *\n * Arrays passed to operators do not have to be built-in JavaScript Arrays. They\n * can be also, for example, `arguments` property available inside every function,\n * [DOM NodeList](https://developer.mozilla.org/pl/docs/Web/API/NodeList),\n * or, actually, any object that has `length` property (which is a number)\n * and stores values under non-negative (zero and up) integers.\n *\n * ## ES6 Iterable\n *\n * Operators will accept both built-in and custom ES6 Iterables, by treating them as\n * observables that emit all its values in order of iteration and then complete\n * when iteration ends. Note that contrary to arrays, Iterables do not have to\n * necessarily be finite, so creating Observables that never complete is possible as well.\n *\n * Note that you can make iterator an instance of Iterable by having it return itself\n * in `Symbol.iterator` method. It means that every operator accepting Iterables accepts,\n * though indirectly, iterators themselves as well. All native ES6 iterators are instances\n * of Iterable by default, so you do not have to implement their `Symbol.iterator` method\n * yourself.\n *\n * **TypeScript Iterable interface issue**\n *\n * TypeScript `ObservableInput` interface actually lacks type signature for Iterables,\n * because of issues it caused in some projects (see [this issue](https://github.com/ReactiveX/rxjs/issues/2306)).\n * If you want to use Iterable as argument for operator, cast it to `any` first.\n * Remember of course that, because of casting, you have to yourself ensure that passed\n * argument really implements said interface.\n *\n *\n * @example <caption>Use merge with arrays</caption>\n * Rx.Observable.merge([1, 2], [4], [5, 6])\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * // \"ta dam!\"\n *\n *\n * @example <caption>Use merge with array-like</caption>\n * Rx.Observable.merge({0: 1, 1: 2, length: 2}, {0: 3, length: 1})\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('nice, huh?')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // \"nice, huh?\"\n *\n * @example <caption>Use merge with an Iterable (Map)</caption>\n * const firstMap = new Map([[1, 'a'], [2, 'b']]);\n * const secondMap = new Map([[3, 'c'], [4, 'd']]);\n *\n * Rx.Observable.merge(\n *   firstMap,          // pass Iterable\n *   secondMap.values() // pass iterator, which is itself an Iterable\n * ).subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('yup!')\n * );\n *\n * // Logs\n * // [1, \"a\"]\n * // [2, \"b\"]\n * // \"c\"\n * // \"d\"\n * // \"yup!\"\n *\n * @example <caption>Use from with generator (returning infinite iterator)</caption>\n * // infinite stream of incrementing numbers\n * const infinite = function* () {\n *   let i = 0;\n *\n *   while (true) {\n *     yield i++;\n *   }\n * };\n *\n * Rx.Observable.from(infinite())\n * .take(3) // only take 3, cause this is infinite\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 0\n * // 1\n * // 2\n * // \"ta dam!\"\n *\n * @interface\n * @name ObservableInput\n * @noimport true\n ",
            "range": [
              10851,
              14670
            ],
            "loc": {
              "start": {
                "line": 284,
                "column": 0
              },
              "end": {
                "line": 407,
                "column": 3
              }
            }
          }
        ],
        "trailingComments": [
          {
            "type": "Block",
            "value": "*\n *\n * This interface describes what should be returned by function passed to Observable\n * constructor or static {@link create} function. Value of that interface will be used\n * to cancel subscription for given Observable.\n *\n * `TeardownLogic` can be:\n *\n * ## Function\n *\n * Function that takes no parameters. When consumer of created Observable calls `unsubscribe`,\n * that function will be called\n *\n * ## AnonymousSubscription\n *\n * `AnonymousSubscription` is simply an object with `unsubscribe` method on it. That method\n * will work the same as function\n *\n * ## void\n *\n * If created Observable does not have any resources to clean up, function does not have to\n * return anything.\n *\n * @interface\n * @name TeardownLogic\n * @noimport true\n ",
            "range": [
              14707,
              15462
            ],
            "loc": {
              "start": {
                "line": 410,
                "column": 0
              },
              "end": {
                "line": 436,
                "column": 3
              }
            }
          }
        ]
      },
      "specifiers": [],
      "source": null,
      "range": [
        14671,
        14706
      ],
      "loc": {
        "start": {
          "line": 408,
          "column": 0
        },
        "end": {
          "line": 409,
          "column": 1
        }
      },
      "leadingComments": [
        {
          "type": "Block",
          "value": "*\n * `ObservableInput` interface describes all values that are either an\n * {@link SubscribableOrPromise} or some kind of collection of values that\n * can be transformed to Observable emitting that values. Every operator that\n * accepts arguments annotated with this interface, can be also used with\n * parameters that are not necessarily RxJS Observables.\n *\n * `ObservableInput` extends {@link SubscribableOrPromise} with following types:\n *\n * ## Array\n *\n * Arrays can be interpreted as observables that emit all values in array one by one,\n * from left to right, and then complete immediately.\n *\n * ## Array-like\n *\n * Arrays passed to operators do not have to be built-in JavaScript Arrays. They\n * can be also, for example, `arguments` property available inside every function,\n * [DOM NodeList](https://developer.mozilla.org/pl/docs/Web/API/NodeList),\n * or, actually, any object that has `length` property (which is a number)\n * and stores values under non-negative (zero and up) integers.\n *\n * ## ES6 Iterable\n *\n * Operators will accept both built-in and custom ES6 Iterables, by treating them as\n * observables that emit all its values in order of iteration and then complete\n * when iteration ends. Note that contrary to arrays, Iterables do not have to\n * necessarily be finite, so creating Observables that never complete is possible as well.\n *\n * Note that you can make iterator an instance of Iterable by having it return itself\n * in `Symbol.iterator` method. It means that every operator accepting Iterables accepts,\n * though indirectly, iterators themselves as well. All native ES6 iterators are instances\n * of Iterable by default, so you do not have to implement their `Symbol.iterator` method\n * yourself.\n *\n * **TypeScript Iterable interface issue**\n *\n * TypeScript `ObservableInput` interface actually lacks type signature for Iterables,\n * because of issues it caused in some projects (see [this issue](https://github.com/ReactiveX/rxjs/issues/2306)).\n * If you want to use Iterable as argument for operator, cast it to `any` first.\n * Remember of course that, because of casting, you have to yourself ensure that passed\n * argument really implements said interface.\n *\n *\n * @example <caption>Use merge with arrays</caption>\n * Rx.Observable.merge([1, 2], [4], [5, 6])\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * // \"ta dam!\"\n *\n *\n * @example <caption>Use merge with array-like</caption>\n * Rx.Observable.merge({0: 1, 1: 2, length: 2}, {0: 3, length: 1})\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('nice, huh?')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // \"nice, huh?\"\n *\n * @example <caption>Use merge with an Iterable (Map)</caption>\n * const firstMap = new Map([[1, 'a'], [2, 'b']]);\n * const secondMap = new Map([[3, 'c'], [4, 'd']]);\n *\n * Rx.Observable.merge(\n *   firstMap,          // pass Iterable\n *   secondMap.values() // pass iterator, which is itself an Iterable\n * ).subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('yup!')\n * );\n *\n * // Logs\n * // [1, \"a\"]\n * // [2, \"b\"]\n * // \"c\"\n * // \"d\"\n * // \"yup!\"\n *\n * @example <caption>Use from with generator (returning infinite iterator)</caption>\n * // infinite stream of incrementing numbers\n * const infinite = function* () {\n *   let i = 0;\n *\n *   while (true) {\n *     yield i++;\n *   }\n * };\n *\n * Rx.Observable.from(infinite())\n * .take(3) // only take 3, cause this is infinite\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 0\n * // 1\n * // 2\n * // \"ta dam!\"\n *\n * @interface\n * @name ObservableInput\n * @noimport true\n ",
          "range": [
            10851,
            14670
          ],
          "loc": {
            "start": {
              "line": 284,
              "column": 0
            },
            "end": {
              "line": 407,
              "column": 3
            }
          }
        }
      ],
      "trailingComments": [
        {
          "type": "Block",
          "value": "*\n *\n * This interface describes what should be returned by function passed to Observable\n * constructor or static {@link create} function. Value of that interface will be used\n * to cancel subscription for given Observable.\n *\n * `TeardownLogic` can be:\n *\n * ## Function\n *\n * Function that takes no parameters. When consumer of created Observable calls `unsubscribe`,\n * that function will be called\n *\n * ## AnonymousSubscription\n *\n * `AnonymousSubscription` is simply an object with `unsubscribe` method on it. That method\n * will work the same as function\n *\n * ## void\n *\n * If created Observable does not have any resources to clean up, function does not have to\n * return anything.\n *\n * @interface\n * @name TeardownLogic\n * @noimport true\n ",
          "range": [
            14707,
            15462
          ],
          "loc": {
            "start": {
              "line": 410,
              "column": 0
            },
            "end": {
              "line": 436,
              "column": 3
            }
          }
        }
      ]
    },
    {
      "type": "ExportNamedDeclaration",
      "declaration": {
        "type": "ClassDeclaration",
        "id": {
          "type": "Identifier",
          "name": "TeardownLogicDoc",
          "range": [
            15476,
            15492
          ],
          "loc": {
            "start": {
              "line": 437,
              "column": 13
            },
            "end": {
              "line": 437,
              "column": 29
            }
          }
        },
        "superClass": null,
        "body": {
          "type": "ClassBody",
          "body": [],
          "range": [
            15493,
            15496
          ],
          "loc": {
            "start": {
              "line": 437,
              "column": 30
            },
            "end": {
              "line": 438,
              "column": 1
            }
          }
        },
        "range": [
          15470,
          15496
        ],
        "loc": {
          "start": {
            "line": 437,
            "column": 7
          },
          "end": {
            "line": 438,
            "column": 1
          }
        },
        "leadingComments": [
          {
            "type": "Block",
            "value": "*\n *\n * This interface describes what should be returned by function passed to Observable\n * constructor or static {@link create} function. Value of that interface will be used\n * to cancel subscription for given Observable.\n *\n * `TeardownLogic` can be:\n *\n * ## Function\n *\n * Function that takes no parameters. When consumer of created Observable calls `unsubscribe`,\n * that function will be called\n *\n * ## AnonymousSubscription\n *\n * `AnonymousSubscription` is simply an object with `unsubscribe` method on it. That method\n * will work the same as function\n *\n * ## void\n *\n * If created Observable does not have any resources to clean up, function does not have to\n * return anything.\n *\n * @interface\n * @name TeardownLogic\n * @noimport true\n ",
            "range": [
              14707,
              15462
            ],
            "loc": {
              "start": {
                "line": 410,
                "column": 0
              },
              "end": {
                "line": 436,
                "column": 3
              }
            }
          }
        ],
        "trailingComments": [
          {
            "type": "Line",
            "value": "# sourceMappingURL=MiscJSDoc.js.map",
            "range": [
              15497,
              15534
            ],
            "loc": {
              "start": {
                "line": 439,
                "column": 0
              },
              "end": {
                "line": 439,
                "column": 37
              }
            }
          }
        ]
      },
      "specifiers": [],
      "source": null,
      "range": [
        15463,
        15496
      ],
      "loc": {
        "start": {
          "line": 437,
          "column": 0
        },
        "end": {
          "line": 438,
          "column": 1
        }
      },
      "leadingComments": [
        {
          "type": "Block",
          "value": "*\n *\n * This interface describes what should be returned by function passed to Observable\n * constructor or static {@link create} function. Value of that interface will be used\n * to cancel subscription for given Observable.\n *\n * `TeardownLogic` can be:\n *\n * ## Function\n *\n * Function that takes no parameters. When consumer of created Observable calls `unsubscribe`,\n * that function will be called\n *\n * ## AnonymousSubscription\n *\n * `AnonymousSubscription` is simply an object with `unsubscribe` method on it. That method\n * will work the same as function\n *\n * ## void\n *\n * If created Observable does not have any resources to clean up, function does not have to\n * return anything.\n *\n * @interface\n * @name TeardownLogic\n * @noimport true\n ",
          "range": [
            14707,
            15462
          ],
          "loc": {
            "start": {
              "line": 410,
              "column": 0
            },
            "end": {
              "line": 436,
              "column": 3
            }
          }
        }
      ],
      "trailingComments": [
        {
          "type": "Line",
          "value": "# sourceMappingURL=MiscJSDoc.js.map",
          "range": [
            15497,
            15534
          ],
          "loc": {
            "start": {
              "line": 439,
              "column": 0
            },
            "end": {
              "line": 439,
              "column": 37
            }
          }
        }
      ]
    }
  ],
  "sourceType": "module",
  "range": [
    0,
    15496
  ],
  "loc": {
    "start": {
      "line": 1,
      "column": 0
    },
    "end": {
      "line": 438,
      "column": 1
    }
  },
  "comments": [
    {
      "type": "Block",
      "value": "*\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n ",
      "range": [
        112,
        206
      ],
      "loc": {
        "start": {
          "line": 4,
          "column": 0
        },
        "end": {
          "line": 8,
          "column": 3
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n     * Creates a new Observable, that will execute the specified function when an\n     * {@link Observer} subscribes to it.\n     *\n     * <span class=\"informal\">Create custom Observable, that does whatever you like.</span>\n     *\n     * <img src=\"./img/create.png\" width=\"100%\">\n     *\n     * `create` converts an `onSubscription` function to an actual Observable.\n     * Whenever someone subscribes to that Observable, the function will be called\n     * with an {@link Observer} instance as a first and only parameter. `onSubscription` should\n     * then invoke the Observers `next`, `error` and `complete` methods.\n     *\n     * Calling `next` with a value will emit that value to the observer. Calling `complete`\n     * means that Observable finished emitting and will not do anything else.\n     * Calling `error` means that something went wrong - value passed to `error` method should\n     * provide details on what exactly happened.\n     *\n     * A well-formed Observable can emit as many values as it needs via `next` method,\n     * but `complete` and `error` methods can be called only once and nothing else can be called\n     * thereafter. If you try to invoke `next`, `complete` or `error` methods after created\n     * Observable already completed or ended with an error, these calls will be ignored to\n     * preserve so called *Observable Contract*. Note that you are not required to call\n     * `complete` at any point - it is perfectly fine to create an Observable that never ends,\n     * depending on your needs.\n     *\n     * `onSubscription` can optionally return either a function or an object with\n     * `unsubscribe` method. In both cases function or method will be called when\n     * subscription to Observable is being cancelled and should be used to clean up all\n     * resources. So, for example, if you are using `setTimeout` in your custom\n     * Observable, when someone unsubscribes, you can clear planned timeout, so that\n     * it does not fire needlessly and browser (or other environment) does not waste\n     * computing power on timing event that no one will listen to anyways.\n     *\n     * Most of the times you should not need to use `create`, because existing\n     * operators allow you to create an Observable for most of the use cases.\n     * That being said, `create` is low-level mechanism allowing you to create\n     * any Observable, if you have very specific needs.\n     *\n     * **TypeScript signature issue**\n     *\n     * Because Observable extends class which already has defined static `create` function,\n     * but with different type signature, it was impossible to assign proper signature to\n     * `Observable.create`. Because of that, it has very general type `Function` and thus\n     * function passed to `create` will not be type checked, unless you explicitly state\n     * what signature it should have.\n     *\n     * When using TypeScript we recommend to declare type signature of function passed to\n     * `create` as `(observer: Observer) => TeardownLogic`, where {@link Observer}\n     * and {@link TeardownLogic} are interfaces provided by the library.\n     *\n     * @example <caption>Emit three numbers, then complete.</caption>\n     * var observable = Rx.Observable.create(function (observer) {\n     *   observer.next(1);\n     *   observer.next(2);\n     *   observer.next(3);\n     *   observer.complete();\n     * });\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('this is the end')\n     * );\n     *\n     * // Logs\n     * // 1\n     * // 2\n     * // 3\n     * // \"this is the end\"\n     *\n     *\n     * @example <caption>Emit an error</caption>\n     * const observable = Rx.Observable.create((observer) => {\n     *   observer.error('something went really wrong...');\n     * });\n     *\n     * observable.subscribe(\n     *   value => console.log(value), // will never be called\n     *   err => console.log(err),\n     *   () => console.log('complete') // will never be called\n     * );\n     *\n     * // Logs\n     * // \"something went really wrong...\"\n     *\n     *\n     * @example <caption>Return unsubscribe function</caption>\n     *\n     * const observable = Rx.Observable.create(observer => {\n     *   const id = setTimeout(() => observer.next('...'), 5000); // emit value after 5s\n     *\n     *   return () => { clearTimeout(id); console.log('cleared!'); };\n     * });\n     *\n     * const subscription = observable.subscribe(value => console.log(value));\n     *\n     * setTimeout(() => subscription.unsubscribe(), 3000); // cancel subscription after 3s\n     *\n     * // Logs:\n     * // \"cleared!\" after 3s\n     *\n     * // Never logs \"...\"\n     *\n     *\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @param {function(observer: Observer): TeardownLogic} onSubscription A\n     * function that accepts an Observer, and invokes its `next`,\n     * `error`, and `complete` methods as appropriate, and optionally returns some\n     * logic for cleaning up resources.\n     * @return {Observable} An Observable that, whenever subscribed, will execute the\n     * specified function.\n     * @static true\n     * @name create\n     * @owner Observable\n     ",
      "range": [
        240,
        5485
      ],
      "loc": {
        "start": {
          "line": 10,
          "column": 4
        },
        "end": {
          "line": 128,
          "column": 7
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n * An interface for a consumer of push-based notifications delivered by an\n * {@link Observable}.\n *\n * ```ts\n * interface Observer<T> {\n *   closed?: boolean;\n *   next: (value: T) => void;\n *   error: (err: any) => void;\n *   complete: () => void;\n * }\n * ```\n *\n * An object conforming to the Observer interface is usually\n * given to the `observable.subscribe(observer)` method, and the Observable will\n * call the Observer's `next(value)` method to provide notifications. A\n * well-behaved Observable will call an Observer's `complete()` method exactly\n * once or the Observer's `error(err)` method exactly once, as the last\n * notification delivered.\n *\n * @interface\n * @name Observer\n * @noimport true\n ",
      "range": [
        5583,
        6300
      ],
      "loc": {
        "start": {
          "line": 134,
          "column": 0
        },
        "end": {
          "line": 157,
          "column": 3
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n         * An optional flag to indicate whether this Observer, when used as a\n         * subscriber, has already been unsubscribed from its Observable.\n         * @type {boolean}\n         ",
      "range": [
        6356,
        6550
      ],
      "loc": {
        "start": {
          "line": 160,
          "column": 8
        },
        "end": {
          "line": 164,
          "column": 11
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n     * The callback to receive notifications of type `next` from the Observable,\n     * with a value. The Observable may call this method 0 or more times.\n     * @param {T} value The `next` value.\n     * @return {void}\n     ",
      "range": [
        6590,
        6820
      ],
      "loc": {
        "start": {
          "line": 167,
          "column": 4
        },
        "end": {
          "line": 172,
          "column": 7
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n     * The callback to receive notifications of type `error` from the Observable,\n     * with an attached {@link Error}. Notifies the Observer that the Observable\n     * has experienced an error condition.\n     * @param {any} err The `error` exception.\n     * @return {void}\n     ",
      "range": [
        6872,
        7158
      ],
      "loc": {
        "start": {
          "line": 176,
          "column": 4
        },
        "end": {
          "line": 182,
          "column": 7
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n     * The callback to receive a valueless notification of type `complete` from\n     * the Observable. Notifies the Observer that the Observable has finished\n     * sending push-based notifications.\n     * @return {void}\n     ",
      "range": [
        7209,
        7441
      ],
      "loc": {
        "start": {
          "line": 186,
          "column": 4
        },
        "end": {
          "line": 191,
          "column": 7
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n * `SubscribableOrPromise` interface describes values that behave like either\n * Observables or Promises. Every operator that accepts arguments annotated\n * with this interface, can be also used with parameters that are not necessarily\n * RxJS Observables.\n *\n * Following types of values might be passed to operators expecting this interface:\n *\n * ## Observable\n *\n * RxJS {@link Observable} instance.\n *\n * ## Observable-like (Subscribable)\n *\n * This might be any object that has `Symbol.observable` method. This method,\n * when called, should return object with `subscribe` method on it, which should\n * behave the same as RxJS `Observable.subscribe`.\n *\n * `Symbol.observable` is part of https://github.com/tc39/proposal-observable proposal.\n * Since currently it is not supported natively, and every symbol is equal only to itself,\n * you should use https://github.com/blesh/symbol-observable polyfill, when implementing\n * custom Observable-likes.\n *\n * **TypeScript Subscribable interface issue**\n *\n * Although TypeScript interface claims that Subscribable is an object that has `subscribe`\n * method declared directly on it, passing custom objects that have `subscribe`\n * method but not `Symbol.observable` method will fail at runtime. Conversely, passing\n * objects with `Symbol.observable` but without `subscribe` will fail at compile time\n * (if you use TypeScript).\n *\n * TypeScript has problem supporting interfaces with methods defined as symbol\n * properties. To get around that, you should implement `subscribe` directly on\n * passed object, and make `Symbol.observable` method simply return `this`. That way\n * everything will work as expected, and compiler will not complain. If you really\n * do not want to put `subscribe` directly on your object, you will have to type cast\n * it to `any`, before passing it to an operator.\n *\n * When this issue is resolved, Subscribable interface will only permit Observable-like\n * objects with `Symbol.observable` defined, no matter if they themselves implement\n * `subscribe` method or not.\n *\n * ## ES6 Promise\n *\n * Promise can be interpreted as Observable that emits value and completes\n * when it is resolved or errors when it is rejected.\n *\n * ## Promise-like (Thenable)\n *\n * Promises passed to operators do not have to be native ES6 Promises.\n * They can be implementations from popular Promise libraries, polyfills\n * or even custom ones. They just need to have `then` method that works\n * as the same as ES6 Promise `then`.\n *\n * @example <caption>Use merge and then map with non-RxJS observable</caption>\n * const nonRxJSObservable = {\n *   subscribe(observer) {\n *     observer.next(1000);\n *     observer.complete();\n *   },\n *   [Symbol.observable]() {\n *     return this;\n *   }\n * };\n *\n * Rx.Observable.merge(nonRxJSObservable)\n * .map(value => \"This value is \" + value)\n * .subscribe(result => console.log(result)); // Logs \"This value is 1000\"\n *\n *\n * @example <caption>Use combineLatest with ES6 Promise</caption>\n * Rx.Observable.combineLatest(Promise.resolve(5), Promise.resolve(10), Promise.resolve(15))\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n * // Logs\n * // [5, 10, 15]\n * // \"the end!\"\n *\n *\n * @interface\n * @name SubscribableOrPromise\n * @noimport true\n ",
      "range": [
        7490,
        10808
      ],
      "loc": {
        "start": {
          "line": 196,
          "column": 0
        },
        "end": {
          "line": 281,
          "column": 3
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n * `ObservableInput` interface describes all values that are either an\n * {@link SubscribableOrPromise} or some kind of collection of values that\n * can be transformed to Observable emitting that values. Every operator that\n * accepts arguments annotated with this interface, can be also used with\n * parameters that are not necessarily RxJS Observables.\n *\n * `ObservableInput` extends {@link SubscribableOrPromise} with following types:\n *\n * ## Array\n *\n * Arrays can be interpreted as observables that emit all values in array one by one,\n * from left to right, and then complete immediately.\n *\n * ## Array-like\n *\n * Arrays passed to operators do not have to be built-in JavaScript Arrays. They\n * can be also, for example, `arguments` property available inside every function,\n * [DOM NodeList](https://developer.mozilla.org/pl/docs/Web/API/NodeList),\n * or, actually, any object that has `length` property (which is a number)\n * and stores values under non-negative (zero and up) integers.\n *\n * ## ES6 Iterable\n *\n * Operators will accept both built-in and custom ES6 Iterables, by treating them as\n * observables that emit all its values in order of iteration and then complete\n * when iteration ends. Note that contrary to arrays, Iterables do not have to\n * necessarily be finite, so creating Observables that never complete is possible as well.\n *\n * Note that you can make iterator an instance of Iterable by having it return itself\n * in `Symbol.iterator` method. It means that every operator accepting Iterables accepts,\n * though indirectly, iterators themselves as well. All native ES6 iterators are instances\n * of Iterable by default, so you do not have to implement their `Symbol.iterator` method\n * yourself.\n *\n * **TypeScript Iterable interface issue**\n *\n * TypeScript `ObservableInput` interface actually lacks type signature for Iterables,\n * because of issues it caused in some projects (see [this issue](https://github.com/ReactiveX/rxjs/issues/2306)).\n * If you want to use Iterable as argument for operator, cast it to `any` first.\n * Remember of course that, because of casting, you have to yourself ensure that passed\n * argument really implements said interface.\n *\n *\n * @example <caption>Use merge with arrays</caption>\n * Rx.Observable.merge([1, 2], [4], [5, 6])\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * // \"ta dam!\"\n *\n *\n * @example <caption>Use merge with array-like</caption>\n * Rx.Observable.merge({0: 1, 1: 2, length: 2}, {0: 3, length: 1})\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('nice, huh?')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // \"nice, huh?\"\n *\n * @example <caption>Use merge with an Iterable (Map)</caption>\n * const firstMap = new Map([[1, 'a'], [2, 'b']]);\n * const secondMap = new Map([[3, 'c'], [4, 'd']]);\n *\n * Rx.Observable.merge(\n *   firstMap,          // pass Iterable\n *   secondMap.values() // pass iterator, which is itself an Iterable\n * ).subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('yup!')\n * );\n *\n * // Logs\n * // [1, \"a\"]\n * // [2, \"b\"]\n * // \"c\"\n * // \"d\"\n * // \"yup!\"\n *\n * @example <caption>Use from with generator (returning infinite iterator)</caption>\n * // infinite stream of incrementing numbers\n * const infinite = function* () {\n *   let i = 0;\n *\n *   while (true) {\n *     yield i++;\n *   }\n * };\n *\n * Rx.Observable.from(infinite())\n * .take(3) // only take 3, cause this is infinite\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 0\n * // 1\n * // 2\n * // \"ta dam!\"\n *\n * @interface\n * @name ObservableInput\n * @noimport true\n ",
      "range": [
        10851,
        14670
      ],
      "loc": {
        "start": {
          "line": 284,
          "column": 0
        },
        "end": {
          "line": 407,
          "column": 3
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n *\n * This interface describes what should be returned by function passed to Observable\n * constructor or static {@link create} function. Value of that interface will be used\n * to cancel subscription for given Observable.\n *\n * `TeardownLogic` can be:\n *\n * ## Function\n *\n * Function that takes no parameters. When consumer of created Observable calls `unsubscribe`,\n * that function will be called\n *\n * ## AnonymousSubscription\n *\n * `AnonymousSubscription` is simply an object with `unsubscribe` method on it. That method\n * will work the same as function\n *\n * ## void\n *\n * If created Observable does not have any resources to clean up, function does not have to\n * return anything.\n *\n * @interface\n * @name TeardownLogic\n * @noimport true\n ",
      "range": [
        14707,
        15462
      ],
      "loc": {
        "start": {
          "line": 410,
          "column": 0
        },
        "end": {
          "line": 436,
          "column": 3
        }
      }
    },
    {
      "type": "Line",
      "value": "# sourceMappingURL=MiscJSDoc.js.map",
      "range": [
        15497,
        15534
      ],
      "loc": {
        "start": {
          "line": 439,
          "column": 0
        },
        "end": {
          "line": 439,
          "column": 37
        }
      }
    }
  ]
}